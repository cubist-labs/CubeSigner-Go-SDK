// Package models provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package models

import (
	"encoding/json"
	"errors"
	"fmt"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	OidcScopes       = "Oidc.Scopes"
	SignerAuthScopes = "SignerAuth.Scopes"
)

// Defines values for AcceptedValueCode.
const (
	MfaRequired AcceptedValueCode = "MfaRequired"
)

// Defines values for AlertKind.
const (
	AlertKindBabylonEotsConcurrentSigning AlertKind = "BabylonEotsConcurrentSigning"
	AlertKindEth2ConcurrentBlockSigning   AlertKind = "Eth2ConcurrentBlockSigning"
	AlertKindPolicyChanges                AlertKind = "PolicyChanges"
)

// Defines values for AttestationConveyancePreference.
const (
	AttestationConveyancePreferenceDirect     AttestationConveyancePreference = "direct"
	AttestationConveyancePreferenceEnterprise AttestationConveyancePreference = "enterprise"
	AttestationConveyancePreferenceIndirect   AttestationConveyancePreference = "indirect"
	AttestationConveyancePreferenceNone       AttestationConveyancePreference = "none"
)

// Defines values for AuthSourceKind.
const (
	Oidc     AuthSourceKind = "oidc"
	Password AuthSourceKind = "password"
)

// Defines values for AuthenticatorAttachment.
const (
	CrossPlatform AuthenticatorAttachment = "cross-platform"
	Platform      AuthenticatorAttachment = "platform"
)

// Defines values for AuthenticatorTransport.
const (
	Ble      AuthenticatorTransport = "ble"
	Internal AuthenticatorTransport = "internal"
	Nfc      AuthenticatorTransport = "nfc"
	Usb      AuthenticatorTransport = "usb"
)

// Defines values for BabylonNetworkId.
const (
	Bbn1 BabylonNetworkId = "bbn1"
	Bbt4 BabylonNetworkId = "bbt4"
	Bbt5 BabylonNetworkId = "bbt5"
)

// Defines values for BabylonStakingRequestDepositAction.
const (
	Deposit BabylonStakingRequestDepositAction = "deposit"
)

// Defines values for BabylonStakingRequestEarlyUnbondAction.
const (
	EarlyUnbond BabylonStakingRequestEarlyUnbondAction = "early_unbond"
)

// Defines values for BabylonStakingRequestSlashDepositAction.
const (
	SlashDeposit BabylonStakingRequestSlashDepositAction = "slash_deposit"
)

// Defines values for BabylonStakingRequestSlashEarlyUnbondAction.
const (
	SlashEarlyUnbond BabylonStakingRequestSlashEarlyUnbondAction = "slash_early_unbond"
)

// Defines values for BabylonStakingRequestWithdrawEarlyUnbondAction.
const (
	WithdrawEarlyUnbond BabylonStakingRequestWithdrawEarlyUnbondAction = "withdraw_early_unbond"
)

// Defines values for BabylonStakingRequestWithdrawSlashingAction.
const (
	WithdrawSlashing BabylonStakingRequestWithdrawSlashingAction = "withdraw_slashing"
)

// Defines values for BabylonStakingRequestWithdrawTimelockAction.
const (
	WithdrawTimelock BabylonStakingRequestWithdrawTimelockAction = "withdraw_timelock"
)

// Defines values for BadGatewayErrorCode.
const (
	CallWebhookError                 BadGatewayErrorCode = "CallWebhookError"
	EsploraApiError                  BadGatewayErrorCode = "EsploraApiError"
	OAuthProviderError               BadGatewayErrorCode = "OAuthProviderError"
	OidcDisoveryFailed               BadGatewayErrorCode = "OidcDisoveryFailed"
	OidcIssuerJwkEndpointUnavailable BadGatewayErrorCode = "OidcIssuerJwkEndpointUnavailable"
	SentryApiError                   BadGatewayErrorCode = "SentryApiError"
	SmtpServerUnavailable            BadGatewayErrorCode = "SmtpServerUnavailable"
)

// Defines values for BadRequestErrorCode.
const (
	BadRequestErrorCodeAddKeyToRoleCountTooHigh                        BadRequestErrorCode = "AddKeyToRoleCountTooHigh"
	BadRequestErrorCodeAlienOwnerInvalid                               BadRequestErrorCode = "AlienOwnerInvalid"
	BadRequestErrorCodeAvaSignError                                    BadRequestErrorCode = "AvaSignError"
	BadRequestErrorCodeAvaSignHashError                                BadRequestErrorCode = "AvaSignHashError"
	BadRequestErrorCodeBabylonCovSign                                  BadRequestErrorCode = "BabylonCovSign"
	BadRequestErrorCodeBabylonStaking                                  BadRequestErrorCode = "BabylonStaking"
	BadRequestErrorCodeBabylonStakingFeePlusDustOverflow               BadRequestErrorCode = "BabylonStakingFeePlusDustOverflow"
	BadRequestErrorCodeBabylonStakingIncorrectKey                      BadRequestErrorCode = "BabylonStakingIncorrectKey"
	BadRequestErrorCodeBabylonStakingRegistrationRequiresTaproot       BadRequestErrorCode = "BabylonStakingRegistrationRequiresTaproot"
	BadRequestErrorCodeBabylonStakingSegwitNonDeposit                  BadRequestErrorCode = "BabylonStakingSegwitNonDeposit"
	BadRequestErrorCodeBadBtcMessageSignP2shFlag                       BadRequestErrorCode = "BadBtcMessageSignP2shFlag"
	BadRequestErrorCodeBtcSegwitHashError                              BadRequestErrorCode = "BtcSegwitHashError"
	BadRequestErrorCodeBtcSignError                                    BadRequestErrorCode = "BtcSignError"
	BadRequestErrorCodeBtcTaprootHashError                             BadRequestErrorCode = "BtcTaprootHashError"
	BadRequestErrorCodeCannotDeletePendingSubscription                 BadRequestErrorCode = "CannotDeletePendingSubscription"
	BadRequestErrorCodeCannotResendUserInvitation                      BadRequestErrorCode = "CannotResendUserInvitation"
	BadRequestErrorCodeCognitoUserAlreadyOrgMember                     BadRequestErrorCode = "CognitoUserAlreadyOrgMember"
	BadRequestErrorCodeContactNameInvalid                              BadRequestErrorCode = "ContactNameInvalid"
	BadRequestErrorCodeCustomStakingAmountNotAllowedForWrapperContract BadRequestErrorCode = "CustomStakingAmountNotAllowedForWrapperContract"
	BadRequestErrorCodeDeleteOidcUserError                             BadRequestErrorCode = "DeleteOidcUserError"
	BadRequestErrorCodeDeleteUserError                                 BadRequestErrorCode = "DeleteUserError"
	BadRequestErrorCodeDuplicateFieldEntry                             BadRequestErrorCode = "DuplicateFieldEntry"
	BadRequestErrorCodeEip712SignError                                 BadRequestErrorCode = "Eip712SignError"
	BadRequestErrorCodeEmailPasswordNotFound                           BadRequestErrorCode = "EmailPasswordNotFound"
	BadRequestErrorCodeEmptyAddress                                    BadRequestErrorCode = "EmptyAddress"
	BadRequestErrorCodeEmptyAllExceptOrgEventFilter                    BadRequestErrorCode = "EmptyAllExceptOrgEventFilter"
	BadRequestErrorCodeEmptyOneOfOrgEventFilter                        BadRequestErrorCode = "EmptyOneOfOrgEventFilter"
	BadRequestErrorCodeEmptyRuleError                                  BadRequestErrorCode = "EmptyRuleError"
	BadRequestErrorCodeEmptyScopes                                     BadRequestErrorCode = "EmptyScopes"
	BadRequestErrorCodeEmptyUpdateRequest                              BadRequestErrorCode = "EmptyUpdateRequest"
	BadRequestErrorCodeErc20ContractDisallowed                         BadRequestErrorCode = "Erc20ContractDisallowed"
	BadRequestErrorCodeEthersGetTransactionCountError                  BadRequestErrorCode = "EthersGetTransactionCountError"
	BadRequestErrorCodeEthersInvalidRpcUrl                             BadRequestErrorCode = "EthersInvalidRpcUrl"
	BadRequestErrorCodeExistingKeysViolateExclusiveKeyAccess           BadRequestErrorCode = "ExistingKeysViolateExclusiveKeyAccess"
	BadRequestErrorCodeExportDelayTooShort                             BadRequestErrorCode = "ExportDelayTooShort"
	BadRequestErrorCodeExportWindowTooLong                             BadRequestErrorCode = "ExportWindowTooLong"
	BadRequestErrorCodeFidoChallengeMfaMismatch                        BadRequestErrorCode = "FidoChallengeMfaMismatch"
	BadRequestErrorCodeFidoKeyAlreadyRegistered                        BadRequestErrorCode = "FidoKeyAlreadyRegistered"
	BadRequestErrorCodeFidoKeySignCountTooLow                          BadRequestErrorCode = "FidoKeySignCountTooLow"
	BadRequestErrorCodeFidoVerificationFailed                          BadRequestErrorCode = "FidoVerificationFailed"
	BadRequestErrorCodeGenericBadRequest                               BadRequestErrorCode = "GenericBadRequest"
	BadRequestErrorCodeIdpUserAlreadyExists                            BadRequestErrorCode = "IdpUserAlreadyExists"
	BadRequestErrorCodeImportKeyMissing                                BadRequestErrorCode = "ImportKeyMissing"
	BadRequestErrorCodeInvalidAbiMethods                               BadRequestErrorCode = "InvalidAbiMethods"
	BadRequestErrorCodeInvalidBabylonStakingPolicyParams               BadRequestErrorCode = "InvalidBabylonStakingPolicyParams"
	BadRequestErrorCodeInvalidBase32Value                              BadRequestErrorCode = "InvalidBase32Value"
	BadRequestErrorCodeInvalidBase58Value                              BadRequestErrorCode = "InvalidBase58Value"
	BadRequestErrorCodeInvalidBlobSignRequest                          BadRequestErrorCode = "InvalidBlobSignRequest"
	BadRequestErrorCodeInvalidBody                                     BadRequestErrorCode = "InvalidBody"
	BadRequestErrorCodeInvalidBtcAddressForChain                       BadRequestErrorCode = "InvalidBtcAddressForChain"
	BadRequestErrorCodeInvalidBtcTxReceiversEmptyAllowlist             BadRequestErrorCode = "InvalidBtcTxReceiversEmptyAllowlist"
	BadRequestErrorCodeInvalidCreateKeyCount                           BadRequestErrorCode = "InvalidCreateKeyCount"
	BadRequestErrorCodeInvalidCreateUserRequest                        BadRequestErrorCode = "InvalidCreateUserRequest"
	BadRequestErrorCodeInvalidDeriveKeyRequest                         BadRequestErrorCode = "InvalidDeriveKeyRequest"
	BadRequestErrorCodeInvalidEip191SignRequest                        BadRequestErrorCode = "InvalidEip191SignRequest"
	BadRequestErrorCodeInvalidEip712SignRequest                        BadRequestErrorCode = "InvalidEip712SignRequest"
	BadRequestErrorCodeInvalidEmail                                    BadRequestErrorCode = "InvalidEmail"
	BadRequestErrorCodeInvalidEth2SignRequest                          BadRequestErrorCode = "InvalidEth2SignRequest"
	BadRequestErrorCodeInvalidEth2SigningPolicyEpochRange              BadRequestErrorCode = "InvalidEth2SigningPolicyEpochRange"
	BadRequestErrorCodeInvalidEth2SigningPolicyOverlappingRule         BadRequestErrorCode = "InvalidEth2SigningPolicyOverlappingRule"
	BadRequestErrorCodeInvalidEth2SigningPolicySlotRange               BadRequestErrorCode = "InvalidEth2SigningPolicySlotRange"
	BadRequestErrorCodeInvalidEth2SigningPolicyTimestampRange          BadRequestErrorCode = "InvalidEth2SigningPolicyTimestampRange"
	BadRequestErrorCodeInvalidEthAddress                               BadRequestErrorCode = "InvalidEthAddress"
	BadRequestErrorCodeInvalidEvmSignRequest                           BadRequestErrorCode = "InvalidEvmSignRequest"
	BadRequestErrorCodeInvalidForkVersionLength                        BadRequestErrorCode = "InvalidForkVersionLength"
	BadRequestErrorCodeInvalidHexValue                                 BadRequestErrorCode = "InvalidHexValue"
	BadRequestErrorCodeInvalidIdentityProof                            BadRequestErrorCode = "InvalidIdentityProof"
	BadRequestErrorCodeInvalidJwt                                      BadRequestErrorCode = "InvalidJwt"
	BadRequestErrorCodeInvalidKeyId                                    BadRequestErrorCode = "InvalidKeyId"
	BadRequestErrorCodeInvalidKeyMaterial                              BadRequestErrorCode = "InvalidKeyMaterial"
	BadRequestErrorCodeInvalidKeyMaterialId                            BadRequestErrorCode = "InvalidKeyMaterialId"
	BadRequestErrorCodeInvalidKeyType                                  BadRequestErrorCode = "InvalidKeyType"
	BadRequestErrorCodeInvalidLength                                   BadRequestErrorCode = "InvalidLength"
	BadRequestErrorCodeInvalidLifetime                                 BadRequestErrorCode = "InvalidLifetime"
	BadRequestErrorCodeInvalidMemberRoleInRecipientAdd                 BadRequestErrorCode = "InvalidMemberRoleInRecipientAdd"
	BadRequestErrorCodeInvalidMemberRoleInUserAdd                      BadRequestErrorCode = "InvalidMemberRoleInUserAdd"
	BadRequestErrorCodeInvalidMessageType                              BadRequestErrorCode = "InvalidMessageType"
	BadRequestErrorCodeInvalidMetadataLength                           BadRequestErrorCode = "InvalidMetadataLength"
	BadRequestErrorCodeInvalidMfaPolicyCount                           BadRequestErrorCode = "InvalidMfaPolicyCount"
	BadRequestErrorCodeInvalidMfaPolicyGracePeriodTooLong              BadRequestErrorCode = "InvalidMfaPolicyGracePeriodTooLong"
	BadRequestErrorCodeInvalidMfaPolicyNumAllowedApprovers             BadRequestErrorCode = "InvalidMfaPolicyNumAllowedApprovers"
	BadRequestErrorCodeInvalidMfaPolicyNumAuthFactors                  BadRequestErrorCode = "InvalidMfaPolicyNumAuthFactors"
	BadRequestErrorCodeInvalidMfaReceipt                               BadRequestErrorCode = "InvalidMfaReceipt"
	BadRequestErrorCodeInvalidMfaReceiptInvalidOrgId                   BadRequestErrorCode = "InvalidMfaReceiptInvalidOrgId"
	BadRequestErrorCodeInvalidMfaReceiptOrgIdMissing                   BadRequestErrorCode = "InvalidMfaReceiptOrgIdMissing"
	BadRequestErrorCodeInvalidNotificationEndpointCount                BadRequestErrorCode = "InvalidNotificationEndpointCount"
	BadRequestErrorCodeInvalidNotificationUrlProtocol                  BadRequestErrorCode = "InvalidNotificationUrlProtocol"
	BadRequestErrorCodeInvalidOidcIdentity                             BadRequestErrorCode = "InvalidOidcIdentity"
	BadRequestErrorCodeInvalidOidcToken                                BadRequestErrorCode = "InvalidOidcToken"
	BadRequestErrorCodeInvalidOneTimeCode                              BadRequestErrorCode = "InvalidOneTimeCode"
	BadRequestErrorCodeInvalidOrgNameOrId                              BadRequestErrorCode = "InvalidOrgNameOrId"
	BadRequestErrorCodeInvalidOrgPolicyRepeatedRule                    BadRequestErrorCode = "InvalidOrgPolicyRepeatedRule"
	BadRequestErrorCodeInvalidOrgPolicyRule                            BadRequestErrorCode = "InvalidOrgPolicyRule"
	BadRequestErrorCodeInvalidPaginationToken                          BadRequestErrorCode = "InvalidPaginationToken"
	BadRequestErrorCodeInvalidPassword                                 BadRequestErrorCode = "InvalidPassword"
	BadRequestErrorCodeInvalidPolicyLogsRequest                        BadRequestErrorCode = "InvalidPolicyLogsRequest"
	BadRequestErrorCodeInvalidPolicyReference                          BadRequestErrorCode = "InvalidPolicyReference"
	BadRequestErrorCodeInvalidRange                                    BadRequestErrorCode = "InvalidRange"
	BadRequestErrorCodeInvalidRequireRoleSessionAllowlist              BadRequestErrorCode = "InvalidRequireRoleSessionAllowlist"
	BadRequestErrorCodeInvalidRestrictedScopes                         BadRequestErrorCode = "InvalidRestrictedScopes"
	BadRequestErrorCodeInvalidRoleNameOrId                             BadRequestErrorCode = "InvalidRoleNameOrId"
	BadRequestErrorCodeInvalidScopesForRoleSession                     BadRequestErrorCode = "InvalidScopesForRoleSession"
	BadRequestErrorCodeInvalidSolanaSignRequest                        BadRequestErrorCode = "InvalidSolanaSignRequest"
	BadRequestErrorCodeInvalidSs58Value                                BadRequestErrorCode = "InvalidSs58Value"
	BadRequestErrorCodeInvalidStakeDeposit                             BadRequestErrorCode = "InvalidStakeDeposit"
	BadRequestErrorCodeInvalidStakingAmount                            BadRequestErrorCode = "InvalidStakingAmount"
	BadRequestErrorCodeInvalidStellarAddress                           BadRequestErrorCode = "InvalidStellarAddress"
	BadRequestErrorCodeInvalidSuiTransaction                           BadRequestErrorCode = "InvalidSuiTransaction"
	BadRequestErrorCodeInvalidSuiTxReceiversEmptyAllowlist             BadRequestErrorCode = "InvalidSuiTxReceiversEmptyAllowlist"
	BadRequestErrorCodeInvalidTapNodeHash                              BadRequestErrorCode = "InvalidTapNodeHash"
	BadRequestErrorCodeInvalidTelegramData                             BadRequestErrorCode = "InvalidTelegramData"
	BadRequestErrorCodeInvalidTendermintRequest                        BadRequestErrorCode = "InvalidTendermintRequest"
	BadRequestErrorCodeInvalidTimeLockAlreadyInThePast                 BadRequestErrorCode = "InvalidTimeLockAlreadyInThePast"
	BadRequestErrorCodeInvalidTotpFailureLimit                         BadRequestErrorCode = "InvalidTotpFailureLimit"
	BadRequestErrorCodeInvalidUnstakeRequest                           BadRequestErrorCode = "InvalidUnstakeRequest"
	BadRequestErrorCodeInvalidUpdate                                   BadRequestErrorCode = "InvalidUpdate"
	BadRequestErrorCodeInvalidWasmPolicy                               BadRequestErrorCode = "InvalidWasmPolicy"
	BadRequestErrorCodeInvitationNoLongerValid                         BadRequestErrorCode = "InvitationNoLongerValid"
	BadRequestErrorCodeKeyNotFound                                     BadRequestErrorCode = "KeyNotFound"
	BadRequestErrorCodeLimitWindowTooLong                              BadRequestErrorCode = "LimitWindowTooLong"
	BadRequestErrorCodeMessageAlreadySigned                            BadRequestErrorCode = "MessageAlreadySigned"
	BadRequestErrorCodeMessageNotFound                                 BadRequestErrorCode = "MessageNotFound"
	BadRequestErrorCodeMessageRejected                                 BadRequestErrorCode = "MessageRejected"
	BadRequestErrorCodeMessageReplaced                                 BadRequestErrorCode = "MessageReplaced"
	BadRequestErrorCodeMfaRequestNotFound                              BadRequestErrorCode = "MfaRequestNotFound"
	BadRequestErrorCodeMmiChainIdMissing                               BadRequestErrorCode = "MmiChainIdMissing"
	BadRequestErrorCodeMmiRpcUrlMissing                                BadRequestErrorCode = "MmiRpcUrlMissing"
	BadRequestErrorCodeNameTaken                                       BadRequestErrorCode = "NameTaken"
	BadRequestErrorCodeNoOidcDataInProof                               BadRequestErrorCode = "NoOidcDataInProof"
	BadRequestErrorCodeNoSingleKeyForUser                              BadRequestErrorCode = "NoSingleKeyForUser"
	BadRequestErrorCodeOidcIdentityAlreadyExists                       BadRequestErrorCode = "OidcIdentityAlreadyExists"
	BadRequestErrorCodeOidcIssuerNoApplicableJwk                       BadRequestErrorCode = "OidcIssuerNoApplicableJwk"
	BadRequestErrorCodeOidcIssuerNotAllowed                            BadRequestErrorCode = "OidcIssuerNotAllowed"
	BadRequestErrorCodeOidcIssuerUnsupported                           BadRequestErrorCode = "OidcIssuerUnsupported"
	BadRequestErrorCodeOneTimeCodeExpired                              BadRequestErrorCode = "OneTimeCodeExpired"
	BadRequestErrorCodeOnlySpecifyOne                                  BadRequestErrorCode = "OnlySpecifyOne"
	BadRequestErrorCodeOptionalListEmpty                               BadRequestErrorCode = "OptionalListEmpty"
	BadRequestErrorCodeOrgInviteExistingUser                           BadRequestErrorCode = "OrgInviteExistingUser"
	BadRequestErrorCodeOrgIsNotOrgExport                               BadRequestErrorCode = "OrgIsNotOrgExport"
	BadRequestErrorCodeOrgNameTaken                                    BadRequestErrorCode = "OrgNameTaken"
	BadRequestErrorCodeOrgUserAlreadyExists                            BadRequestErrorCode = "OrgUserAlreadyExists"
	BadRequestErrorCodePaginationDataExpired                           BadRequestErrorCode = "PaginationDataExpired"
	BadRequestErrorCodePasswordAuthNotAllowedByInvitation              BadRequestErrorCode = "PasswordAuthNotAllowedByInvitation"
	BadRequestErrorCodePolicyDuplicateError                            BadRequestErrorCode = "PolicyDuplicateError"
	BadRequestErrorCodePolicyEngineDisabled                            BadRequestErrorCode = "PolicyEngineDisabled"
	BadRequestErrorCodePolicyKeyMismatch                               BadRequestErrorCode = "PolicyKeyMismatch"
	BadRequestErrorCodePolicyModified                                  BadRequestErrorCode = "PolicyModified"
	BadRequestErrorCodePolicyNameTaken                                 BadRequestErrorCode = "PolicyNameTaken"
	BadRequestErrorCodePolicyNotAttached                               BadRequestErrorCode = "PolicyNotAttached"
	BadRequestErrorCodePolicyNotFound                                  BadRequestErrorCode = "PolicyNotFound"
	BadRequestErrorCodePolicyRuleDisallowedByType                      BadRequestErrorCode = "PolicyRuleDisallowedByType"
	BadRequestErrorCodePolicyRuleKeyMismatch                           BadRequestErrorCode = "PolicyRuleKeyMismatch"
	BadRequestErrorCodePolicyStillAttached                             BadRequestErrorCode = "PolicyStillAttached"
	BadRequestErrorCodePolicyTypeDisallowed                            BadRequestErrorCode = "PolicyTypeDisallowed"
	BadRequestErrorCodePolicyVersionInvalid                            BadRequestErrorCode = "PolicyVersionInvalid"
	BadRequestErrorCodePolicyVersionMaxReached                         BadRequestErrorCode = "PolicyVersionMaxReached"
	BadRequestErrorCodePolicyVersionNotFound                           BadRequestErrorCode = "PolicyVersionNotFound"
	BadRequestErrorCodePsbtSigning                                     BadRequestErrorCode = "PsbtSigning"
	BadRequestErrorCodeQueryMetricsError                               BadRequestErrorCode = "QueryMetricsError"
	BadRequestErrorCodeQueryMetricsValidationError                     BadRequestErrorCode = "QueryMetricsValidationError"
	BadRequestErrorCodeRedundantDerivationPath                         BadRequestErrorCode = "RedundantDerivationPath"
	BadRequestErrorCodeReservedName                                    BadRequestErrorCode = "ReservedName"
	BadRequestErrorCodeRoleNameTaken                                   BadRequestErrorCode = "RoleNameTaken"
	BadRequestErrorCodeRoleNotFound                                    BadRequestErrorCode = "RoleNotFound"
	BadRequestErrorCodeSessionRoleMismatch                             BadRequestErrorCode = "SessionRoleMismatch"
	BadRequestErrorCodeSourceIpAllowlistEmpty                          BadRequestErrorCode = "SourceIpAllowlistEmpty"
	BadRequestErrorCodeSuiSenderMismatch                               BadRequestErrorCode = "SuiSenderMismatch"
	BadRequestErrorCodeTaprootSignError                                BadRequestErrorCode = "TaprootSignError"
	BadRequestErrorCodeThirdPartyUserAlreadyExists                     BadRequestErrorCode = "ThirdPartyUserAlreadyExists"
	BadRequestErrorCodeThirdPartyUserNotFound                          BadRequestErrorCode = "ThirdPartyUserNotFound"
	BadRequestErrorCodeTokenRequestError                               BadRequestErrorCode = "TokenRequestError"
	BadRequestErrorCodeTooManyFailedLogins                             BadRequestErrorCode = "TooManyFailedLogins"
	BadRequestErrorCodeTooManyRequests                                 BadRequestErrorCode = "TooManyRequests"
	BadRequestErrorCodeTooManyResets                                   BadRequestErrorCode = "TooManyResets"
	BadRequestErrorCodeUnableToAccessSmtpRelay                         BadRequestErrorCode = "UnableToAccessSmtpRelay"
	BadRequestErrorCodeUnsupportedLegacyCognitoSession                 BadRequestErrorCode = "UnsupportedLegacyCognitoSession"
	BadRequestErrorCodeUserAlreadyExists                               BadRequestErrorCode = "UserAlreadyExists"
	BadRequestErrorCodeUserEmailNotConfigured                          BadRequestErrorCode = "UserEmailNotConfigured"
	BadRequestErrorCodeUserExportDerivedKey                            BadRequestErrorCode = "UserExportDerivedKey"
	BadRequestErrorCodeUserExportInProgress                            BadRequestErrorCode = "UserExportInProgress"
	BadRequestErrorCodeUserExportPublicKeyInvalid                      BadRequestErrorCode = "UserExportPublicKeyInvalid"
	BadRequestErrorCodeUserNotFound                                    BadRequestErrorCode = "UserNotFound"
	BadRequestErrorCodeWebhookPolicyDisallowedHeaders                  BadRequestErrorCode = "WebhookPolicyDisallowedHeaders"
	BadRequestErrorCodeWebhookPolicyDisallowedUrlHost                  BadRequestErrorCode = "WebhookPolicyDisallowedUrlHost"
	BadRequestErrorCodeWebhookPolicyDisallowedUrlScheme                BadRequestErrorCode = "WebhookPolicyDisallowedUrlScheme"
	BadRequestErrorCodeWebhookPolicyTimeoutOutOfBounds                 BadRequestErrorCode = "WebhookPolicyTimeoutOutOfBounds"
)

// Defines values for BillingEvent.
const (
	BillingEventAboutMe                     BillingEvent = "AboutMe"
	BillingEventAddKeysToRole               BillingEvent = "AddKeysToRole"
	BillingEventAddOidcIdentity             BillingEvent = "AddOidcIdentity"
	BillingEventAddUserToRole               BillingEvent = "AddUserToRole"
	BillingEventAuthMigrationIdentityAdd    BillingEvent = "AuthMigrationIdentityAdd"
	BillingEventAuthMigrationIdentityRemove BillingEvent = "AuthMigrationIdentityRemove"
	BillingEventAvaSerializedTxSign         BillingEvent = "AvaSerializedTxSign"
	BillingEventAvaSign                     BillingEvent = "AvaSign"
	BillingEventBabylonCovSign              BillingEvent = "BabylonCovSign"
	BillingEventBabylonRegistration         BillingEvent = "BabylonRegistration"
	BillingEventBabylonStaking              BillingEvent = "BabylonStaking"
	BillingEventBlobSign                    BillingEvent = "BlobSign"
	BillingEventBtcMessageSign              BillingEvent = "BtcMessageSign"
	BillingEventBtcSign                     BillingEvent = "BtcSign"
	BillingEventConfigureEmail              BillingEvent = "ConfigureEmail"
	BillingEventCounts                      BillingEvent = "Counts"
	BillingEventCreateContact               BillingEvent = "CreateContact"
	BillingEventCreateEotsNonces            BillingEvent = "CreateEotsNonces"
	BillingEventCreateKey                   BillingEvent = "CreateKey"
	BillingEventCreateKeyImportKey          BillingEvent = "CreateKeyImportKey"
	BillingEventCreateOidcUser              BillingEvent = "CreateOidcUser"
	BillingEventCreateOrg                   BillingEvent = "CreateOrg"
	BillingEventCreatePolicy                BillingEvent = "CreatePolicy"
	BillingEventCreatePolicyImportKey       BillingEvent = "CreatePolicyImportKey"
	BillingEventCreateProofCubeSigner       BillingEvent = "CreateProofCubeSigner"
	BillingEventCreateProofOidc             BillingEvent = "CreateProofOidc"
	BillingEventCreateRole                  BillingEvent = "CreateRole"
	BillingEventCreateSession               BillingEvent = "CreateSession"
	BillingEventCreateToken                 BillingEvent = "CreateToken"
	BillingEventCube3signerHeartbeat        BillingEvent = "Cube3signerHeartbeat"
	BillingEventDeleteContact               BillingEvent = "DeleteContact"
	BillingEventDeleteKey                   BillingEvent = "DeleteKey"
	BillingEventDeleteOidcUser              BillingEvent = "DeleteOidcUser"
	BillingEventDeletePolicy                BillingEvent = "DeletePolicy"
	BillingEventDeletePolicySecret          BillingEvent = "DeletePolicySecret"
	BillingEventDeleteRole                  BillingEvent = "DeleteRole"
	BillingEventDeleteUser                  BillingEvent = "DeleteUser"
	BillingEventDeriveKey                   BillingEvent = "DeriveKey"
	BillingEventEip191Sign                  BillingEvent = "Eip191Sign"
	BillingEventEip712Sign                  BillingEvent = "Eip712Sign"
	BillingEventEmailOtpAuth                BillingEvent = "EmailOtpAuth"
	BillingEventEotsSign                    BillingEvent = "EotsSign"
	BillingEventEsploraApiCall              BillingEvent = "EsploraApiCall"
	BillingEventEth1Sign                    BillingEvent = "Eth1Sign"
	BillingEventEth2Sign                    BillingEvent = "Eth2Sign"
	BillingEventGetContact                  BillingEvent = "GetContact"
	BillingEventGetKey                      BillingEvent = "GetKey"
	BillingEventGetKeyByMaterialId          BillingEvent = "GetKeyByMaterialId"
	BillingEventGetOrg                      BillingEvent = "GetOrg"
	BillingEventGetOrgExport                BillingEvent = "GetOrgExport"
	BillingEventGetPolicy                   BillingEvent = "GetPolicy"
	BillingEventGetPolicyLogs               BillingEvent = "GetPolicyLogs"
	BillingEventGetPolicySecrets            BillingEvent = "GetPolicySecrets"
	BillingEventGetRole                     BillingEvent = "GetRole"
	BillingEventGetRoleKey                  BillingEvent = "GetRoleKey"
	BillingEventGetSession                  BillingEvent = "GetSession"
	BillingEventGetUser                     BillingEvent = "GetUser"
	BillingEventIdpAuthenticate             BillingEvent = "IdpAuthenticate"
	BillingEventIdpPasswordResetConfirm     BillingEvent = "IdpPasswordResetConfirm"
	BillingEventImportKey                   BillingEvent = "ImportKey"
	BillingEventInvitationAccept            BillingEvent = "InvitationAccept"
	BillingEventInvite                      BillingEvent = "Invite"
	BillingEventInvokePolicy                BillingEvent = "InvokePolicy"
	BillingEventKeyCreated                  BillingEvent = "KeyCreated"
	BillingEventKeyImported                 BillingEvent = "KeyImported"
	BillingEventListContacts                BillingEvent = "ListContacts"
	BillingEventListHistoricalKeyTx         BillingEvent = "ListHistoricalKeyTx"
	BillingEventListHistoricalRoleTx        BillingEvent = "ListHistoricalRoleTx"
	BillingEventListKeyRoles                BillingEvent = "ListKeyRoles"
	BillingEventListKeys                    BillingEvent = "ListKeys"
	BillingEventListOidcIdentities          BillingEvent = "ListOidcIdentities"
	BillingEventListPolicies                BillingEvent = "ListPolicies"
	BillingEventListRoleKeys                BillingEvent = "ListRoleKeys"
	BillingEventListRoleUsers               BillingEvent = "ListRoleUsers"
	BillingEventListRoles                   BillingEvent = "ListRoles"
	BillingEventListSessions                BillingEvent = "ListSessions"
	BillingEventListTokenKeys               BillingEvent = "ListTokenKeys"
	BillingEventListUsers                   BillingEvent = "ListUsers"
	BillingEventMfaApproveCs                BillingEvent = "MfaApproveCs"
	BillingEventMfaApproveFidoComplete      BillingEvent = "MfaApproveFidoComplete"
	BillingEventMfaApproveTotp              BillingEvent = "MfaApproveTotp"
	BillingEventMfaEmailComplete            BillingEvent = "MfaEmailComplete"
	BillingEventMfaEmailInit                BillingEvent = "MfaEmailInit"
	BillingEventMfaFidoInit                 BillingEvent = "MfaFidoInit"
	BillingEventMfaGet                      BillingEvent = "MfaGet"
	BillingEventMfaList                     BillingEvent = "MfaList"
	BillingEventMfaRejectCs                 BillingEvent = "MfaRejectCs"
	BillingEventMfaRejectFidoComplete       BillingEvent = "MfaRejectFidoComplete"
	BillingEventMfaRejectTotp               BillingEvent = "MfaRejectTotp"
	BillingEventMmi                         BillingEvent = "Mmi"
	BillingEventMmiMessageDelete            BillingEvent = "MmiMessageDelete"
	BillingEventMmiMessageGet               BillingEvent = "MmiMessageGet"
	BillingEventMmiMessageList              BillingEvent = "MmiMessageList"
	BillingEventMmiMessageReject            BillingEvent = "MmiMessageReject"
	BillingEventMmiMessageSign              BillingEvent = "MmiMessageSign"
	BillingEventOAuth2TokenRefresh          BillingEvent = "OAuth2TokenRefresh"
	BillingEventOauth2Twitter               BillingEvent = "Oauth2Twitter"
	BillingEventOidcAuth                    BillingEvent = "OidcAuth"
	BillingEventPasskeyAuthComplete         BillingEvent = "PasskeyAuthComplete"
	BillingEventPsbtLegacyInputSign         BillingEvent = "PsbtLegacyInputSign"
	BillingEventPsbtSegwitInputSign         BillingEvent = "PsbtSegwitInputSign"
	BillingEventPsbtSign                    BillingEvent = "PsbtSign"
	BillingEventPsbtTaprootInputSign        BillingEvent = "PsbtTaprootInputSign"
	BillingEventQueryMetrics                BillingEvent = "QueryMetrics"
	BillingEventRemoveKeyFromRole           BillingEvent = "RemoveKeyFromRole"
	BillingEventRemoveOidcIdentity          BillingEvent = "RemoveOidcIdentity"
	BillingEventRemoveUserFromRole          BillingEvent = "RemoveUserFromRole"
	BillingEventRevokeCurrentSession        BillingEvent = "RevokeCurrentSession"
	BillingEventRevokeSession               BillingEvent = "RevokeSession"
	BillingEventRevokeSessions              BillingEvent = "RevokeSessions"
	BillingEventSetPolicySecret             BillingEvent = "SetPolicySecret"
	BillingEventSignerSessionRefresh        BillingEvent = "SignerSessionRefresh"
	BillingEventSolanaSign                  BillingEvent = "SolanaSign"
	BillingEventStake                       BillingEvent = "Stake"
	BillingEventSuiSign                     BillingEvent = "SuiSign"
	BillingEventTaprootSign                 BillingEvent = "TaprootSign"
	BillingEventTelegramAuth                BillingEvent = "TelegramAuth"
	BillingEventTendermintSign              BillingEvent = "TendermintSign"
	BillingEventUnstake                     BillingEvent = "Unstake"
	BillingEventUpdateContact               BillingEvent = "UpdateContact"
	BillingEventUpdateKey                   BillingEvent = "UpdateKey"
	BillingEventUpdateMembership            BillingEvent = "UpdateMembership"
	BillingEventUpdateOrg                   BillingEvent = "UpdateOrg"
	BillingEventUpdatePolicy                BillingEvent = "UpdatePolicy"
	BillingEventUpdatePolicySecrets         BillingEvent = "UpdatePolicySecrets"
	BillingEventUpdateRole                  BillingEvent = "UpdateRole"
	BillingEventUploadWasmPolicy            BillingEvent = "UploadWasmPolicy"
	BillingEventUserDeleteFido              BillingEvent = "UserDeleteFido"
	BillingEventUserDeleteTotp              BillingEvent = "UserDeleteTotp"
	BillingEventUserExportComplete          BillingEvent = "UserExportComplete"
	BillingEventUserExportDelete            BillingEvent = "UserExportDelete"
	BillingEventUserExportInit              BillingEvent = "UserExportInit"
	BillingEventUserExportList              BillingEvent = "UserExportList"
	BillingEventUserRegisterFidoComplete    BillingEvent = "UserRegisterFidoComplete"
	BillingEventUserRegisterFidoInit        BillingEvent = "UserRegisterFidoInit"
	BillingEventUserResetTotpComplete       BillingEvent = "UserResetTotpComplete"
	BillingEventUserResetTotpInit           BillingEvent = "UserResetTotpInit"
	BillingEventUserVerifyTotp              BillingEvent = "UserVerifyTotp"
	BillingEventVerifyProof                 BillingEvent = "VerifyProof"
)

// Defines values for BtcChain.
const (
	Btc       BtcChain = "btc"
	BtcSignet BtcChain = "btc_signet"
)

// Defines values for BtcSighashType.
const (
	BtcSighashTypeAll                    BtcSighashType = "All"
	BtcSighashTypeAllPlusAnyoneCanPay    BtcSighashType = "AllPlusAnyoneCanPay"
	BtcSighashTypeNone                   BtcSighashType = "None"
	BtcSighashTypeNonePlusAnyoneCanPay   BtcSighashType = "NonePlusAnyoneCanPay"
	BtcSighashTypeSingle                 BtcSighashType = "Single"
	BtcSighashTypeSinglePlusAnyoneCanPay BtcSighashType = "SinglePlusAnyoneCanPay"
)

// Defines values for ConfiguredMfaFidoType.
const (
	ConfiguredMfaFidoTypeFido ConfiguredMfaFidoType = "fido"
)

// Defines values for ConfiguredMfaTotpType.
const (
	ConfiguredMfaTotpTypeTotp ConfiguredMfaTotpType = "totp"
)

// Defines values for ConflictErrorCode.
const (
	ConcurrentLockCreation      ConflictErrorCode = "ConcurrentLockCreation"
	ConcurrentRequestDisallowed ConflictErrorCode = "ConcurrentRequestDisallowed"
)

// Defines values for DepositType.
const (
	Canonical DepositType = "Canonical"
	Wrapper   DepositType = "Wrapper"
)

// Defines values for EsploraRequestNetwork.
const (
	EsploraRequestNetworkMainnet EsploraRequestNetwork = "mainnet"
	EsploraRequestNetworkSignet  EsploraRequestNetwork = "signet"
	EsploraRequestNetworkTestnet EsploraRequestNetwork = "testnet"
)

// Defines values for EvmChain.
const (
	Arbitrum        EvmChain = "arbitrum"
	Avalanche       EvmChain = "avalanche"
	AvalancheFuji   EvmChain = "avalanche_fuji"
	Base            EvmChain = "base"
	Bsc             EvmChain = "bsc"
	Eth             EvmChain = "eth"
	EthHolesky      EvmChain = "eth_holesky"
	EthSepolia      EvmChain = "eth_sepolia"
	Fantom          EvmChain = "fantom"
	Flare           EvmChain = "flare"
	Linea           EvmChain = "linea"
	Optimism        EvmChain = "optimism"
	OptimismSepolia EvmChain = "optimism_sepolia"
	Polygon         EvmChain = "polygon"
)

// Defines values for EvmTxDepositErrorCode.
const (
	EvmTxDepositEmptyChainId                    EvmTxDepositErrorCode = "EvmTxDepositEmptyChainId"
	EvmTxDepositEmptyData                       EvmTxDepositErrorCode = "EvmTxDepositEmptyData"
	EvmTxDepositEmptyReceiver                   EvmTxDepositErrorCode = "EvmTxDepositEmptyReceiver"
	EvmTxDepositInvalidDepositEncoding          EvmTxDepositErrorCode = "EvmTxDepositInvalidDepositEncoding"
	EvmTxDepositInvalidValidatorKey             EvmTxDepositErrorCode = "EvmTxDepositInvalidValidatorKey"
	EvmTxDepositMissingDepositArg               EvmTxDepositErrorCode = "EvmTxDepositMissingDepositArg"
	EvmTxDepositNoAbi                           EvmTxDepositErrorCode = "EvmTxDepositNoAbi"
	EvmTxDepositNoDepositFunction               EvmTxDepositErrorCode = "EvmTxDepositNoDepositFunction"
	EvmTxDepositReceiverMismatch                EvmTxDepositErrorCode = "EvmTxDepositReceiverMismatch"
	EvmTxDepositUnexpectedDataLength            EvmTxDepositErrorCode = "EvmTxDepositUnexpectedDataLength"
	EvmTxDepositUnexpectedFunctionName          EvmTxDepositErrorCode = "EvmTxDepositUnexpectedFunctionName"
	EvmTxDepositUnexpectedValidatorKey          EvmTxDepositErrorCode = "EvmTxDepositUnexpectedValidatorKey"
	EvmTxDepositUnexpectedValue                 EvmTxDepositErrorCode = "EvmTxDepositUnexpectedValue"
	EvmTxDepositUnexpectedWithdrawalCredentials EvmTxDepositErrorCode = "EvmTxDepositUnexpectedWithdrawalCredentials"
	EvmTxDepositUnresolvedRole                  EvmTxDepositErrorCode = "EvmTxDepositUnresolvedRole"
	EvmTxDepositValidatorKeyNotInRole           EvmTxDepositErrorCode = "EvmTxDepositValidatorKeyNotInRole"
	EvmTxDepositWrongDepositArgType             EvmTxDepositErrorCode = "EvmTxDepositWrongDepositArgType"
)

// Defines values for ExecutionSource.
const (
	SignRequest    ExecutionSource = "SignRequest"
	UserInvocation ExecutionSource = "UserInvocation"
)

// Defines values for ExplicitScopes.
const (
	Export                              ExplicitScopes = "export:*"
	ExportUser                          ExplicitScopes = "export:user:*"
	ExportUserComplete                  ExplicitScopes = "export:user:complete"
	ExportUserInit                      ExplicitScopes = "export:user:init"
	Manage                              ExplicitScopes = "manage:*"
	ManageAuthMigrationIdentityAdd      ExplicitScopes = "manage:auth_migration:identity:add"
	ManageAuthMigrationIdentityRemove   ExplicitScopes = "manage:auth_migration:identity:remove"
	ManageContact                       ExplicitScopes = "manage:contact:*"
	ManageContactCreate                 ExplicitScopes = "manage:contact:create"
	ManageContactDelete                 ExplicitScopes = "manage:contact:delete"
	ManageContactGet                    ExplicitScopes = "manage:contact:get"
	ManageContactList                   ExplicitScopes = "manage:contact:list"
	ManageContactUpdate                 ExplicitScopes = "manage:contact:update:*"
	ManageContactUpdateAddresses        ExplicitScopes = "manage:contact:update:addresses"
	ManageContactUpdateEditPolicy       ExplicitScopes = "manage:contact:update:editPolicy"
	ManageContactUpdateMetadata         ExplicitScopes = "manage:contact:update:metadata"
	ManageContactUpdateName             ExplicitScopes = "manage:contact:update:name"
	ManageContactUpdateOwner            ExplicitScopes = "manage:contact:update:owner"
	ManageEmail                         ExplicitScopes = "manage:email"
	ManageExport                        ExplicitScopes = "manage:export:*"
	ManageExportOrg                     ExplicitScopes = "manage:export:org:*"
	ManageExportOrgGet                  ExplicitScopes = "manage:export:org:get"
	ManageExportUser                    ExplicitScopes = "manage:export:user:*"
	ManageExportUserDelete              ExplicitScopes = "manage:export:user:delete"
	ManageExportUserList                ExplicitScopes = "manage:export:user:list"
	ManageIdentity                      ExplicitScopes = "manage:identity:*"
	ManageIdentityAdd                   ExplicitScopes = "manage:identity:add"
	ManageIdentityList                  ExplicitScopes = "manage:identity:list"
	ManageIdentityRemove                ExplicitScopes = "manage:identity:remove"
	ManageIdentityVerify                ExplicitScopes = "manage:identity:verify"
	ManageKey                           ExplicitScopes = "manage:key:*"
	ManageKeyCreate                     ExplicitScopes = "manage:key:create"
	ManageKeyDelete                     ExplicitScopes = "manage:key:delete"
	ManageKeyGet                        ExplicitScopes = "manage:key:get"
	ManageKeyHistoryTxList              ExplicitScopes = "manage:key:history:tx:list"
	ManageKeyImport                     ExplicitScopes = "manage:key:import"
	ManageKeyList                       ExplicitScopes = "manage:key:list"
	ManageKeyListRoles                  ExplicitScopes = "manage:key:listRoles"
	ManageKeyReadonly                   ExplicitScopes = "manage:key:readonly"
	ManageKeyUpdate                     ExplicitScopes = "manage:key:update:*"
	ManageKeyUpdateEditPolicy           ExplicitScopes = "manage:key:update:editPolicy"
	ManageKeyUpdateEnabled              ExplicitScopes = "manage:key:update:enabled"
	ManageKeyUpdateMetadata             ExplicitScopes = "manage:key:update:metadata"
	ManageKeyUpdateOwner                ExplicitScopes = "manage:key:update:owner"
	ManageKeyUpdatePolicy               ExplicitScopes = "manage:key:update:policy"
	ManageMfa                           ExplicitScopes = "manage:mfa:*"
	ManageMfaList                       ExplicitScopes = "manage:mfa:list"
	ManageMfaReadonly                   ExplicitScopes = "manage:mfa:readonly"
	ManageMfaRegister                   ExplicitScopes = "manage:mfa:register:*"
	ManageMfaRegisterFido               ExplicitScopes = "manage:mfa:register:fido"
	ManageMfaRegisterTotp               ExplicitScopes = "manage:mfa:register:totp"
	ManageMfaUnregister                 ExplicitScopes = "manage:mfa:unregister:*"
	ManageMfaUnregisterFido             ExplicitScopes = "manage:mfa:unregister:fido"
	ManageMfaUnregisterTotp             ExplicitScopes = "manage:mfa:unregister:totp"
	ManageMfaVerify                     ExplicitScopes = "manage:mfa:verify:*"
	ManageMfaVerifyTotp                 ExplicitScopes = "manage:mfa:verify:totp"
	ManageMfaVote                       ExplicitScopes = "manage:mfa:vote:*"
	ManageMfaVoteCs                     ExplicitScopes = "manage:mfa:vote:cs"
	ManageMfaVoteEmail                  ExplicitScopes = "manage:mfa:vote:email"
	ManageMfaVoteFido                   ExplicitScopes = "manage:mfa:vote:fido"
	ManageMfaVoteTotp                   ExplicitScopes = "manage:mfa:vote:totp"
	ManageMmi                           ExplicitScopes = "manage:mmi:*"
	ManageMmiDelete                     ExplicitScopes = "manage:mmi:delete"
	ManageMmiGet                        ExplicitScopes = "manage:mmi:get"
	ManageMmiList                       ExplicitScopes = "manage:mmi:list"
	ManageMmiReadonly                   ExplicitScopes = "manage:mmi:readonly"
	ManageMmiReject                     ExplicitScopes = "manage:mmi:reject"
	ManageOrg                           ExplicitScopes = "manage:org:*"
	ManageOrgAddUser                    ExplicitScopes = "manage:org:addUser"
	ManageOrgCreate                     ExplicitScopes = "manage:org:create"
	ManageOrgDeleteUser                 ExplicitScopes = "manage:org:deleteUser"
	ManageOrgGet                        ExplicitScopes = "manage:org:get"
	ManageOrgInviteAlien                ExplicitScopes = "manage:org:inviteAlien"
	ManageOrgInviteUser                 ExplicitScopes = "manage:org:inviteUser"
	ManageOrgListUsers                  ExplicitScopes = "manage:org:listUsers"
	ManageOrgMetricsQuery               ExplicitScopes = "manage:org:metrics:query"
	ManageOrgReadonly                   ExplicitScopes = "manage:org:readonly"
	ManageOrgUpdateMembership           ExplicitScopes = "manage:org:updateMembership"
	ManageOrgUserGet                    ExplicitScopes = "manage:org:user:get"
	ManagePolicy                        ExplicitScopes = "manage:policy:*"
	ManagePolicyCreate                  ExplicitScopes = "manage:policy:create"
	ManagePolicyCreateImportKey         ExplicitScopes = "manage:policy:createImportKey"
	ManagePolicyDelete                  ExplicitScopes = "manage:policy:delete"
	ManagePolicyGet                     ExplicitScopes = "manage:policy:get"
	ManagePolicyInvoke                  ExplicitScopes = "manage:policy:invoke"
	ManagePolicyList                    ExplicitScopes = "manage:policy:list"
	ManagePolicySecrets                 ExplicitScopes = "manage:policy:secrets:*"
	ManagePolicySecretsGet              ExplicitScopes = "manage:policy:secrets:get"
	ManagePolicySecretsUpdate           ExplicitScopes = "manage:policy:secrets:update:*"
	ManagePolicySecretsUpdateEditPolicy ExplicitScopes = "manage:policy:secrets:update:editPolicy"
	ManagePolicySecretsUpdateValues     ExplicitScopes = "manage:policy:secrets:update:values"
	ManagePolicyUpdate                  ExplicitScopes = "manage:policy:update:*"
	ManagePolicyUpdateEditPolicy        ExplicitScopes = "manage:policy:update:editPolicy"
	ManagePolicyUpdateMetadata          ExplicitScopes = "manage:policy:update:metadata"
	ManagePolicyUpdateName              ExplicitScopes = "manage:policy:update:name"
	ManagePolicyUpdateOwner             ExplicitScopes = "manage:policy:update:owner"
	ManagePolicyUpdateRule              ExplicitScopes = "manage:policy:update:rule"
	ManagePolicyWasm                    ExplicitScopes = "manage:policy:wasm:*"
	ManagePolicyWasmUpload              ExplicitScopes = "manage:policy:wasm:upload"
	ManageReadonly                      ExplicitScopes = "manage:readonly"
	ManageRole                          ExplicitScopes = "manage:role:*"
	ManageRoleCreate                    ExplicitScopes = "manage:role:create"
	ManageRoleDelete                    ExplicitScopes = "manage:role:delete"
	ManageRoleGet                       ExplicitScopes = "manage:role:get:*"
	ManageRoleGetKeys                   ExplicitScopes = "manage:role:get:keys"
	ManageRoleGetKeysGet                ExplicitScopes = "manage:role:get:keys:get"
	ManageRoleGetKeysList               ExplicitScopes = "manage:role:get:keys:list"
	ManageRoleGetUsers                  ExplicitScopes = "manage:role:get:users"
	ManageRoleHistoryTxList             ExplicitScopes = "manage:role:history:tx:list"
	ManageRoleList                      ExplicitScopes = "manage:role:list"
	ManageRoleReadonly                  ExplicitScopes = "manage:role:readonly"
	ManageRoleUpdate                    ExplicitScopes = "manage:role:update:*"
	ManageRoleUpdateEditPolicy          ExplicitScopes = "manage:role:update:editPolicy"
	ManageRoleUpdateEnabled             ExplicitScopes = "manage:role:update:enabled"
	ManageRoleUpdateKey                 ExplicitScopes = "manage:role:update:key:*"
	ManageRoleUpdateKeyAdd              ExplicitScopes = "manage:role:update:key:add"
	ManageRoleUpdateKeyRemove           ExplicitScopes = "manage:role:update:key:remove"
	ManageRoleUpdatePolicy              ExplicitScopes = "manage:role:update:policy"
	ManageRoleUpdateUser                ExplicitScopes = "manage:role:update:user:*"
	ManageRoleUpdateUserAdd             ExplicitScopes = "manage:role:update:user:add"
	ManageRoleUpdateUserRemove          ExplicitScopes = "manage:role:update:user:remove"
	ManageSession                       ExplicitScopes = "manage:session:*"
	ManageSessionCreate                 ExplicitScopes = "manage:session:create"
	ManageSessionExtend                 ExplicitScopes = "manage:session:extend"
	ManageSessionGet                    ExplicitScopes = "manage:session:get"
	ManageSessionList                   ExplicitScopes = "manage:session:list"
	ManageSessionReadonly               ExplicitScopes = "manage:session:readonly"
	ManageSessionRevoke                 ExplicitScopes = "manage:session:revoke"
	Mmi                                 ExplicitScopes = "mmi:*"
	OrgAccess                           ExplicitScopes = "orgAccess:*"
	OrgAccessChild                      ExplicitScopes = "orgAccess:child:*"
	Sign                                ExplicitScopes = "sign:*"
	SignAva                             ExplicitScopes = "sign:ava"
	SignBabylon                         ExplicitScopes = "sign:babylon:*"
	SignBabylonCovenant                 ExplicitScopes = "sign:babylon:covenant"
	SignBabylonEots                     ExplicitScopes = "sign:babylon:eots:*"
	SignBabylonEotsNonces               ExplicitScopes = "sign:babylon:eots:nonces"
	SignBabylonEotsSign                 ExplicitScopes = "sign:babylon:eots:sign"
	SignBabylonRegistration             ExplicitScopes = "sign:babylon:registration"
	SignBabylonStaking                  ExplicitScopes = "sign:babylon:staking:*"
	SignBabylonStakingDeposit           ExplicitScopes = "sign:babylon:staking:deposit"
	SignBabylonStakingSlash             ExplicitScopes = "sign:babylon:staking:slash"
	SignBabylonStakingUnbond            ExplicitScopes = "sign:babylon:staking:unbond"
	SignBabylonStakingWithdraw          ExplicitScopes = "sign:babylon:staking:withdraw"
	SignBlob                            ExplicitScopes = "sign:blob"
	SignBtc                             ExplicitScopes = "sign:btc:*"
	SignBtcMessage                      ExplicitScopes = "sign:btc:message:*"
	SignBtcMessageLegacy                ExplicitScopes = "sign:btc:message:legacy"
	SignBtcMessageSegwit                ExplicitScopes = "sign:btc:message:segwit"
	SignBtcPsbt                         ExplicitScopes = "sign:btc:psbt:*"
	SignBtcPsbtDoge                     ExplicitScopes = "sign:btc:psbt:doge"
	SignBtcPsbtLegacy                   ExplicitScopes = "sign:btc:psbt:legacy"
	SignBtcPsbtSegwit                   ExplicitScopes = "sign:btc:psbt:segwit"
	SignBtcPsbtTaproot                  ExplicitScopes = "sign:btc:psbt:taproot"
	SignBtcSegwit                       ExplicitScopes = "sign:btc:segwit"
	SignBtcTaproot                      ExplicitScopes = "sign:btc:taproot"
	SignEth2                            ExplicitScopes = "sign:eth2:*"
	SignEth2Stake                       ExplicitScopes = "sign:eth2:stake"
	SignEth2Unstake                     ExplicitScopes = "sign:eth2:unstake"
	SignEth2Validate                    ExplicitScopes = "sign:eth2:validate"
	SignEvm                             ExplicitScopes = "sign:evm:*"
	SignEvmEip191                       ExplicitScopes = "sign:evm:eip191"
	SignEvmEip712                       ExplicitScopes = "sign:evm:eip712"
	SignEvmTx                           ExplicitScopes = "sign:evm:tx"
	SignMmi                             ExplicitScopes = "sign:mmi"
	SignSolana                          ExplicitScopes = "sign:solana"
	SignSui                             ExplicitScopes = "sign:sui"
	SignTendermint                      ExplicitScopes = "sign:tendermint"
)

// Defines values for FeeType.
const (
	Sats       FeeType = "sats"
	SatsPerKwu FeeType = "sats_per_kwu"
	SatsPerVb  FeeType = "sats_per_vb"
)

// Defines values for ForbiddenErrorCode.
const (
	AutoAddBlsKeyToProtectedRole        ForbiddenErrorCode = "AutoAddBlsKeyToProtectedRole"
	CannotAssumeIdentity                ForbiddenErrorCode = "CannotAssumeIdentity"
	CannotCreateOrg                     ForbiddenErrorCode = "CannotCreateOrg"
	ChainIdNotAllowed                   ForbiddenErrorCode = "ChainIdNotAllowed"
	ContactNotInOrg                     ForbiddenErrorCode = "ContactNotInOrg"
	DisabledRole                        ForbiddenErrorCode = "DisabledRole"
	EmailOtpNotConfigured               ForbiddenErrorCode = "EmailOtpNotConfigured"
	ExpectedUserSession                 ForbiddenErrorCode = "ExpectedUserSession"
	FidoRequiredToRemoveTotp            ForbiddenErrorCode = "FidoRequiredToRemoveTotp"
	FullSessionRequired                 ForbiddenErrorCode = "FullSessionRequired"
	ImproperSessionScope                ForbiddenErrorCode = "ImproperSessionScope"
	InvalidArn                          ForbiddenErrorCode = "InvalidArn"
	InvalidAuthHeader                   ForbiddenErrorCode = "InvalidAuthHeader"
	InvalidOrg                          ForbiddenErrorCode = "InvalidOrg"
	InvalidOrgMembershipRoleChange      ForbiddenErrorCode = "InvalidOrgMembershipRoleChange"
	InvalidRole                         ForbiddenErrorCode = "InvalidRole"
	KeyDisabled                         ForbiddenErrorCode = "KeyDisabled"
	KeyNotInRole                        ForbiddenErrorCode = "KeyNotInRole"
	LegacySessionCannotHaveScopeCeiling ForbiddenErrorCode = "LegacySessionCannotHaveScopeCeiling"
	MemberRoleForbidden                 ForbiddenErrorCode = "MemberRoleForbidden"
	MfaChallengeExpired                 ForbiddenErrorCode = "MfaChallengeExpired"
	MfaConfirmationCodeMismatch         ForbiddenErrorCode = "MfaConfirmationCodeMismatch"
	MfaDisallowedApprover               ForbiddenErrorCode = "MfaDisallowedApprover"
	MfaDisallowedIdentity               ForbiddenErrorCode = "MfaDisallowedIdentity"
	MfaHttpRequestMismatch              ForbiddenErrorCode = "MfaHttpRequestMismatch"
	MfaNotApprovedYet                   ForbiddenErrorCode = "MfaNotApprovedYet"
	MfaNotConfigured                    ForbiddenErrorCode = "MfaNotConfigured"
	MfaRemoveBelowMin                   ForbiddenErrorCode = "MfaRemoveBelowMin"
	MfaTotpBadCode                      ForbiddenErrorCode = "MfaTotpBadCode"
	MfaTotpBadConfiguration             ForbiddenErrorCode = "MfaTotpBadConfiguration"
	MfaTotpRateLimit                    ForbiddenErrorCode = "MfaTotpRateLimit"
	MfaTypeNotAllowed                   ForbiddenErrorCode = "MfaTypeNotAllowed"
	MustBeFullMember                    ForbiddenErrorCode = "MustBeFullMember"
	OidcIdentityLimitReached            ForbiddenErrorCode = "OidcIdentityLimitReached"
	OidcIssuerNotAllowedForMemberRole   ForbiddenErrorCode = "OidcIssuerNotAllowedForMemberRole"
	OidcNoMemberRolesAllowed            ForbiddenErrorCode = "OidcNoMemberRolesAllowed"
	OidcScopeCeilingMissing             ForbiddenErrorCode = "OidcScopeCeilingMissing"
	OidcUserNotFound                    ForbiddenErrorCode = "OidcUserNotFound"
	OperationNotAllowed                 ForbiddenErrorCode = "OperationNotAllowed"
	OrgDisabled                         ForbiddenErrorCode = "OrgDisabled"
	OrgExportRetrievalDisabled          ForbiddenErrorCode = "OrgExportRetrievalDisabled"
	OrgFlagNotSet                       ForbiddenErrorCode = "OrgFlagNotSet"
	OrgIdMismatch                       ForbiddenErrorCode = "OrgIdMismatch"
	OrgNotFound                         ForbiddenErrorCode = "OrgNotFound"
	OrgWithoutOwner                     ForbiddenErrorCode = "OrgWithoutOwner"
	OrphanedUser                        ForbiddenErrorCode = "OrphanedUser"
	PasskeyLoginDisabled                ForbiddenErrorCode = "PasskeyLoginDisabled"
	PasskeyNotRegistered                ForbiddenErrorCode = "PasskeyNotRegistered"
	RemoveKeyFromRoleUserNotAllowed     ForbiddenErrorCode = "RemoveKeyFromRoleUserNotAllowed"
	RemoveLastOidcIdentity              ForbiddenErrorCode = "RemoveLastOidcIdentity"
	RoleInParentOrgNotAllowed           ForbiddenErrorCode = "RoleInParentOrgNotAllowed"
	ScopedNameNotFound                  ForbiddenErrorCode = "ScopedNameNotFound"
	SelfDelete                          ForbiddenErrorCode = "SelfDelete"
	SelfDisable                         ForbiddenErrorCode = "SelfDisable"
	SentryDisallowed                    ForbiddenErrorCode = "SentryDisallowed"
	SessionAuthTokenExpired             ForbiddenErrorCode = "SessionAuthTokenExpired"
	SessionChanged                      ForbiddenErrorCode = "SessionChanged"
	SessionExpired                      ForbiddenErrorCode = "SessionExpired"
	SessionForWrongOrg                  ForbiddenErrorCode = "SessionForWrongOrg"
	SessionInvalidAuthToken             ForbiddenErrorCode = "SessionInvalidAuthToken"
	SessionInvalidEpochToken            ForbiddenErrorCode = "SessionInvalidEpochToken"
	SessionInvalidRefreshToken          ForbiddenErrorCode = "SessionInvalidRefreshToken"
	SessionNotFound                     ForbiddenErrorCode = "SessionNotFound"
	SessionPossiblyStolenToken          ForbiddenErrorCode = "SessionPossiblyStolenToken"
	SessionRefreshTokenExpired          ForbiddenErrorCode = "SessionRefreshTokenExpired"
	SessionRevoked                      ForbiddenErrorCode = "SessionRevoked"
	SessionRoleChanged                  ForbiddenErrorCode = "SessionRoleChanged"
	SessionWithoutAnyScopeUnder         ForbiddenErrorCode = "SessionWithoutAnyScopeUnder"
	TotpAlreadyConfigured               ForbiddenErrorCode = "TotpAlreadyConfigured"
	TotpConfigurationChanged            ForbiddenErrorCode = "TotpConfigurationChanged"
	UserDisabled                        ForbiddenErrorCode = "UserDisabled"
	UserExportDisabled                  ForbiddenErrorCode = "UserExportDisabled"
	UserExportRequestInvalid            ForbiddenErrorCode = "UserExportRequestInvalid"
	UserExportRequestNotInOrg           ForbiddenErrorCode = "UserExportRequestNotInOrg"
	UserMfaNotConfigured                ForbiddenErrorCode = "UserMfaNotConfigured"
	UserNotContactOwner                 ForbiddenErrorCode = "UserNotContactOwner"
	UserNotInOrg                        ForbiddenErrorCode = "UserNotInOrg"
	UserNotInRole                       ForbiddenErrorCode = "UserNotInRole"
	UserNotKeyOwner                     ForbiddenErrorCode = "UserNotKeyOwner"
	UserNotOrgOwner                     ForbiddenErrorCode = "UserNotOrgOwner"
	UserNotOriginalKeyOwner             ForbiddenErrorCode = "UserNotOriginalKeyOwner"
	UserNotPolicyOwner                  ForbiddenErrorCode = "UserNotPolicyOwner"
	UserRoleUnprivileged                ForbiddenErrorCode = "UserRoleUnprivileged"
	WrongMfaEmailOtpJwt                 ForbiddenErrorCode = "WrongMfaEmailOtpJwt"
)

// Defines values for HttpRequestCmpEq.
const (
	Eq HttpRequestCmpEq = "Eq"
)

// Defines values for InternalErrorCode.
const (
	AvaSignCredsMissing                 InternalErrorCode = "AvaSignCredsMissing"
	AvaSignSignatureMissing             InternalErrorCode = "AvaSignSignatureMissing"
	BabylonCovSignError                 InternalErrorCode = "BabylonCovSignError"
	ClaimsParseError                    InternalErrorCode = "ClaimsParseError"
	CognitoDeleteUserError              InternalErrorCode = "CognitoDeleteUserError"
	CognitoGetUser                      InternalErrorCode = "CognitoGetUser"
	CognitoGetUserError                 InternalErrorCode = "CognitoGetUserError"
	CognitoListUsersError               InternalErrorCode = "CognitoListUsersError"
	CognitoResendUserInvitation         InternalErrorCode = "CognitoResendUserInvitation"
	CognitoSetUserPasswordError         InternalErrorCode = "CognitoSetUserPasswordError"
	CreateEotsNoncesError               InternalErrorCode = "CreateEotsNoncesError"
	CreateImportKeyError                InternalErrorCode = "CreateImportKeyError"
	CreateKeyError                      InternalErrorCode = "CreateKeyError"
	CreatePolicyImportKeyError          InternalErrorCode = "CreatePolicyImportKeyError"
	CubistSignerError                   InternalErrorCode = "CubistSignerError"
	CwListMetricsError                  InternalErrorCode = "CwListMetricsError"
	CwPutMetricDataError                InternalErrorCode = "CwPutMetricDataError"
	DbDeleteError                       InternalErrorCode = "DbDeleteError"
	DbGetError                          InternalErrorCode = "DbGetError"
	DbGetItemsError                     InternalErrorCode = "DbGetItemsError"
	DbPutError                          InternalErrorCode = "DbPutError"
	DbQueryError                        InternalErrorCode = "DbQueryError"
	DbUpdateError                       InternalErrorCode = "DbUpdateError"
	DbWriteError                        InternalErrorCode = "DbWriteError"
	DeserializeEncryptedExportKeyError  InternalErrorCode = "DeserializeEncryptedExportKeyError"
	EmailConstructionError              InternalErrorCode = "EmailConstructionError"
	EmailTemplateRender                 InternalErrorCode = "EmailTemplateRender"
	EmptyUpdateModifiedActions          InternalErrorCode = "EmptyUpdateModifiedActions"
	EmptyUpdateModifiedObject           InternalErrorCode = "EmptyUpdateModifiedObject"
	EotsSignError                       InternalErrorCode = "EotsSignError"
	ExpectedRoleSession                 InternalErrorCode = "ExpectedRoleSession"
	FidoKeyAssociatedWithMultipleUsers  InternalErrorCode = "FidoKeyAssociatedWithMultipleUsers"
	GenericInternalError                InternalErrorCode = "GenericInternalError"
	GetAwsSecretError                   InternalErrorCode = "GetAwsSecretError"
	HistoricalTxBodyMissing             InternalErrorCode = "HistoricalTxBodyMissing"
	InconsistentMultiValueTestAndSet    InternalErrorCode = "InconsistentMultiValueTestAndSet"
	InternalHeaderMissing               InternalErrorCode = "InternalHeaderMissing"
	InvalidAlias                        InternalErrorCode = "InvalidAlias"
	InvalidBtcAddress                   InternalErrorCode = "InvalidBtcAddress"
	InvalidEmailAddress                 InternalErrorCode = "InvalidEmailAddress"
	InvalidInternalHeaderValue          InternalErrorCode = "InvalidInternalHeaderValue"
	InvalidOperation                    InternalErrorCode = "InvalidOperation"
	InvalidPkForMaterialId              InternalErrorCode = "InvalidPkForMaterialId"
	InvalidThirdPartyIdentity           InternalErrorCode = "InvalidThirdPartyIdentity"
	InvalidThrottleId                   InternalErrorCode = "InvalidThrottleId"
	InvalidUploadObjectId               InternalErrorCode = "InvalidUploadObjectId"
	KmsDisableKeyError                  InternalErrorCode = "KmsDisableKeyError"
	KmsEnableKeyError                   InternalErrorCode = "KmsEnableKeyError"
	KmsGenerateRandomError              InternalErrorCode = "KmsGenerateRandomError"
	KmsGenerateRandomNoResponseError    InternalErrorCode = "KmsGenerateRandomNoResponseError"
	LambdaFailure                       InternalErrorCode = "LambdaFailure"
	LambdaInvokeError                   InternalErrorCode = "LambdaInvokeError"
	LambdaNoResponseError               InternalErrorCode = "LambdaNoResponseError"
	LambdaUnparsableResponse            InternalErrorCode = "LambdaUnparsableResponse"
	MalformedTotpBytes                  InternalErrorCode = "MalformedTotpBytes"
	ManagedStateMissing                 InternalErrorCode = "ManagedStateMissing"
	MaterialIdError                     InternalErrorCode = "MaterialIdError"
	MissingKeyMetadata                  InternalErrorCode = "MissingKeyMetadata"
	MissingUserEmail                    InternalErrorCode = "MissingUserEmail"
	NoMaterialId                        InternalErrorCode = "NoMaterialId"
	OidcAuthWithoutOrg                  InternalErrorCode = "OidcAuthWithoutOrg"
	OidcIdentityHeaderMissing           InternalErrorCode = "OidcIdentityHeaderMissing"
	OidcIdentityParseError              InternalErrorCode = "OidcIdentityParseError"
	OidcIssuerInvalidJwk                InternalErrorCode = "OidcIssuerInvalidJwk"
	OidcOrgMismatch                     InternalErrorCode = "OidcOrgMismatch"
	OrgParentLoop                       InternalErrorCode = "OrgParentLoop"
	ParentOrgNotFound                   InternalErrorCode = "ParentOrgNotFound"
	ParseDerivationPathError            InternalErrorCode = "ParseDerivationPathError"
	PasswordHashParseError              InternalErrorCode = "PasswordHashParseError"
	PolicyEngineError                   InternalErrorCode = "PolicyEngineError"
	PolicyEngineNotFound                InternalErrorCode = "PolicyEngineNotFound"
	PolicySecretsEncryptionError        InternalErrorCode = "PolicySecretsEncryptionError"
	ReEncryptUserExport                 InternalErrorCode = "ReEncryptUserExport"
	RequestLocalStateAlreadySet         InternalErrorCode = "RequestLocalStateAlreadySet"
	ReqwestError                        InternalErrorCode = "ReqwestError"
	ResolvedParentOrgWithNoScopeCeiling InternalErrorCode = "ResolvedParentOrgWithNoScopeCeiling"
	S3BuildError                        InternalErrorCode = "S3BuildError"
	S3CopyError                         InternalErrorCode = "S3CopyError"
	S3DeleteObjectsError                InternalErrorCode = "S3DeleteObjectsError"
	S3DownloadError                     InternalErrorCode = "S3DownloadError"
	S3ListObjectsError                  InternalErrorCode = "S3ListObjectsError"
	S3PresignedUrlError                 InternalErrorCode = "S3PresignedUrlError"
	S3UploadError                       InternalErrorCode = "S3UploadError"
	SecretNotFound                      InternalErrorCode = "SecretNotFound"
	SendMailError                       InternalErrorCode = "SendMailError"
	SerdeError                          InternalErrorCode = "SerdeError"
	SerializeEncryptedExportKeyError    InternalErrorCode = "SerializeEncryptedExportKeyError"
	SessionOrgIdMissing                 InternalErrorCode = "SessionOrgIdMissing"
	SnsGetSubscriptionAttributesError   InternalErrorCode = "SnsGetSubscriptionAttributesError"
	SnsPublishBatchError                InternalErrorCode = "SnsPublishBatchError"
	SnsSetSubscriptionAttributesError   InternalErrorCode = "SnsSetSubscriptionAttributesError"
	SnsSubscribeError                   InternalErrorCode = "SnsSubscribeError"
	SnsSubscriptionAttributesMissing    InternalErrorCode = "SnsSubscriptionAttributesMissing"
	SnsUnsubscribeError                 InternalErrorCode = "SnsUnsubscribeError"
	SplitSignerError                    InternalErrorCode = "SplitSignerError"
	SystemTimeError                     InternalErrorCode = "SystemTimeError"
	TestAndSetError                     InternalErrorCode = "TestAndSetError"
	TsQueryError                        InternalErrorCode = "TsQueryError"
	TsWriteError                        InternalErrorCode = "TsWriteError"
	UncheckedOrg                        InternalErrorCode = "UncheckedOrg"
)

// Defines values for InviteKind.
const (
	Cognito   InviteKind = "Cognito"
	IdpAndSso InviteKind = "IdpAndSso"
	Sso       InviteKind = "Sso"
)

// Defines values for JsonKeyPackageEnglishMnemonicMaterialType.
const (
	EnglishMnemonic JsonKeyPackageEnglishMnemonicMaterialType = "english_mnemonic"
)

// Defines values for JsonKeyPackageRawSecretMaterialType.
const (
	RawSecret JsonKeyPackageRawSecretMaterialType = "raw_secret"
)

// Defines values for KeyType.
const (
	BabylonCov            KeyType = "BabylonCov"
	BabylonEots           KeyType = "BabylonEots"
	BlsAvaIcm             KeyType = "BlsAvaIcm"
	BlsInactive           KeyType = "BlsInactive"
	BlsPub                KeyType = "BlsPub"
	Ed25519AptosAddr      KeyType = "Ed25519AptosAddr"
	Ed25519CardanoAddrVk  KeyType = "Ed25519CardanoAddrVk"
	Ed25519SolanaAddr     KeyType = "Ed25519SolanaAddr"
	Ed25519StellarAddr    KeyType = "Ed25519StellarAddr"
	Ed25519SubstrateAddr  KeyType = "Ed25519SubstrateAddr"
	Ed25519SuiAddr        KeyType = "Ed25519SuiAddr"
	Ed25519TendermintAddr KeyType = "Ed25519TendermintAddr"
	Ed25519TonAddr        KeyType = "Ed25519TonAddr"
	Mnemonic              KeyType = "Mnemonic"
	P256CosmosAddr        KeyType = "P256CosmosAddr"
	P256Neo3Addr          KeyType = "P256Neo3Addr"
	P256OntologyAddr      KeyType = "P256OntologyAddr"
	SchnorrKaspaAddr      KeyType = "SchnorrKaspaAddr"
	SchnorrKaspaTestAddr  KeyType = "SchnorrKaspaTestAddr"
	SecpAvaAddr           KeyType = "SecpAvaAddr"
	SecpAvaTestAddr       KeyType = "SecpAvaTestAddr"
	SecpBtc               KeyType = "SecpBtc"
	SecpBtcLegacy         KeyType = "SecpBtcLegacy"
	SecpBtcLegacyTest     KeyType = "SecpBtcLegacyTest"
	SecpBtcTest           KeyType = "SecpBtcTest"
	SecpCosmosAddr        KeyType = "SecpCosmosAddr"
	SecpDogeAddr          KeyType = "SecpDogeAddr"
	SecpDogeTestAddr      KeyType = "SecpDogeTestAddr"
	SecpEthAddr           KeyType = "SecpEthAddr"
	SecpKaspaAddr         KeyType = "SecpKaspaAddr"
	SecpKaspaTestAddr     KeyType = "SecpKaspaTestAddr"
	SecpTronAddr          KeyType = "SecpTronAddr"
	Stark                 KeyType = "Stark"
	TaprootBtc            KeyType = "TaprootBtc"
	TaprootBtcTest        KeyType = "TaprootBtcTest"
)

// Defines values for MemberRole.
const (
	Alien  MemberRole = "Alien"
	Member MemberRole = "Member"
	Owner  MemberRole = "Owner"
)

// Defines values for MembershipStatus.
const (
	Disabled MembershipStatus = "disabled"
	Enabled  MembershipStatus = "enabled"
)

// Defines values for MfaRequestInfoProvenance.
const (
	MfaRequestInfoProvenanceEditPolicy MfaRequestInfoProvenance = "EditPolicy"
	MfaRequestInfoProvenanceKey        MfaRequestInfoProvenance = "Key"
	MfaRequestInfoProvenanceKeyInRole  MfaRequestInfoProvenance = "KeyInRole"
	MfaRequestInfoProvenanceRole       MfaRequestInfoProvenance = "Role"
	MfaRequestInfoProvenanceUser       MfaRequestInfoProvenance = "User"
)

// Defines values for MfaTypeCubeSigner.
const (
	CubeSigner MfaTypeCubeSigner = "CubeSigner"
)

// Defines values for MfaTypeEmailOtp.
const (
	EmailOtp MfaTypeEmailOtp = "EmailOtp"
)

// Defines values for MfaTypeFido.
const (
	Fido MfaTypeFido = "Fido"
)

// Defines values for MfaTypeTotp.
const (
	Totp MfaTypeTotp = "Totp"
)

// Defines values for MfaVote.
const (
	Approve MfaVote = "approve"
	Reject  MfaVote = "reject"
)

// Defines values for MsgStatusPendingStatus.
const (
	MsgStatusPendingStatusPending MsgStatusPendingStatus = "Pending"
)

// Defines values for MsgStatusRejectedStatus.
const (
	MsgStatusRejectedStatusRejected MsgStatusRejectedStatus = "Rejected"
)

// Defines values for MsgStatusSignedStatus.
const (
	MsgStatusSignedStatusSigned MsgStatusSignedStatus = "Signed"
)

// Defines values for Network.
const (
	NetworkHolesky Network = "holesky"
	NetworkHoodi   Network = "hoodi"
	NetworkMainnet Network = "mainnet"
)

// Defines values for NotFoundErrorCode.
const (
	FidoChallengeNotFound        NotFoundErrorCode = "FidoChallengeNotFound"
	FidoKeyNotFound              NotFoundErrorCode = "FidoKeyNotFound"
	OrgExportCiphertextNotFound  NotFoundErrorCode = "OrgExportCiphertextNotFound"
	PolicySecretNotFound         NotFoundErrorCode = "PolicySecretNotFound"
	TotpChallengeNotFound        NotFoundErrorCode = "TotpChallengeNotFound"
	TotpNotConfigured            NotFoundErrorCode = "TotpNotConfigured"
	UploadObjectNotFound         NotFoundErrorCode = "UploadObjectNotFound"
	UriSegmentInvalid            NotFoundErrorCode = "UriSegmentInvalid"
	UriSegmentMissing            NotFoundErrorCode = "UriSegmentMissing"
	UserExportCiphertextNotFound NotFoundErrorCode = "UserExportCiphertextNotFound"
	UserExportRequestNotFound    NotFoundErrorCode = "UserExportRequestNotFound"
)

// Defines values for OperationKind.
const (
	AvaChainTxSign      OperationKind = "AvaChainTxSign"
	AvaSign             OperationKind = "AvaSign"
	BabylonCovSign      OperationKind = "BabylonCovSign"
	BabylonRegistration OperationKind = "BabylonRegistration"
	BabylonStaking      OperationKind = "BabylonStaking"
	BlobSign            OperationKind = "BlobSign"
	BtcMessageSign      OperationKind = "BtcMessageSign"
	BtcSign             OperationKind = "BtcSign"
	Eip191Sign          OperationKind = "Eip191Sign"
	Eip712Sign          OperationKind = "Eip712Sign"
	EotsNonces          OperationKind = "EotsNonces"
	EotsSign            OperationKind = "EotsSign"
	Eth1Sign            OperationKind = "Eth1Sign"
	Eth2Sign            OperationKind = "Eth2Sign"
	Eth2Stake           OperationKind = "Eth2Stake"
	Eth2Unstake         OperationKind = "Eth2Unstake"
	PsbtSign            OperationKind = "PsbtSign"
	RoleUpdate          OperationKind = "RoleUpdate"
	SolanaSign          OperationKind = "SolanaSign"
	SuiSign             OperationKind = "SuiSign"
	TaprootSign         OperationKind = "TaprootSign"
	TendermintSign      OperationKind = "TendermintSign"
)

// Defines values for OrgEventDiscriminants.
const (
	OrgEventDiscriminantsBabylonEotsConcurrentSigning            OrgEventDiscriminants = "BabylonEotsConcurrentSigning"
	OrgEventDiscriminantsBilling                                 OrgEventDiscriminants = "Billing"
	OrgEventDiscriminantsEth2ConcurrentAttestationSigning        OrgEventDiscriminants = "Eth2ConcurrentAttestationSigning"
	OrgEventDiscriminantsEth2ConcurrentBlockSigning              OrgEventDiscriminants = "Eth2ConcurrentBlockSigning"
	OrgEventDiscriminantsEth2ExceededMaxUnstake                  OrgEventDiscriminants = "Eth2ExceededMaxUnstake"
	OrgEventDiscriminantsEth2InvalidAttestationSourceEpochTooLow OrgEventDiscriminants = "Eth2InvalidAttestationSourceEpochTooLow"
	OrgEventDiscriminantsEth2InvalidAttestationTargetEpochTooLow OrgEventDiscriminants = "Eth2InvalidAttestationTargetEpochTooLow"
	OrgEventDiscriminantsEth2InvalidBlockProposerSlotTooLow      OrgEventDiscriminants = "Eth2InvalidBlockProposerSlotTooLow"
	OrgEventDiscriminantsEth2Unstake                             OrgEventDiscriminants = "Eth2Unstake"
	OrgEventDiscriminantsKeyCreated                              OrgEventDiscriminants = "KeyCreated"
	OrgEventDiscriminantsMfaRejected                             OrgEventDiscriminants = "MfaRejected"
	OrgEventDiscriminantsOidcAuth                                OrgEventDiscriminants = "OidcAuth"
	OrgEventDiscriminantsPolicyChanged                           OrgEventDiscriminants = "PolicyChanged"
	OrgEventDiscriminantsSigned                                  OrgEventDiscriminants = "Signed"
	OrgEventDiscriminantsTendermintConcurrentSigning             OrgEventDiscriminants = "TendermintConcurrentSigning"
	OrgEventDiscriminantsUserExportComplete                      OrgEventDiscriminants = "UserExportComplete"
	OrgEventDiscriminantsUserExportInit                          OrgEventDiscriminants = "UserExportInit"
	OrgEventDiscriminantsWasmPolicyExecuted                      OrgEventDiscriminants = "WasmPolicyExecuted"
)

// Defines values for OrgEventFilterAll.
const (
	AllEvents OrgEventFilterAll = "All"
)

// Defines values for OrgMetricDiscriminants.
const (
	BillingEventMetric OrgMetricDiscriminants = "BillingEvent"

	KeyCount       OrgMetricDiscriminants = "KeyCount"
	OidcLoginEvent OrgMetricDiscriminants = "OidcLoginEvent"
	SignEvent      OrgMetricDiscriminants = "SignEvent"
	UserCount      OrgMetricDiscriminants = "UserCount"
)

// Defines values for OrgMetricStat.
const (
	Average OrgMetricStat = "Average"
	Sum     OrgMetricStat = "Sum"
)

// Defines values for PendingMessageInfoMessageEip712Version.
const (
	PendingMessageInfoMessageEip712VersionV3 PendingMessageInfoMessageEip712Version = "v3"
	PendingMessageInfoMessageEip712VersionV4 PendingMessageInfoMessageEip712Version = "v4"
)

// Defines values for PendingMessageSignResponseMessageEip712Version.
const (
	PendingMessageSignResponseMessageEip712VersionV3 PendingMessageSignResponseMessageEip712Version = "v3"
	PendingMessageSignResponseMessageEip712VersionV4 PendingMessageSignResponseMessageEip712Version = "v4"
)

// Defines values for PolicyErrorOwnCodes.
const (
	AddKeyToRoleDisallowed                  PolicyErrorOwnCodes = "AddKeyToRoleDisallowed"
	BabylonStakingBbnAddress                PolicyErrorOwnCodes = "BabylonStakingBbnAddress"
	BabylonStakingChangeAddress             PolicyErrorOwnCodes = "BabylonStakingChangeAddress"
	BabylonStakingDisallowed                PolicyErrorOwnCodes = "BabylonStakingDisallowed"
	BabylonStakingExplicitParams            PolicyErrorOwnCodes = "BabylonStakingExplicitParams"
	BabylonStakingFee                       PolicyErrorOwnCodes = "BabylonStakingFee"
	BabylonStakingFinalityProviderPk        PolicyErrorOwnCodes = "BabylonStakingFinalityProviderPk"
	BabylonStakingLockTime                  PolicyErrorOwnCodes = "BabylonStakingLockTime"
	BabylonStakingNetwork                   PolicyErrorOwnCodes = "BabylonStakingNetwork"
	BabylonStakingParamsVersion             PolicyErrorOwnCodes = "BabylonStakingParamsVersion"
	BabylonStakingStakerPk                  PolicyErrorOwnCodes = "BabylonStakingStakerPk"
	BabylonStakingValue                     PolicyErrorOwnCodes = "BabylonStakingValue"
	BabylonStakingWithdrawalAddress         PolicyErrorOwnCodes = "BabylonStakingWithdrawalAddress"
	BtcMessageSigningNotAllowed             PolicyErrorOwnCodes = "BtcMessageSigningNotAllowed"
	BtcSighashTypeDisallowed                PolicyErrorOwnCodes = "BtcSighashTypeDisallowed"
	BtcSignatureExceededValue               PolicyErrorOwnCodes = "BtcSignatureExceededValue"
	BtcTxDisallowedOutputs                  PolicyErrorOwnCodes = "BtcTxDisallowedOutputs"
	BtcValueOverflow                        PolicyErrorOwnCodes = "BtcValueOverflow"
	DeniedByWebhook                         PolicyErrorOwnCodes = "DeniedByWebhook"
	Eip191SigningNotAllowed                 PolicyErrorOwnCodes = "Eip191SigningNotAllowed"
	Eip712SigningNotAllowed                 PolicyErrorOwnCodes = "Eip712SigningNotAllowed"
	Erc20DataInvalid                        PolicyErrorOwnCodes = "Erc20DataInvalid"
	Erc20ExceededApproveLimit               PolicyErrorOwnCodes = "Erc20ExceededApproveLimit"
	Erc20ExceededTransferLimit              PolicyErrorOwnCodes = "Erc20ExceededTransferLimit"
	Erc20ReceiverMismatch                   PolicyErrorOwnCodes = "Erc20ReceiverMismatch"
	Erc20SpenderMismatch                    PolicyErrorOwnCodes = "Erc20SpenderMismatch"
	Eth2ConcurrentUnstaking                 PolicyErrorOwnCodes = "Eth2ConcurrentUnstaking"
	Eth2ExceededMaxUnstake                  PolicyErrorOwnCodes = "Eth2ExceededMaxUnstake"
	EvmContractAddressUndefined             PolicyErrorOwnCodes = "EvmContractAddressUndefined"
	EvmContractChainIdUndefined             PolicyErrorOwnCodes = "EvmContractChainIdUndefined"
	EvmContractNotInAllowlist               PolicyErrorOwnCodes = "EvmContractNotInAllowlist"
	EvmDataDisallowed                       PolicyErrorOwnCodes = "EvmDataDisallowed"
	EvmDataInvalid                          PolicyErrorOwnCodes = "EvmDataInvalid"
	EvmDataNotDefined                       PolicyErrorOwnCodes = "EvmDataNotDefined"
	EvmFunctionCallInvalid                  PolicyErrorOwnCodes = "EvmFunctionCallInvalid"
	EvmFunctionNotInAllowlist               PolicyErrorOwnCodes = "EvmFunctionNotInAllowlist"
	EvmTxExceededGasCost                    PolicyErrorOwnCodes = "EvmTxExceededGasCost"
	EvmTxExceededValue                      PolicyErrorOwnCodes = "EvmTxExceededValue"
	EvmTxGasCostUndefined                   PolicyErrorOwnCodes = "EvmTxGasCostUndefined"
	EvmTxReceiverMismatch                   PolicyErrorOwnCodes = "EvmTxReceiverMismatch"
	EvmTxSenderMismatch                     PolicyErrorOwnCodes = "EvmTxSenderMismatch"
	EvmTxValueUndefined                     PolicyErrorOwnCodes = "EvmTxValueUndefined"
	InvalidSourceIp                         PolicyErrorOwnCodes = "InvalidSourceIp"
	KeyAccessError                          PolicyErrorOwnCodes = "KeyAccessError"
	KeyInMultipleRoles                      PolicyErrorOwnCodes = "KeyInMultipleRoles"
	KeysAlreadyInRole                       PolicyErrorOwnCodes = "KeysAlreadyInRole"
	NoOidcAuthSourcesDefined                PolicyErrorOwnCodes = "NoOidcAuthSourcesDefined"
	NotInIpv4Allowlist                      PolicyErrorOwnCodes = "NotInIpv4Allowlist"
	NotInOriginAllowlist                    PolicyErrorOwnCodes = "NotInOriginAllowlist"
	OidcSourceNotAllowed                    PolicyErrorOwnCodes = "OidcSourceNotAllowed"
	PolicyDisjunctionError                  PolicyErrorOwnCodes = "PolicyDisjunctionError"
	PolicyNegationError                     PolicyErrorOwnCodes = "PolicyNegationError"
	PsbtSigningDisallowed                   PolicyErrorOwnCodes = "PsbtSigningDisallowed"
	RawSigningNotAllowed                    PolicyErrorOwnCodes = "RawSigningNotAllowed"
	RequireRoleSessionKeyAccessError        PolicyErrorOwnCodes = "RequireRoleSessionKeyAccessError"
	SegwitSigningDisallowed                 PolicyErrorOwnCodes = "SegwitSigningDisallowed"
	SolanaInstructionCountHigh              PolicyErrorOwnCodes = "SolanaInstructionCountHigh"
	SolanaInstructionCountLow               PolicyErrorOwnCodes = "SolanaInstructionCountLow"
	SolanaInstructionMismatch               PolicyErrorOwnCodes = "SolanaInstructionMismatch"
	SolanaNotInInstructionAllowlist         PolicyErrorOwnCodes = "SolanaNotInInstructionAllowlist"
	SuiTxReceiversDisallowedCommand         PolicyErrorOwnCodes = "SuiTxReceiversDisallowedCommand"
	SuiTxReceiversDisallowedTransactionKind PolicyErrorOwnCodes = "SuiTxReceiversDisallowedTransactionKind"
	SuiTxReceiversDisallowedTransferAddress PolicyErrorOwnCodes = "SuiTxReceiversDisallowedTransferAddress"
	TaprootSigningDisallowed                PolicyErrorOwnCodes = "TaprootSigningDisallowed"
	TimeLocked                              PolicyErrorOwnCodes = "TimeLocked"
	WasmPoliciesDisabled                    PolicyErrorOwnCodes = "WasmPoliciesDisabled"
	WasmPolicyDenied                        PolicyErrorOwnCodes = "WasmPolicyDenied"
	WasmPolicyFailed                        PolicyErrorOwnCodes = "WasmPolicyFailed"
	WebhookPoliciesDisabled                 PolicyErrorOwnCodes = "WebhookPoliciesDisabled"
)

// Defines values for PolicyType.
const (
	PolicyTypeKey  PolicyType = "Key"
	PolicyTypeRole PolicyType = "Role"
	PolicyTypeWasm PolicyType = "Wasm"
)

// Defines values for PreconditionErrorOwnCodes.
const (
	BabylonEotsConcurrentSigning                  PreconditionErrorOwnCodes = "BabylonEotsConcurrentSigning"
	ConcurrentSigningWhenTimeLimitPolicyIsDefined PreconditionErrorOwnCodes = "ConcurrentSigningWhenTimeLimitPolicyIsDefined"
	Eth2AttestationSourceEpochTooLow              PreconditionErrorOwnCodes = "Eth2AttestationSourceEpochTooLow"
	Eth2AttestationTargetEpochTooLow              PreconditionErrorOwnCodes = "Eth2AttestationTargetEpochTooLow"
	Eth2ConcurrentAttestationSigning              PreconditionErrorOwnCodes = "Eth2ConcurrentAttestationSigning"
	Eth2ConcurrentBlockSigning                    PreconditionErrorOwnCodes = "Eth2ConcurrentBlockSigning"
	Eth2MultiDepositToNonGeneratedKey             PreconditionErrorOwnCodes = "Eth2MultiDepositToNonGeneratedKey"
	Eth2MultiDepositUnknownInitialDeposit         PreconditionErrorOwnCodes = "Eth2MultiDepositUnknownInitialDeposit"
	Eth2MultiDepositWithdrawalAddressMismatch     PreconditionErrorOwnCodes = "Eth2MultiDepositWithdrawalAddressMismatch"
	Eth2ProposerSlotTooLow                        PreconditionErrorOwnCodes = "Eth2ProposerSlotTooLow"
	MfaApprovalsNotYetValid                       PreconditionErrorOwnCodes = "MfaApprovalsNotYetValid"
	TendermintConcurrentSigning                   PreconditionErrorOwnCodes = "TendermintConcurrentSigning"
	TendermintStateError                          PreconditionErrorOwnCodes = "TendermintStateError"
)

// Defines values for PublicKeyCredentialType.
const (
	PublicKey PublicKeyCredentialType = "public-key"
)

// Defines values for Purpose.
const (
	PurposeAlienInvite        Purpose = "alien_invite"
	PurposeAlienPasswordReset Purpose = "alien_password_reset"
	PurposeOtp                Purpose = "otp"
	PurposeOtpMfa             Purpose = "otp_mfa"
)

// Defines values for RefreshGrantType.
const (
	RefreshToken RefreshGrantType = "refresh_token"
)

// Defines values for ResidentKeyRequirement.
const (
	ResidentKeyRequirementDiscouraged ResidentKeyRequirement = "discouraged"
	ResidentKeyRequirementPreferred   ResidentKeyRequirement = "preferred"
	ResidentKeyRequirementRequired    ResidentKeyRequirement = "required"
)

// Defines values for RoleAction.
const (
	CreateToken RoleAction = "CreateToken"
)

// Defines values for ScopeSetAll.
const (
	AllScopes ScopeSetAll = "All"
)

// Defines values for SecondFactorRequirement.
const (
	SecondFactorRequirementIfRegistered SecondFactorRequirement = "if_registered"
	SecondFactorRequirementNone         SecondFactorRequirement = "none"
	SecondFactorRequirementRequired     SecondFactorRequirement = "required"
)

// Defines values for SignatureVersion.
const (
	Eip712V3     SignatureVersion = "eip_712_v3"
	Eip712V4     SignatureVersion = "eip_712_v4"
	PersonalSign SignatureVersion = "personal_sign"
)

// Defines values for SignerErrorOwnCodes.
const (
	EnclaveError          SignerErrorOwnCodes = "EnclaveError"
	JrpcError             SignerErrorOwnCodes = "JrpcError"
	PreComputed           SignerErrorOwnCodes = "PreComputed"
	ProxyStartError       SignerErrorOwnCodes = "ProxyStartError"
	StatusCodeWithMessage SignerErrorOwnCodes = "StatusCodeWithMessage"
	UnhandledError        SignerErrorOwnCodes = "UnhandledError"
)

// Defines values for SubscriptionStatus.
const (
	SubscriptionStatusConfirmed SubscriptionStatus = "Confirmed"
	SubscriptionStatusPending   SubscriptionStatus = "Pending"
)

// Defines values for SuiChain.
const (
	Sui        SuiChain = "sui"
	SuiDevnet  SuiChain = "sui_devnet"
	SuiTestnet SuiChain = "sui_testnet"
)

// Defines values for TelegramEnvironment.
const (
	Production TelegramEnvironment = "production"
	Test       TelegramEnvironment = "test"
)

// Defines values for TimeoutErrorCode.
const (
	PolicyEngineTimeout        TimeoutErrorCode = "PolicyEngineTimeout"
	WasmPolicyExecutionTimeout TimeoutErrorCode = "WasmPolicyExecutionTimeout"
)

// Defines values for TsQueryName.
const (
	ActiveKeys    TsQueryName = "ActiveKeys"
	ActiveUsers   TsQueryName = "ActiveUsers"
	UniqueSignIns TsQueryName = "UniqueSignIns"
)

// Defines values for TxStatusPendingStatus.
const (
	Pending TxStatusPendingStatus = "Pending"
)

// Defines values for TxStatusRejectedStatus.
const (
	TxStatusRejectedStatusRejected TxStatusRejectedStatus = "Rejected"
)

// Defines values for TxStatusSignedStatus.
const (
	TxStatusSignedStatusSigned TxStatusSignedStatus = "Signed"
)

// Defines values for UnauthorizedErrorCode.
const (
	AuthorizationHeaderMissing  UnauthorizedErrorCode = "AuthorizationHeaderMissing"
	EndpointRequiresUserSession UnauthorizedErrorCode = "EndpointRequiresUserSession"
	RefreshTokenMissing         UnauthorizedErrorCode = "RefreshTokenMissing"
)

// Defines values for UserVerificationRequirement.
const (
	Discouraged UserVerificationRequirement = "discouraged"
	Preferred   UserVerificationRequirement = "preferred"
	Required    UserVerificationRequirement = "required"
)

// Defines values for WasmPolicyResponseAllowResponse.
const (
	Allow WasmPolicyResponseAllowResponse = "Allow"
)

// Defines values for WasmPolicyResponseDenyResponse.
const (
	Deny WasmPolicyResponseDenyResponse = "Deny"
)

// Defines values for WasmPolicyResponseErrorResponse.
const (
	Error WasmPolicyResponseErrorResponse = "Error"
)

// Defines values for WebhookMethod.
const (
	GET  WebhookMethod = "GET"
	POST WebhookMethod = "POST"
)

// Defines values for ConfigureEmailParamsPurpose.
const (
	ConfigureEmailParamsPurposeAlienInvite        ConfigureEmailParamsPurpose = "alien_invite"
	ConfigureEmailParamsPurposeAlienPasswordReset ConfigureEmailParamsPurpose = "alien_password_reset"
	ConfigureEmailParamsPurposeOtp                ConfigureEmailParamsPurpose = "otp"
	ConfigureEmailParamsPurposeOtpMfa             ConfigureEmailParamsPurpose = "otp_mfa"
)

// AcceptedResponse defines model for AcceptedResponse.
type AcceptedResponse struct {
	Accepted  *AcceptedValue  `json:"accepted"`
	ErrorCode SignerErrorCode `json:"error_code"`

	// Message Error message
	Message string `json:"message"`

	// RequestId Optional request identifier
	RequestId *string `json:"request_id,omitempty"`
}

// AcceptedValue defines model for AcceptedValue.
type AcceptedValue struct {
	MfaRequired struct {
		// Id Always set to first MFA id from `Self::ids`
		Id string `json:"id"`

		// Ids Non-empty MFA request IDs
		Ids []string `json:"ids"`

		// OrgId Organization id
		OrgId   string              `json:"org_id"`
		Session *NewSessionResponse `json:"session"`
	} `json:"MfaRequired"`
}

// AcceptedValueCode defines model for AcceptedValueCode.
type AcceptedValueCode string

// AddIdentityRequest Request to add OIDC identity to an existing user account
type AddIdentityRequest struct {
	OidcToken string `json:"oidc_token"`
}

// AddKeysToRoleRequest defines model for AddKeysToRoleRequest.
type AddKeysToRoleRequest struct {
	// KeyIds A list of keys to add to a role
	KeyIds []string `json:"key_ids"`

	// Policy Optional policies to apply for each key
	Policy *[]interface{} `json:"policy"`
}

// AddThirdPartyUserRequest defines model for AddThirdPartyUserRequest.
type AddThirdPartyUserRequest struct {
	// Email Optional user email
	Email    *string       `json:"email"`
	Identity *OidcIdentity `json:"identity"`

	// MfaPolicy Optional login MFA policy
	MfaPolicy *map[string]interface{} `json:"mfa_policy"`

	// Name Optional user full name
	Name  *string        `json:"name"`
	Proof *IdentityProof `json:"proof"`

	// Role Describes whether a user in an org is an Owner or just a regular member
	Role MemberRole `json:"role"`
}

// AddThirdPartyUserResponse defines model for AddThirdPartyUserResponse.
type AddThirdPartyUserResponse struct {
	UserId string `json:"user_id"`
}

// AddressMap A mapping of networks to their associated chains and addresses.
type AddressMap struct {
	// Btc BTC addresses. The keys are `BtcChain`s and the values are addresses.
	Btc *map[string]string `json:"btc,omitempty"`
	Evm *EvmOptions        `json:"evm"`

	// Sui SUI addresses. The keys are `SuiChain`s and the values are addresses.
	Sui *map[string]string `json:"sui,omitempty"`
}

// AlertKind defines model for AlertKind.
type AlertKind string

// ApprovalInfo defines model for ApprovalInfo.
type ApprovalInfo struct {
	// Timestamp DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	Timestamp EpochDateTime `json:"timestamp"`
}

// AttestationConveyancePreference WebAuthn Relying Parties may use AttestationConveyancePreference to specify
// their preference regarding attestation conveyance during credential
// generation.
//
// https://www.w3.org/TR/webauthn-2/#enumdef-attestationconveyancepreference
type AttestationConveyancePreference string

// Aud Audience(s) that this ID Token is intended for. It MUST contain the
// OAuth 2.0 client_id of the Relying Party as an audience value. It MAY also contain
// identifiers for other audiences. In the general case, the aud value is an array of
// case-sensitive strings. In the common special case when there is one audience,
// the aud value MAY be a single case-sensitive string.
type Aud struct {
	union json.RawMessage
}

// AudArray defines model for AudArray.
type AudArray = []string

// AudString defines model for AudString.
type AudString = string

// AuthData Data required for both `authenticate` and `refresh`.
type AuthData struct {
	EpochNum int32 `json:"epoch_num"`

	// EpochToken Wrapper around a zeroizing 32-byte fixed-size array
	EpochToken B32    `json:"epoch_token"`
	OtherToken string `json:"other_token"`
}

// AuthSource At redemption time, the user must provide a credential they wish to use to authenticate.
// This enum represents the two possible sources of authentication.
type AuthSource struct {
	Credential string `json:"credential"`

	// Kind At redemption time, the user must provide a credential they wish to use to authenticate.
	// This enum represents the two possible sources of authentication.
	Kind AuthSourceKind `json:"kind"`
}

// AuthSourceKind At redemption time, the user must provide a credential they wish to use to authenticate.
// This enum represents the two possible sources of authentication.
type AuthSourceKind string

// AuthenticationRequest The request body for the idp authenticate endpoint
type AuthenticationRequest struct {
	// Email The email address of the user attempting to authenticate
	Email string `json:"email"`

	// Password The password for that user
	Password string `json:"password"`
}

// AuthenticationResponse The response to the idp authenticate endpoint
type AuthenticationResponse struct {
	// IdToken An OIDC token that can be used to authenticate with CubeSigner
	IdToken string `json:"id_token"`
}

// AuthenticatorAssertionResponse Represents the assertion response used by clients when attempting to log in with a known credential
// https://www.w3.org/TR/webauthn-2/#authenticatorassertionresponse
type AuthenticatorAssertionResponse struct {
	// AuthenticatorData Contains the standard CTAP2 authenticator data. Must be a valid [`AuthenticatorData`].
	// This contains information about how key was invoked.
	// https://www.w3.org/TR/webauthn-2/#dom-authenticatorassertionresponse-authenticatordata
	AuthenticatorData string `json:"authenticatorData"`

	// ClientDataJSON Contains UTF8 encoded JSON which must be a valid [`ClientData`]
	// This data is combined with `authenticator_data` to produce the signature
	// meaning the client attests to the correctness of this data.
	// https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson
	ClientDataJSON string `json:"clientDataJSON"`

	// Signature The signature of the concatenated `authenticatorData || hash` where
	// `hash` is the SHA256 hash of the `clientDataJSON` buffer:
	//
	// Field Definition: https://www.w3.org/TR/webauthn-2/#dom-authenticatorassertionresponse-signature
	// Step 11 of `getAssertion` specifies the concatenation: https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion
	// Requirement for SHA-256: https://www.w3.org/TR/webauthn-2/#collectedclientdata-hash-of-the-serialized-client-data
	Signature string `json:"signature"`

	// UserHandle Allows the authenticator to optionally declare the credential identifier they used.
	// https://www.w3.org/TR/webauthn-2/#dom-authenticatorassertionresponse-userhandle
	UserHandle *string `json:"userHandle"`
}

// AuthenticatorAttachment This enumeration’s values describe authenticators' attachment modalities.
// Relying Parties use this to express a preferred authenticator attachment
// modality when calling navigator.credentials.create() to create a credential.
//
// https://www.w3.org/TR/webauthn-2/#enumdef-authenticatorattachment
type AuthenticatorAttachment string

// AuthenticatorAttestationResponse The AuthenticatorAttestationResponse interface represents the authenticator's
// response to a client’s request for the creation of a new public key
// credential. It contains information about the new credential that can be
// used to identify it for later use, and metadata that can be used by the
// WebAuthn Relying Party to assess the characteristics of the credential
// during registration.
//
// https://www.w3.org/TR/webauthn-2/#iface-authenticatorattestationresponse
type AuthenticatorAttestationResponse struct {
	// AttestationObject This attribute contains an attestation object, which is opaque to, and
	// cryptographically protected against tampering by, the client. The
	// attestation object contains both authenticator data and an attestation
	// statement. The former contains the AAGUID, a unique credential ID, and
	// the credential public key. The contents of the attestation statement are
	// determined by the attestation statement format used by the
	// authenticator. It also contains any additional information that the
	// Relying Party's server requires to validate the attestation statement,
	// as well as to decode and validate the authenticator data along with the
	// JSON-compatible serialization of client data. For more details, see
	// § 6.5 Attestation, § 6.5.4 Generating an Attestation Object, and Figure
	// 6.
	AttestationObject string `json:"attestationObject"`

	// ClientDataJSON This attribute, inherited from AuthenticatorResponse, contains the
	// JSON-compatible serialization of client data (see § 6.5 Attestation)
	// passed to the authenticator by the client in order to generate this
	// credential. The exact JSON serialization MUST be preserved, as the hash
	// of the serialized client data has been computed over it.
	ClientDataJSON string `json:"clientDataJSON"`
}

// AuthenticatorSelectionCriteria WebAuthn Relying Parties may use the AuthenticatorSelectionCriteria
// dictionary to specify their requirements regarding authenticator
// attributes.
//
// https://www.w3.org/TR/webauthn-2/#dictdef-authenticatorselectioncriteria
type AuthenticatorSelectionCriteria struct {
	AuthenticatorAttachment *AuthenticatorAttachment `json:"authenticatorAttachment"`

	// RequireResidentKey This member is retained for backwards compatibility with WebAuthn Level
	// 1 and, for historical reasons, its naming retains the deprecated
	// “resident” terminology for discoverable credentials. Relying Parties
	// SHOULD set it to true if, and only if, residentKey is set to required.
	//
	// https://www.w3.org/TR/webauthn-2/#dom-authenticatorselectioncriteria-requireresidentkey
	RequireResidentKey *bool                   `json:"requireResidentKey,omitempty"`
	ResidentKey        *ResidentKeyRequirement `json:"residentKey"`

	// UserVerification A WebAuthn Relying Party may require user verification for some of its
	// operations but not for others, and may use this type to express its needs.
	//
	// https://www.w3.org/TR/webauthn-2/#enum-userVerificationRequirement
	UserVerification *UserVerificationRequirement `json:"userVerification,omitempty"`
}

// AuthenticatorTransport Authenticators may implement various transports for communicating with
// clients. This enumeration defines hints as to how clients might communicate
// with a particular authenticator in order to obtain an assertion for a
// specific credential. Note that these hints represent the WebAuthn Relying
// Party's best belief as to how an authenticator may be reached. A Relying
// Party will typically learn of the supported transports for a public key
// credential via getTransports().
//
// https://www.w3.org/TR/webauthn-2/#enumdef-authenticatortransport
type AuthenticatorTransport string

// AvaSerializedTxSignRequest defines model for AvaSerializedTxSignRequest.
type AvaSerializedTxSignRequest struct {
	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata *interface{} `json:"metadata"`

	// Tx Serialized transaction to sign
	Tx string `json:"tx"`
}

// AvaSignRequest defines model for AvaSignRequest.
type AvaSignRequest struct {
	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata *interface{} `json:"metadata"`

	// Tx Transaction to sign.
	//
	// Examples:
	// - {"P": { "AddPermissionlessValidator": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/platformvm/txs/add_permissionless_validator.rs#L14) }}
	// - {"P": { "AddSubnetValidator": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/platformvm/txs/add_subnet_validator.rs#L29) }}
	// - {"P": { "AddValidator": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/platformvm/txs/add_validator.rs#L12) }}
	// - {"P": { "CreateChain": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/platformvm/txs/create_chain.rs#L8) }}
	// - {"P": { "CreateSubnet": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/platformvm/txs/create_subnet.rs#L8) }}
	// - {"P": { "Export": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/platformvm/txs/export.rs#L12) }}
	// - {"P": { "Import": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/platformvm/txs/import.rs#L12) }}
	// - {"X": { "Base": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/avm/txs/mod.rs#L21) }}
	// - {"X": { "Export": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/avm/txs/export.rs#L16) }}
	// - {"X": { "Import": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/avm/txs/import.rs#L14) }}
	Tx map[string]interface{} `json:"tx"`
}

// B32 Wrapper around a zeroizing 32-byte fixed-size array
type B32 = string

// BabylonCovSignRequest defines model for BabylonCovSignRequest.
type BabylonCovSignRequest struct {
	// FpEncKeys The keys for the finality providers to which this transaction is being staked.
	// Each key is a hex string containing a SEC1-encoded secp256k1 public key.
	FpEncKeys []string `json:"fp_enc_keys"`

	// SlashUnbondingTx The slash-unbonding transaction being approved by the covenant signer.
	// This is a Bitcoin consensus--encoded hex string.
	SlashUnbondingTx string `json:"slash_unbonding_tx"`

	// SlashingScript The slashing script in the staking transaction.
	// This is a Bitcoin consensus--encoded hex string.
	SlashingScript string `json:"slashing_script"`

	// SlashingTx The slashing transaction being approved by the covenant signer.
	// This is a Bitcoin consensus--encoded hex string.
	SlashingTx string `json:"slashing_tx"`

	// StakingOutputIdx The output index of the Babylon staking scripts in the staking transaction.
	StakingOutputIdx int32 `json:"staking_output_idx"`

	// StakingTx The staking transaction being approved by the covenant signer.
	// This is a Bitcoin consensus--encoded hex string.
	StakingTx string `json:"staking_tx"`

	// UnbondingScript The unbonding script in the staking transaction.
	// This is a Bitcoin consensus--encoded hex string.
	UnbondingScript string `json:"unbonding_script"`

	// UnbondingSlashingScript The slashing script in the unbonding transaction.
	// This is a Bitcoin consensus--encoded hex string.
	UnbondingSlashingScript string `json:"unbonding_slashing_script"`

	// UnbondingTx The unbonding transaction being approved by the covenant signer.
	// This is a Bitcoin consensus--encoded hex string.
	UnbondingTx string `json:"unbonding_tx"`
}

// BabylonCovSignResponse defines model for BabylonCovSignResponse.
type BabylonCovSignResponse struct {
	// SlashUnbondingTransactionsSignatures The slash-unbonding transaction signatures as an array of hex strings with no 0x prefix
	SlashUnbondingTransactionsSignatures []string `json:"slash_unbonding_transactions_signatures"`

	// SlashingTransactionsSignatures The slashing transaction signatures as an array of hex strings with no 0x prefix
	SlashingTransactionsSignatures []string `json:"slashing_transactions_signatures"`

	// UnbondingTransactionSignature The unbonding transaction signature as hex string with no 0x prefix
	UnbondingTransactionSignature string `json:"unbonding_transaction_signature"`
}

// BabylonNetworkId The network-id for Babylon staking
type BabylonNetworkId string

// BabylonRegistrationRequest defines model for BabylonRegistrationRequest.
type BabylonRegistrationRequest struct {
	// BbnAddr The Babylon address that will receive the staking rewards for this deposit.
	// Babylon requires this to be the same address that registers the deposit on
	// the Babylon chain.
	//
	// This must be a secp256k1 Cosmos address with either a `bbn` or a `cosmos`
	// human-readable part (i.e., `bbn1...` or `cosmos1...`). The latter lets you
	// specify the material-id of a SecpCosmos CubeSigner key.
	BbnAddr string `json:"bbn_addr"`

	// Change The change address, specified as a Bitcoin spend script
	Change         string                `json:"change"`
	ExplicitParams *BabylonStakingParams `json:"explicit_params"`

	// Fee The transaction fee value. The `fee_type` field determines whether this
	// is a fixed fee in sats or a rate in sats per (estimated) virtual byte of
	// transaction weight (i.e., sats per vb).
	Fee int64 `json:"fee"`

	// FeeType This type specifies the interpretation of the `fee` field in Babylon
	// staking requests. If `sats`, the field is intpreted as a fixed value
	// in sats. If `sats_pr_vb`, the field is interpreted as a rate and the
	// fee is computed by estimating the weight of the output transaction.
	FeeType FeeType `json:"fee_type"`

	// FinalityProviderPks The Schnorr public key (i.e., 32-byte X-coordinate) of the finality
	// provider to which the stake is delegated.
	FinalityProviderPks []string `json:"finality_provider_pks"`

	// IgnorePsbtOutputs By default, the PSBT in this request can only specify transaction inputs:
	// PSBTs that specify outputs will result in an error. When this flag is set,
	// existing outputs in the PSBT will instead be ignored (i.e., deleted from
	// the PSBT) when creating the deposit transaction.
	IgnorePsbtOutputs *bool `json:"ignore_psbt_outputs,omitempty"`

	// LockTime The lock time used for the withdrawal output in the staking deposit transaction
	LockTime int32 `json:"lock_time"`

	// Network The network-id for Babylon staking
	Network BabylonNetworkId `json:"network"`

	// Psbt A hex-serialized PSBT (version 0) containing the transaction inputs and
	// all necessary information for signing (e.g., taproot path and leaf
	// information). This PSBT must not have any transaction outputs; they
	// will be added to the returned PSBT.
	Psbt string `json:"psbt"`

	// StakerPk The Schnorr public key (i.e., 32-byte X-coordinate) of the staker. This
	// is the key that signs the slashing, withdrawal, and unbonding scripts.
	StakerPk string `json:"staker_pk"`

	// Value The value to be staked in sats
	Value int64 `json:"value"`

	// Version The parameter version to use. If `None`, uses the latest version.
	Version *int32 `json:"version"`
}

// BabylonRegistrationResponse defines model for BabylonRegistrationResponse.
type BabylonRegistrationResponse struct {
	// BbnAddr The Babylon address that will receive the staking rewards for this deposit.
	//
	// This value will correspond to the `bbn_addr` value specified in the request,
	// but it will always have a `bbn` human-readable part.
	BbnAddr string `json:"bbn_addr"`

	// Deposit The deposit transaction PSBT. This PSBT includes signatures on any
	// inputs controlled by the staker taproot key specified in the request.
	Deposit string `json:"deposit"`

	// DepositFee The deposit transaction fee in sats.
	DepositFee int64 `json:"deposit_fee"`

	// Pop The proof of possession, i.e., a BIP322 signature on the staker's
	// Babylon address signed by the staker taproot key. This is a Bitcoin
	// witness stack in Bitcoin consensus hex encoding.
	Pop string `json:"pop"`

	// SlashDeposit The slash-deposit transaction in Bitcoin consensus hex encoding.
	SlashDeposit string `json:"slash_deposit"`

	// SlashDepositSig The staker taproot key's signature on the slash-deposit transaction.
	// This is a BIP340 signature in hex format.
	SlashDepositSig string `json:"slash_deposit_sig"`

	// SlashUnbond The slash-unbond transaction in Bitcoin consensus hex encoding.
	SlashUnbond string `json:"slash_unbond"`

	// SlashUnbondSig The staker taproot key's signature on the slash-unbond transaction.
	// This is a BIP340 signature in hex format.
	SlashUnbondSig string `json:"slash_unbond_sig"`

	// Unbond The (unsigned) unbonding transaction in Bitcoin consensus hex encoding.
	Unbond string `json:"unbond"`
}

// BabylonScriptData Data needed to create the Babylon deposit scripts
type BabylonScriptData struct {
	ExplicitParams *BabylonStakingParams `json:"explicit_params"`

	// FinalityProviderPks The Schnorr public key (i.e., 32-byte X-coordinate) of the finality
	// provider to which the stake is delegated.
	FinalityProviderPks []string `json:"finality_provider_pks"`

	// LockTime The lock time used for the withdrawal output in the staking deposit transaction
	LockTime int32 `json:"lock_time"`

	// Network The network-id for Babylon staking
	Network BabylonNetworkId `json:"network"`

	// StakerPk The Schnorr public key (i.e., 32-byte X-coordinate) of the staker. This
	// is the key that signs the slashing, withdrawal, and unbonding scripts.
	StakerPk string `json:"staker_pk"`

	// Version The parameter version to use. If `None`, uses the latest version.
	Version *int32 `json:"version"`
}

// BabylonStakingDeposit defines model for BabylonStakingDeposit.
type BabylonStakingDeposit struct {
	// Change The change address, specified as a Bitcoin spend script
	Change         string                `json:"change"`
	ExplicitParams *BabylonStakingParams `json:"explicit_params"`

	// Fee The transaction fee value. The `fee_type` field determines whether this
	// is a fixed fee in sats or a rate in sats per (estimated) virtual byte of
	// transaction weight (i.e., sats per vb).
	Fee int64 `json:"fee"`

	// FeeType This type specifies the interpretation of the `fee` field in Babylon
	// staking requests. If `sats`, the field is intpreted as a fixed value
	// in sats. If `sats_pr_vb`, the field is interpreted as a rate and the
	// fee is computed by estimating the weight of the output transaction.
	FeeType FeeType `json:"fee_type"`

	// FinalityProviderPks The Schnorr public key (i.e., 32-byte X-coordinate) of the finality
	// provider to which the stake is delegated.
	FinalityProviderPks []string `json:"finality_provider_pks"`

	// IgnorePsbtOutputs By default, the PSBT in this request can only specify transaction inputs:
	// PSBTs that specify outputs will result in an error. When this flag is set,
	// existing outputs in the PSBT will instead be ignored (i.e., deleted from
	// the PSBT) when creating the deposit transaction.
	IgnorePsbtOutputs *bool `json:"ignore_psbt_outputs,omitempty"`

	// LockTime The lock time used for the withdrawal output in the staking deposit transaction
	LockTime int32 `json:"lock_time"`

	// Network The network-id for Babylon staking
	Network BabylonNetworkId `json:"network"`

	// Psbt A hex-serialized PSBT (version 0) containing the transaction inputs and
	// all necessary information for signing (e.g., taproot path and leaf
	// information). This PSBT must not have any transaction outputs; they
	// will be added to the returned PSBT.
	Psbt string `json:"psbt"`

	// StakerPk The Schnorr public key (i.e., 32-byte X-coordinate) of the staker. This
	// is the key that signs the slashing, withdrawal, and unbonding scripts.
	StakerPk string `json:"staker_pk"`

	// Value The value to be staked in sats
	Value int64 `json:"value"`

	// Version The parameter version to use. If `None`, uses the latest version.
	Version *int32 `json:"version"`
}

// BabylonStakingEarlyUnbond defines model for BabylonStakingEarlyUnbond.
type BabylonStakingEarlyUnbond struct {
	// AsBase64 If `true`, the resulting PSBT is encoded as a base64 string.
	// Otherwise, it is encoded as a hex string.
	AsBase64       *bool                 `json:"as_base64,omitempty"`
	ExplicitParams *BabylonStakingParams `json:"explicit_params"`

	// FinalityProviderPks The Schnorr public key (i.e., 32-byte X-coordinate) of the finality
	// provider to which the stake is delegated.
	FinalityProviderPks []string `json:"finality_provider_pks"`

	// LockTime The lock time used for the withdrawal output in the staking deposit transaction
	LockTime int32 `json:"lock_time"`

	// Network The network-id for Babylon staking
	Network BabylonNetworkId `json:"network"`

	// StakerPk The Schnorr public key (i.e., 32-byte X-coordinate) of the staker. This
	// is the key that signs the slashing, withdrawal, and unbonding scripts.
	StakerPk string `json:"staker_pk"`

	// Txid Transaction-id of the deposit transaction to unbond or slash.
	Txid string `json:"txid"`

	// Value The value in sats that was staked in the transaction to unbond or slash.
	Value int64 `json:"value"`

	// Version The parameter version to use. If `None`, uses the latest version.
	Version *int32 `json:"version"`

	// Vout Transaction output index of the staking transaction to unbond or slash.
	// For staking transactions generated by CubeSigner, this will always be zero.
	Vout int32 `json:"vout"`
}

// BabylonStakingParams Parameter set for Babylon staking. The latest parameter sets are
// available from <https://github.com/babylonchain/networks>
type BabylonStakingParams struct {
	// ActivationHeight Block height at which these params will enter use
	ActivationHeight int64 `json:"activation_height"`

	// CovenantPks Public keys of the covenant signers
	CovenantPks []string `json:"covenant_pks"`

	// CovenantQuorum Quorum for covenant signer
	CovenantQuorum int `json:"covenant_quorum"`

	// MaxStakingAmount Max amount that can be staked in a single txn
	MaxStakingAmount int64 `json:"max_staking_amount"`

	// MaxStakingTime Max timelock for staking
	MaxStakingTime int32 `json:"max_staking_time"`

	// MinStakingAmount Min amount that must be staked
	MinStakingAmount int64 `json:"min_staking_amount"`

	// MinStakingTime Min timelock for staking
	MinStakingTime int32 `json:"min_staking_time"`

	// SlashingFee Minimum fee (in sats) that must be paid as part of the slashing txn
	SlashingFee *int64 `json:"slashing_fee,omitempty"`

	// SlashingMargin An extra number of sats to slash in the slashing txn. This can be used
	// to ensure that the transaction meets the minimum slashing requirement
	// even if the covenant committee members use floats to compute the amount
	// that should be slashed. The default is 2; it should not be necessary to
	// go higher than this.
	SlashingMargin *int64 `json:"slashing_margin"`

	// SlashingPkScript The pk_script value for the 0th output index of a slashing transaction,
	// serialized as a hex byte string. This value must be present to create
	// slashing signatures.
	SlashingPkScript *string `json:"slashing_pk_script"`

	// SlashingRate The fraction of stake slashed if a double-sign is detected
	SlashingRate *string `json:"slashing_rate"`

	// Tag Bitcoin transaction tag for staking metadata. If present, an identifiable
	// staking output (i.e., one with an OP_RETURN) will be created.
	Tag *string `json:"tag"`

	// UnbondingFee Fee (in sats) that must be spent as part of the unbonding txn
	UnbondingFee int64 `json:"unbonding_fee"`

	// UnbondingTime Min timelock for an unbonding script
	UnbondingTime int32 `json:"unbonding_time"`

	// Version Parameter version
	Version int32 `json:"version"`
}

// BabylonStakingRequest The actions possible via the Babylon Staking endpoint
type BabylonStakingRequest struct {
	union json.RawMessage
}

// BabylonStakingRequestDeposit defines model for BabylonStakingRequestDeposit.
type BabylonStakingRequestDeposit struct {
	Action BabylonStakingRequestDepositAction `json:"action"`

	// Change The change address, specified as a Bitcoin spend script
	Change         string                `json:"change"`
	ExplicitParams *BabylonStakingParams `json:"explicit_params"`

	// Fee The transaction fee value. The `fee_type` field determines whether this
	// is a fixed fee in sats or a rate in sats per (estimated) virtual byte of
	// transaction weight (i.e., sats per vb).
	Fee int64 `json:"fee"`

	// FeeType This type specifies the interpretation of the `fee` field in Babylon
	// staking requests. If `sats`, the field is intpreted as a fixed value
	// in sats. If `sats_pr_vb`, the field is interpreted as a rate and the
	// fee is computed by estimating the weight of the output transaction.
	FeeType FeeType `json:"fee_type"`

	// FinalityProviderPks The Schnorr public key (i.e., 32-byte X-coordinate) of the finality
	// provider to which the stake is delegated.
	FinalityProviderPks []string `json:"finality_provider_pks"`

	// IgnorePsbtOutputs By default, the PSBT in this request can only specify transaction inputs:
	// PSBTs that specify outputs will result in an error. When this flag is set,
	// existing outputs in the PSBT will instead be ignored (i.e., deleted from
	// the PSBT) when creating the deposit transaction.
	IgnorePsbtOutputs *bool `json:"ignore_psbt_outputs,omitempty"`

	// LockTime The lock time used for the withdrawal output in the staking deposit transaction
	LockTime int32 `json:"lock_time"`

	// Network The network-id for Babylon staking
	Network BabylonNetworkId `json:"network"`

	// Psbt A hex-serialized PSBT (version 0) containing the transaction inputs and
	// all necessary information for signing (e.g., taproot path and leaf
	// information). This PSBT must not have any transaction outputs; they
	// will be added to the returned PSBT.
	Psbt string `json:"psbt"`

	// StakerPk The Schnorr public key (i.e., 32-byte X-coordinate) of the staker. This
	// is the key that signs the slashing, withdrawal, and unbonding scripts.
	StakerPk string `json:"staker_pk"`

	// Value The value to be staked in sats
	Value int64 `json:"value"`

	// Version The parameter version to use. If `None`, uses the latest version.
	Version *int32 `json:"version"`
}

// BabylonStakingRequestDepositAction defines model for BabylonStakingRequestDeposit.Action.
type BabylonStakingRequestDepositAction string

// BabylonStakingRequestEarlyUnbond defines model for BabylonStakingRequestEarlyUnbond.
type BabylonStakingRequestEarlyUnbond struct {
	Action BabylonStakingRequestEarlyUnbondAction `json:"action"`

	// AsBase64 If `true`, the resulting PSBT is encoded as a base64 string.
	// Otherwise, it is encoded as a hex string.
	AsBase64       *bool                 `json:"as_base64,omitempty"`
	ExplicitParams *BabylonStakingParams `json:"explicit_params"`

	// FinalityProviderPks The Schnorr public key (i.e., 32-byte X-coordinate) of the finality
	// provider to which the stake is delegated.
	FinalityProviderPks []string `json:"finality_provider_pks"`

	// LockTime The lock time used for the withdrawal output in the staking deposit transaction
	LockTime int32 `json:"lock_time"`

	// Network The network-id for Babylon staking
	Network BabylonNetworkId `json:"network"`

	// StakerPk The Schnorr public key (i.e., 32-byte X-coordinate) of the staker. This
	// is the key that signs the slashing, withdrawal, and unbonding scripts.
	StakerPk string `json:"staker_pk"`

	// Txid Transaction-id of the deposit transaction to unbond or slash.
	Txid string `json:"txid"`

	// Value The value in sats that was staked in the transaction to unbond or slash.
	Value int64 `json:"value"`

	// Version The parameter version to use. If `None`, uses the latest version.
	Version *int32 `json:"version"`

	// Vout Transaction output index of the staking transaction to unbond or slash.
	// For staking transactions generated by CubeSigner, this will always be zero.
	Vout int32 `json:"vout"`
}

// BabylonStakingRequestEarlyUnbondAction defines model for BabylonStakingRequestEarlyUnbond.Action.
type BabylonStakingRequestEarlyUnbondAction string

// BabylonStakingRequestSlashDeposit defines model for BabylonStakingRequestSlashDeposit.
type BabylonStakingRequestSlashDeposit struct {
	Action BabylonStakingRequestSlashDepositAction `json:"action"`

	// AsBase64 If `true`, the resulting PSBT is encoded as a base64 string.
	// Otherwise, it is encoded as a hex string.
	AsBase64       *bool                 `json:"as_base64,omitempty"`
	ExplicitParams *BabylonStakingParams `json:"explicit_params"`

	// FinalityProviderPks The Schnorr public key (i.e., 32-byte X-coordinate) of the finality
	// provider to which the stake is delegated.
	FinalityProviderPks []string `json:"finality_provider_pks"`

	// LockTime The lock time used for the withdrawal output in the staking deposit transaction
	LockTime int32 `json:"lock_time"`

	// Network The network-id for Babylon staking
	Network BabylonNetworkId `json:"network"`

	// StakerPk The Schnorr public key (i.e., 32-byte X-coordinate) of the staker. This
	// is the key that signs the slashing, withdrawal, and unbonding scripts.
	StakerPk string `json:"staker_pk"`

	// Txid Transaction-id of the deposit transaction to unbond or slash.
	Txid string `json:"txid"`

	// Value The value in sats that was staked in the transaction to unbond or slash.
	Value int64 `json:"value"`

	// Version The parameter version to use. If `None`, uses the latest version.
	Version *int32 `json:"version"`

	// Vout Transaction output index of the staking transaction to unbond or slash.
	// For staking transactions generated by CubeSigner, this will always be zero.
	Vout int32 `json:"vout"`
}

// BabylonStakingRequestSlashDepositAction defines model for BabylonStakingRequestSlashDeposit.Action.
type BabylonStakingRequestSlashDepositAction string

// BabylonStakingRequestSlashEarlyUnbond defines model for BabylonStakingRequestSlashEarlyUnbond.
type BabylonStakingRequestSlashEarlyUnbond struct {
	Action BabylonStakingRequestSlashEarlyUnbondAction `json:"action"`

	// AsBase64 If `true`, the resulting PSBT is encoded as a base64 string.
	// Otherwise, it is encoded as a hex string.
	AsBase64       *bool                 `json:"as_base64,omitempty"`
	ExplicitParams *BabylonStakingParams `json:"explicit_params"`

	// FinalityProviderPks The Schnorr public key (i.e., 32-byte X-coordinate) of the finality
	// provider to which the stake is delegated.
	FinalityProviderPks []string `json:"finality_provider_pks"`

	// LockTime The lock time used for the withdrawal output in the staking deposit transaction
	LockTime int32 `json:"lock_time"`

	// Network The network-id for Babylon staking
	Network BabylonNetworkId `json:"network"`

	// StakerPk The Schnorr public key (i.e., 32-byte X-coordinate) of the staker. This
	// is the key that signs the slashing, withdrawal, and unbonding scripts.
	StakerPk string `json:"staker_pk"`

	// Txid Transaction-id of the deposit transaction to unbond or slash.
	Txid string `json:"txid"`

	// Value The value in sats that was staked in the transaction to unbond or slash.
	Value int64 `json:"value"`

	// Version The parameter version to use. If `None`, uses the latest version.
	Version *int32 `json:"version"`

	// Vout Transaction output index of the staking transaction to unbond or slash.
	// For staking transactions generated by CubeSigner, this will always be zero.
	Vout int32 `json:"vout"`
}

// BabylonStakingRequestSlashEarlyUnbondAction defines model for BabylonStakingRequestSlashEarlyUnbond.Action.
type BabylonStakingRequestSlashEarlyUnbondAction string

// BabylonStakingRequestWithdrawEarlyUnbond defines model for BabylonStakingRequestWithdrawEarlyUnbond.
type BabylonStakingRequestWithdrawEarlyUnbond struct {
	Action BabylonStakingRequestWithdrawEarlyUnbondAction `json:"action"`

	// AsBase64 If `true`, the resulting PSBT is encoded as a base64 string.
	// Otherwise, it is encoded as a hex string.
	AsBase64       *bool                 `json:"as_base64,omitempty"`
	ExplicitParams *BabylonStakingParams `json:"explicit_params"`

	// Fee The transaction fee value. The `fee_type` field determines whether this
	// is a fixed fee in sats or a rate in sats per (estimated) virtual byte of
	// transaction weight (i.e., sats per vb).
	Fee int64 `json:"fee"`

	// FeeType This type specifies the interpretation of the `fee` field in Babylon
	// staking requests. If `sats`, the field is intpreted as a fixed value
	// in sats. If `sats_pr_vb`, the field is interpreted as a rate and the
	// fee is computed by estimating the weight of the output transaction.
	FeeType FeeType `json:"fee_type"`

	// FinalityProviderPks The Schnorr public key (i.e., 32-byte X-coordinate) of the finality
	// provider to which the stake is delegated.
	FinalityProviderPks []string `json:"finality_provider_pks"`

	// LockTime The lock time used for the withdrawal output in the staking deposit transaction
	LockTime int32 `json:"lock_time"`

	// Network The network-id for Babylon staking
	Network BabylonNetworkId `json:"network"`

	// Recipient The withdrawal recipient, specified as a Bitcoin spend script
	Recipient string `json:"recipient"`

	// StakerPk The Schnorr public key (i.e., 32-byte X-coordinate) of the staker. This
	// is the key that signs the slashing, withdrawal, and unbonding scripts.
	StakerPk string `json:"staker_pk"`

	// Txid Transaction-id of the deposit or early unbonding transaction to withdraw from
	Txid string `json:"txid"`

	// TxnLockHeight An optional lock height (in blocks) for this transaction. The resulting
	// transaction cannot be mined before the specified block height.
	TxnLockHeight *int32 `json:"txn_lock_height"`

	// Value The value in sats that is staked in the transaction being withdrawn
	Value int64 `json:"value"`

	// Version The parameter version to use. If `None`, uses the latest version.
	Version *int32 `json:"version"`

	// Vout Transaction output index of the staking transaction from which to withdraw.
	// For staking transactions generated by CubeSigner, this will always be 0.
	// For slashing transactions generated by CubeSigner, this will always be 1.
	Vout int32 `json:"vout"`
}

// BabylonStakingRequestWithdrawEarlyUnbondAction defines model for BabylonStakingRequestWithdrawEarlyUnbond.Action.
type BabylonStakingRequestWithdrawEarlyUnbondAction string

// BabylonStakingRequestWithdrawSlashing defines model for BabylonStakingRequestWithdrawSlashing.
type BabylonStakingRequestWithdrawSlashing struct {
	Action BabylonStakingRequestWithdrawSlashingAction `json:"action"`

	// AsBase64 If `true`, the resulting PSBT is encoded as a base64 string.
	// Otherwise, it is encoded as a hex string.
	AsBase64       *bool                 `json:"as_base64,omitempty"`
	ExplicitParams *BabylonStakingParams `json:"explicit_params"`

	// Fee The transaction fee value. The `fee_type` field determines whether this
	// is a fixed fee in sats or a rate in sats per (estimated) virtual byte of
	// transaction weight (i.e., sats per vb).
	Fee int64 `json:"fee"`

	// FeeType This type specifies the interpretation of the `fee` field in Babylon
	// staking requests. If `sats`, the field is intpreted as a fixed value
	// in sats. If `sats_pr_vb`, the field is interpreted as a rate and the
	// fee is computed by estimating the weight of the output transaction.
	FeeType FeeType `json:"fee_type"`

	// FinalityProviderPks The Schnorr public key (i.e., 32-byte X-coordinate) of the finality
	// provider to which the stake is delegated.
	FinalityProviderPks []string `json:"finality_provider_pks"`

	// LockTime The lock time used for the withdrawal output in the staking deposit transaction
	LockTime int32 `json:"lock_time"`

	// Network The network-id for Babylon staking
	Network BabylonNetworkId `json:"network"`

	// Recipient The withdrawal recipient, specified as a Bitcoin spend script
	Recipient string `json:"recipient"`

	// StakerPk The Schnorr public key (i.e., 32-byte X-coordinate) of the staker. This
	// is the key that signs the slashing, withdrawal, and unbonding scripts.
	StakerPk string `json:"staker_pk"`

	// Txid Transaction-id of the deposit or early unbonding transaction to withdraw from
	Txid string `json:"txid"`

	// TxnLockHeight An optional lock height (in blocks) for this transaction. The resulting
	// transaction cannot be mined before the specified block height.
	TxnLockHeight *int32 `json:"txn_lock_height"`

	// Value The value in sats that is staked in the transaction being withdrawn
	Value int64 `json:"value"`

	// Version The parameter version to use. If `None`, uses the latest version.
	Version *int32 `json:"version"`

	// Vout Transaction output index of the staking transaction from which to withdraw.
	// For staking transactions generated by CubeSigner, this will always be 0.
	// For slashing transactions generated by CubeSigner, this will always be 1.
	Vout int32 `json:"vout"`
}

// BabylonStakingRequestWithdrawSlashingAction defines model for BabylonStakingRequestWithdrawSlashing.Action.
type BabylonStakingRequestWithdrawSlashingAction string

// BabylonStakingRequestWithdrawTimelock defines model for BabylonStakingRequestWithdrawTimelock.
type BabylonStakingRequestWithdrawTimelock struct {
	Action BabylonStakingRequestWithdrawTimelockAction `json:"action"`

	// AsBase64 If `true`, the resulting PSBT is encoded as a base64 string.
	// Otherwise, it is encoded as a hex string.
	AsBase64       *bool                 `json:"as_base64,omitempty"`
	ExplicitParams *BabylonStakingParams `json:"explicit_params"`

	// Fee The transaction fee value. The `fee_type` field determines whether this
	// is a fixed fee in sats or a rate in sats per (estimated) virtual byte of
	// transaction weight (i.e., sats per vb).
	Fee int64 `json:"fee"`

	// FeeType This type specifies the interpretation of the `fee` field in Babylon
	// staking requests. If `sats`, the field is intpreted as a fixed value
	// in sats. If `sats_pr_vb`, the field is interpreted as a rate and the
	// fee is computed by estimating the weight of the output transaction.
	FeeType FeeType `json:"fee_type"`

	// FinalityProviderPks The Schnorr public key (i.e., 32-byte X-coordinate) of the finality
	// provider to which the stake is delegated.
	FinalityProviderPks []string `json:"finality_provider_pks"`

	// LockTime The lock time used for the withdrawal output in the staking deposit transaction
	LockTime int32 `json:"lock_time"`

	// Network The network-id for Babylon staking
	Network BabylonNetworkId `json:"network"`

	// Recipient The withdrawal recipient, specified as a Bitcoin spend script
	Recipient string `json:"recipient"`

	// StakerPk The Schnorr public key (i.e., 32-byte X-coordinate) of the staker. This
	// is the key that signs the slashing, withdrawal, and unbonding scripts.
	StakerPk string `json:"staker_pk"`

	// Txid Transaction-id of the deposit or early unbonding transaction to withdraw from
	Txid string `json:"txid"`

	// TxnLockHeight An optional lock height (in blocks) for this transaction. The resulting
	// transaction cannot be mined before the specified block height.
	TxnLockHeight *int32 `json:"txn_lock_height"`

	// Value The value in sats that is staked in the transaction being withdrawn
	Value int64 `json:"value"`

	// Version The parameter version to use. If `None`, uses the latest version.
	Version *int32 `json:"version"`

	// Vout Transaction output index of the staking transaction from which to withdraw.
	// For staking transactions generated by CubeSigner, this will always be 0.
	// For slashing transactions generated by CubeSigner, this will always be 1.
	Vout int32 `json:"vout"`
}

// BabylonStakingRequestWithdrawTimelockAction defines model for BabylonStakingRequestWithdrawTimelock.Action.
type BabylonStakingRequestWithdrawTimelockAction string

// BabylonStakingResponse defines model for BabylonStakingResponse.
type BabylonStakingResponse struct {
	// Fee The transaction fee in sats
	Fee int64 `json:"fee"`

	// Psbt The PSBT in either hex or base64 serialization
	Psbt string `json:"psbt"`
}

// BabylonStakingWithdrawal defines model for BabylonStakingWithdrawal.
type BabylonStakingWithdrawal struct {
	// AsBase64 If `true`, the resulting PSBT is encoded as a base64 string.
	// Otherwise, it is encoded as a hex string.
	AsBase64       *bool                 `json:"as_base64,omitempty"`
	ExplicitParams *BabylonStakingParams `json:"explicit_params"`

	// Fee The transaction fee value. The `fee_type` field determines whether this
	// is a fixed fee in sats or a rate in sats per (estimated) virtual byte of
	// transaction weight (i.e., sats per vb).
	Fee int64 `json:"fee"`

	// FeeType This type specifies the interpretation of the `fee` field in Babylon
	// staking requests. If `sats`, the field is intpreted as a fixed value
	// in sats. If `sats_pr_vb`, the field is interpreted as a rate and the
	// fee is computed by estimating the weight of the output transaction.
	FeeType FeeType `json:"fee_type"`

	// FinalityProviderPks The Schnorr public key (i.e., 32-byte X-coordinate) of the finality
	// provider to which the stake is delegated.
	FinalityProviderPks []string `json:"finality_provider_pks"`

	// LockTime The lock time used for the withdrawal output in the staking deposit transaction
	LockTime int32 `json:"lock_time"`

	// Network The network-id for Babylon staking
	Network BabylonNetworkId `json:"network"`

	// Recipient The withdrawal recipient, specified as a Bitcoin spend script
	Recipient string `json:"recipient"`

	// StakerPk The Schnorr public key (i.e., 32-byte X-coordinate) of the staker. This
	// is the key that signs the slashing, withdrawal, and unbonding scripts.
	StakerPk string `json:"staker_pk"`

	// Txid Transaction-id of the deposit or early unbonding transaction to withdraw from
	Txid string `json:"txid"`

	// TxnLockHeight An optional lock height (in blocks) for this transaction. The resulting
	// transaction cannot be mined before the specified block height.
	TxnLockHeight *int32 `json:"txn_lock_height"`

	// Value The value in sats that is staked in the transaction being withdrawn
	Value int64 `json:"value"`

	// Version The parameter version to use. If `None`, uses the latest version.
	Version *int32 `json:"version"`

	// Vout Transaction output index of the staking transaction from which to withdraw.
	// For staking transactions generated by CubeSigner, this will always be 0.
	// For slashing transactions generated by CubeSigner, this will always be 1.
	Vout int32 `json:"vout"`
}

// BadGatewayErrorCode defines model for BadGatewayErrorCode.
type BadGatewayErrorCode string

// BadRequestErrorCode defines model for BadRequestErrorCode.
type BadRequestErrorCode string

// BillingDimensions defines model for BillingDimensions.
type BillingDimensions struct {
	// Kind Billing event types.
	Kind BillingEvent `json:"kind"`

	// OrgId All metrics must include 'org_id' as a dimension.
	OrgId string `json:"org_id"`
}

// BillingEvent Billing event types.
type BillingEvent string

// BlobSignRequest defines model for BlobSignRequest.
type BlobSignRequest struct {
	// AdaptorPk An optional base64 string comprising a SEC1-encoded secp256k1 public key.
	// This field can be used *only* with Schnorr keys.
	//
	// If this field is present, the response will be a Schnorr adaptor signature
	// in the format specified by Blockstream for use in libsecp256k1-zkp. See
	// <https://github.com/ZhePang/Python_Specification_for_Schnorr_Adaptor/>
	// for more information.
	AdaptorPk *string `json:"adaptor_pk"`

	// BlsDst An optional domain separation tag for use *only* with BLS signing requests.
	// This field must not be supplied for requests involving non-BLS key types.
	//
	// If this field is not present or null, the domain separation tag specified in
	// the IETF BLS Signatures draft versions 4 and 5, section 4.2.3 (minimal pubkey
	// size variant) is used.
	//
	// Otherwise, this field must contain a base-64 string encoding a non-empty byte
	// vector. When using a custom tag, RFC9380 (Section 3.1) recommends a length of
	// at least 16 bytes.
	BlsDst *string `json:"bls_dst"`

	// MessageBase64 The blob to sign, encoded as a base64 string.
	//
	// Note that certain signing keys impose additional requirements on the contents of
	// the message. For example, Secp256k1 keys require that the message is 32 bytes long.
	MessageBase64 string `json:"message_base64"`

	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata *interface{} `json:"metadata"`

	// SegwitTweak An optional tweak value for use *only* with Segwit (i.e., SecpBtc and SecpBtcTest)
	// keys. This field must not be supplied for requests involving any other key type.
	//
	// If this field is not present or null, no tweak is applied. Otherwise, this field
	// must contain a base-64 string encoding a vector of exactly 32 bytes. See the
	// CubeSigner documentation for more information on the Segwit tweaking procedure.
	SegwitTweak *string `json:"segwit_tweak"`

	// TaprootTweak An optional tweak value for use *only* with Taproot keys. This field must not
	// be supplied for requests involving any other key type.
	//
	// If this field is not present or null, no tweak is applied. If the field is an
	// empty string, the key is tweaked with an unspendable script path per BIP0341.
	// Otherwise, this field must contain a 32-byte, base-64 string representing the
	// Merkle root with which to tweak the key before signing.
	TaprootTweak *string `json:"taproot_tweak"`
}

// BtcChain Supported BTC chains.
type BtcChain string

// BtcLeafHashCodeSeparator Leaf hash and code, as per BIP341 and https://github.com/rust-bitcoin/rust-bitcoin/blob/464202109d2b2c96e9b4867461bffe420dbd8177/bitcoin/src/crypto/sighash.rs#L691
type BtcLeafHashCodeSeparator struct {
	// CodeSeparator Code separator
	CodeSeparator int32 `json:"code_separator"`

	// LeafHash Taproot-tagged hash with tag "TapLeaf".
	LeafHash string `json:"leaf_hash"`
}

// BtcMessageSignRequest defines model for BtcMessageSignRequest.
type BtcMessageSignRequest struct {
	// Data Message to sign as a hex-encoded byte string.
	Data string `json:"data"`

	// IsP2sh For segwit, sign the message as p2sh-p2wpkh instead of p2wpkh
	IsP2sh *bool `json:"is_p2sh,omitempty"`

	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata *interface{} `json:"metadata"`
}

// BtcMessageSignResponse BTC message signing response
type BtcMessageSignResponse struct {
	// Sig The base64-encoded signature in BIP137 format.
	Sig string `json:"sig"`
}

// BtcSighashType defines model for BtcSighashType.
type BtcSighashType string

// BtcSignRequest defines model for BtcSignRequest.
type BtcSignRequest struct {
	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata *interface{}     `json:"metadata"`
	SigKind  BtcSignatureKind `json:"sig_kind"`
	Tx       BtcTx            `json:"tx"`
}

// BtcSignatureKind defines model for BtcSignatureKind.
type BtcSignatureKind struct {
	// Segwit Segregated Witness
	Segwit struct {
		// InputIndex Transaction input index
		InputIndex int `json:"input_index"`

		// ScriptCode Script
		ScriptCode  string         `json:"script_code"`
		SighashType BtcSighashType `json:"sighash_type"`

		// Tweak Optional tweak to apply to the key before signing.
		//
		// When supplied, this field must contain a base-64 string encoding a vector of
		// exactly 32 bytes, which are used to compute the tweaked public key. See the
		// CubeSigner documentation for more information on the Segwit tweaking procedure.
		Tweak *string `json:"tweak"`

		// Value The total amount of the input (in satoshis).
		Value int64 `json:"value"`
	} `json:"Segwit"`
}

// BtcTx defines model for BtcTx.
type BtcTx = map[string]interface{}

// BtcTxOut defines model for BtcTxOut.
type BtcTxOut struct {
	// ScriptPubkey The script which must be satisfied for the output to be spent.
	ScriptPubkey string `json:"script_pubkey"`

	// Value The value of the output, in satoshis.
	Value int64 `json:"value"`
}

// ChallengePieces Describes how to derive a WebAuthn challenge value.
type ChallengePieces struct {
	// Preimage A base64url encoding of UTF8 JSON. The data in that JSON is endpoint specific, and describes what this FIDO challenge will be used for.
	//
	// Clients can use `preimage` along with `random_seed` to reconstruct the challenge like so:
	//
	// `challenge = HMAC-SHA256(key=random_seed, message=preimage)`
	Preimage string `json:"preimage"`

	// RandomSeed A random seed that prevents replay attacks
	RandomSeed string `json:"random_seed"`
}

// ClientProfile Client information representing the nature of front-end in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`].
type ClientProfile struct {
	// Agent Agent/Product name
	Agent *string `json:"agent"`

	// Engine Name of the engine
	Engine *string `json:"engine"`

	// Version Agent/product version
	Version *string `json:"version"`
}

// ClientSessionInfo Session information sent to the client.
// This struct works in tandem with its server-side counterpart [`SessionData`].
type ClientSessionInfo struct {
	// AuthToken Token to use for authorization.
	AuthToken string `json:"auth_token"`

	// AuthTokenExp DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	AuthTokenExp EpochDateTime `json:"auth_token_exp"`

	// Epoch Epoch at which the token was last refreshed
	Epoch int32 `json:"epoch"`

	// EpochToken Wrapper around a zeroizing 32-byte fixed-size array
	EpochToken B32 `json:"epoch_token"`

	// RefreshToken Token to use for refreshing the `(auth, refresh)` token pair
	RefreshToken string `json:"refresh_token"`

	// RefreshTokenExp DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	RefreshTokenExp EpochDateTime `json:"refresh_token_exp"`

	// SessionId Session ID
	SessionId string `json:"session_id"`
}

// ClientSessionMetadata Attributes that are expected to be provided by the client
type ClientSessionMetadata struct {
	// Client Client information representing the nature of front-end in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`].
	Client *ClientProfile `json:"client,omitempty"`

	// OsInfo OS information set in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`]
	OsInfo *OsInfo `json:"os_info,omitempty"`
}

// CommonFields Fields that are common to different types of resources such as keys
type CommonFields struct {
	Created *EpochDateTime `json:"created"`

	// EditPolicy A policy which governs when and who is allowed to update the entity this policy is
	// attached to (e.g., a role or a key).
	//
	// When attached to a role, by default, this policy applies to role deletion and all
	// role updates (including adding/removing keys and users); in terms of scopes,
	// it applies to `manage:role:update:*` and `manage:role:delete`.
	//
	// When attached to a key, by default, this policy applies to key deletion, all
	// key updates, and adding/removing that key to/from a role; in terms of scopes,
	// it applies to `manage:key:update:*`, `manage:key:delete`, `manage:role:update:key:*`.
	//
	// This default can be changed by setting the `applies_to_scopes` property.
	EditPolicy   *EditPolicy    `json:"edit_policy,omitempty"`
	LastModified *EpochDateTime `json:"last_modified"`

	// Metadata User-defined metadata. When rendering (e.g., in the browser) you should treat
	// it as untrusted user data (and avoid injecting metadata into HTML directly) if
	// untrusted users can create/update keys (or their metadata).
	Metadata *interface{} `json:"metadata,omitempty"`

	// Version Version of this object
	Version *int64 `json:"version,omitempty"`
}

// ComputeCountsResponse The number of users and keys in an org, organized by user role and key type
type ComputeCountsResponse struct {
	// Keys A map of a `KeyType` to the amount of keys with that type in the org.
	Keys map[string]int `json:"keys"`

	// Users A map of a `MemberRole` to the amount of number of users with that role in the org.
	Users map[string]int `json:"users"`
}

// ConfigureEmailRequest defines model for ConfigureEmailRequest.
type ConfigureEmailRequest struct {
	Auth struct {
		Smtp string `json:"smtp"`
	} `json:"auth"`

	// Sender The email address that emails will be sent from
	Sender   string `json:"sender"`
	Template *struct {
		// BodyTemplate An HTML template to use for the body.
		BodyTemplate string `json:"body_template"`

		// SubjectTemplate The subject line template
		SubjectTemplate string `json:"subject_template"`
	} `json:"template"`
}

// ConfiguredMfa defines model for ConfiguredMfa.
type ConfiguredMfa struct {
	union json.RawMessage
}

// ConfiguredMfaFido Named FIDO device (multiple can be configured per user)
type ConfiguredMfaFido struct {
	// Aaguid UUID of the device type
	Aaguid string `json:"aaguid"`

	// CreatedAt Creation date
	CreatedAt int64 `json:"created_at"`

	// Id A unique credential id
	Id string `json:"id"`

	// LastUsedAt Last used date
	LastUsedAt int64 `json:"last_used_at"`

	// Name A human-readable name given to the key
	Name string                `json:"name"`
	Type ConfiguredMfaFidoType `json:"type"`
}

// ConfiguredMfaFidoType defines model for ConfiguredMfaFido.Type.
type ConfiguredMfaFidoType string

// ConfiguredMfaTotp defines model for ConfiguredMfaTotp.
type ConfiguredMfaTotp struct {
	Type ConfiguredMfaTotpType `json:"type"`
}

// ConfiguredMfaTotpType defines model for ConfiguredMfaTotp.Type.
type ConfiguredMfaTotpType string

// ConflictErrorCode defines model for ConflictErrorCode.
type ConflictErrorCode string

// Contact defines model for Contact.
type Contact struct {
	// Addresses A mapping of networks to their associated chains and addresses.
	Addresses AddressMap     `json:"addresses"`
	Created   *EpochDateTime `json:"created"`

	// EditPolicy A policy which governs when and who is allowed to update the entity this policy is
	// attached to (e.g., a role or a key).
	//
	// When attached to a role, by default, this policy applies to role deletion and all
	// role updates (including adding/removing keys and users); in terms of scopes,
	// it applies to `manage:role:update:*` and `manage:role:delete`.
	//
	// When attached to a key, by default, this policy applies to key deletion, all
	// key updates, and adding/removing that key to/from a role; in terms of scopes,
	// it applies to `manage:key:update:*`, `manage:key:delete`, `manage:role:update:key:*`.
	//
	// This default can be changed by setting the `applies_to_scopes` property.
	EditPolicy   *EditPolicy    `json:"edit_policy,omitempty"`
	LastModified *EpochDateTime `json:"last_modified"`

	// Metadata User-defined metadata. When rendering (e.g., in the browser) you should treat
	// it as untrusted user data (and avoid injecting metadata into HTML directly) if
	// untrusted users can create/update keys (or their metadata).
	Metadata *interface{} `json:"metadata,omitempty"`

	// Name The name of the contact.
	Name  string `json:"name"`
	Owner Id     `json:"owner"`

	// Version Version of this object
	Version *int64 `json:"version,omitempty"`
}

// ContactInfo defines model for ContactInfo.
type ContactInfo struct {
	// Addresses A mapping of networks to their associated chains and addresses.
	Addresses AddressMap     `json:"addresses"`
	Created   *EpochDateTime `json:"created"`

	// EditPolicy A policy which governs when and who is allowed to update the entity this policy is
	// attached to (e.g., a role or a key).
	//
	// When attached to a role, by default, this policy applies to role deletion and all
	// role updates (including adding/removing keys and users); in terms of scopes,
	// it applies to `manage:role:update:*` and `manage:role:delete`.
	//
	// When attached to a key, by default, this policy applies to key deletion, all
	// key updates, and adding/removing that key to/from a role; in terms of scopes,
	// it applies to `manage:key:update:*`, `manage:key:delete`, `manage:role:update:key:*`.
	//
	// This default can be changed by setting the `applies_to_scopes` property.
	EditPolicy   *EditPolicy    `json:"edit_policy,omitempty"`
	Id           Id             `json:"id"`
	LastModified *EpochDateTime `json:"last_modified"`

	// Metadata User-defined metadata. When rendering (e.g., in the browser) you should treat
	// it as untrusted user data (and avoid injecting metadata into HTML directly) if
	// untrusted users can create/update keys (or their metadata).
	Metadata *interface{} `json:"metadata,omitempty"`

	// Name The name of the contact.
	Name  string `json:"name"`
	Owner Id     `json:"owner"`

	// Version Version of this object
	Version *int64 `json:"version,omitempty"`
}

// CreateAndUpdateKeyProperties defines model for CreateAndUpdateKeyProperties.
type CreateAndUpdateKeyProperties struct {
	EditPolicy *EditPolicy `json:"edit_policy"`

	// Metadata Set this key's metadata. If this value is `null`, the metadata is erased. If the field is
	// missing, the metadata remains unchanged.
	Metadata *interface{} `json:"metadata,omitempty"`

	// Owner Specify a user other than themselves to be the (potentially new) owner of the key.
	// The specified owner must be an existing user who is a member of the same org.
	Owner *string `json:"owner"`

	// Policy Set this key's policies. For an existing key, this overwrites all its policies.
	Policy *[]interface{} `json:"policy"`
}

// CreateContactRequest The information needed to create a Contact.
type CreateContactRequest struct {
	// Addresses A mapping of networks to their associated chains and addresses.
	Addresses  AddressMap  `json:"addresses"`
	EditPolicy *EditPolicy `json:"edit_policy"`

	// Metadata Optional user-defined metadata about the contact.
	Metadata *interface{} `json:"metadata"`

	// Name The name for the contact. Must be unique among contacts in the
	// org. Duplicate contact names will be rejected. Name must consist of
	// alphanumeric characters, spaces, `.` and `-`, and cannot be longer than
	// 50 characters.
	Name string `json:"name"`
}

// CreateKeyImportKeyResponse defines model for CreateKeyImportKeyResponse.
type CreateKeyImportKeyResponse struct {
	// DkEnc Base64-encoded, encrypted data key.
	DkEnc string `json:"dk_enc"`

	// EnclaveAttestation An attestation document from a secure enclave, including an
	// RSA signing key used to sign the contents of this message.
	EnclaveAttestation string `json:"enclave_attestation"`

	// EnclaveSignature An RSA-PSS-SHA256 signature on the public key and encrypted
	// secrets attesting to their generation inside a secure enclave.
	EnclaveSignature string `json:"enclave_signature"`

	// Expires Expiration timestamp expressed as seconds since the UNIX epoch.
	Expires int64 `json:"expires"`

	// PublicKey The ephemeral public key to which an imported key should be encrypted.
	// This is a P384 public key in base64-encoded uncompressed SECG format.
	PublicKey string `json:"public_key"`

	// SkEnc Base64-encoded, encrypted secret key.
	SkEnc string `json:"sk_enc"`
}

// CreateKeyRequest defines model for CreateKeyRequest.
type CreateKeyRequest struct {
	// ChainId Chain id for which the key is allowed to sign messages
	ChainId *int64 `json:"chain_id"`

	// Count Number of keys to create
	Count      int32       `json:"count"`
	EditPolicy *EditPolicy `json:"edit_policy"`
	KeyType    KeyType     `json:"key_type"`

	// Metadata Set this key's metadata. If this value is `null`, the metadata is erased. If the field is
	// missing, the metadata remains unchanged.
	Metadata *interface{} `json:"metadata,omitempty"`

	// Owner Specify a user other than themselves to be the (potentially new) owner of the key.
	// The specified owner must be an existing user who is a member of the same org.
	Owner *string `json:"owner"`

	// Policy Set this key's policies. For an existing key, this overwrites all its policies.
	Policy *[]interface{} `json:"policy"`
}

// CreateKeyResponse defines model for CreateKeyResponse.
type CreateKeyResponse struct {
	// Keys The info about the created keys
	Keys []KeyInfo `json:"keys"`
}

// CreateOrgRequest defines model for CreateOrgRequest.
type CreateOrgRequest struct {
	// MetricsEnabled Whether to enable metrics for the new organization
	MetricsEnabled *bool `json:"metrics_enabled,omitempty"`

	// Name The human readable name of the new organization
	Name string `json:"name"`
}

// CreatePolicyImportKeyResponse defines model for CreatePolicyImportKeyResponse.
type CreatePolicyImportKeyResponse struct {
	// DkEnc Base64-encoded, encrypted data key.
	DkEnc string `json:"dk_enc"`

	// EnclaveAttestation An attestation document from a secure enclave, including an
	// RSA signing key used to sign the contents of this message.
	EnclaveAttestation string `json:"enclave_attestation"`

	// EnclaveSignature An RSA-PSS-SHA256 signature on the public key and encrypted
	// secrets attesting to their generation inside a secure enclave.
	EnclaveSignature string `json:"enclave_signature"`

	// Expires Expiration timestamp expressed as seconds since the UNIX epoch.
	Expires int64 `json:"expires"`

	// PublicKey The ephemeral public key to which an imported key should be encrypted.
	// This is a P384 public key in base64-encoded uncompressed SECG format.
	PublicKey string `json:"public_key"`

	// SkEnc Base64-encoded, encrypted secret key.
	SkEnc string `json:"sk_enc"`
}

// CreatePolicyRequest Request for creating a named policy
type CreatePolicyRequest struct {
	EditPolicy *EditPolicy `json:"edit_policy"`

	// Metadata Optional metadata.
	Metadata *interface{} `json:"metadata"`

	// Name The policy name.
	// Must be unique among the named policies in this org. Duplicate policy names
	// will be rejected.
	Name string `json:"name"`

	// PolicyType The type of a [NamedPolicy].
	//
	// The type of a policy is set at creation time, and is used to offer guarantees
	// about the current and all future versions of a [NamedPolicy].
	PolicyType PolicyType `json:"policy_type"`

	// Rules The policy rules.
	Rules []interface{} `json:"rules"`
}

// CreateRoleRequest Optional create role request body
type CreateRoleRequest struct {
	// Name A human-readable name for the role.
	Name string `json:"name"`
}

// CreateRoleResponse The newly created role information
type CreateRoleResponse struct {
	// Name A human-readable name for the role.
	Name *string `json:"name"`

	// RoleId The id of the newly created role
	RoleId string `json:"role_id"`
}

// CreateSessionRequest defines model for CreateSessionRequest.
type CreateSessionRequest struct {
	// AuthLifetime The lifetime (in seconds) of auth tokens for this session.
	// Auth tokens can be refreshed (renewed) using a valid (unexpired)
	// refresh token, but not beyond the session lifetime.
	AuthLifetime *int64 `json:"auth_lifetime,omitempty"`

	// Client Client information representing the nature of front-end in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`].
	Client *ClientProfile `json:"client,omitempty"`

	// ExtendLifetimes By default, the requested session and auth lifetimes are truncated to be at most requestor's
	// session and auth lifetime, respectively. To extend the requested lifetimes past the
	// requestor's, set this property to `true` (in which case MFA will be required).
	ExtendLifetimes *bool `json:"extend_lifetimes,omitempty"`

	// GraceLifetime The amount of time (in seconds) that an auth token for this session remains
	// valid after it has been refreshed and a new auth token has been issued. This
	// helps to address concurrency hazards, for example, if one thread makes requests
	// with auth token while another refreshes it.
	GraceLifetime *int64 `json:"grace_lifetime,omitempty"`

	// OsInfo OS information set in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`]
	OsInfo *OsInfo `json:"os_info,omitempty"`

	// Purpose A human readable description of the session's purpose
	Purpose string `json:"purpose"`

	// RefreshLifetime The lifetime (in seconds) of refresh tokens for this session.
	// If this value is shorter than the session lifetime, inactive sessions
	// will become invalid once the auth and refresh tokens have both expired.
	RefreshLifetime *int64 `json:"refresh_lifetime,omitempty"`

	// Scopes Controls what capabilities this session will have.
	Scopes []Scope `json:"scopes"`

	// SessionLifetime The lifetime (in seconds) of the session.
	// The session cannot be extended beyond its original lifetime.
	SessionLifetime *int64 `json:"session_lifetime,omitempty"`
}

// CreateTokenRequest defines model for CreateTokenRequest.
type CreateTokenRequest struct {
	// AuthLifetime The lifetime (in seconds) of auth tokens for this session.
	// Auth tokens can be refreshed (renewed) using a valid (unexpired)
	// refresh token, but not beyond the session lifetime.
	AuthLifetime *int64 `json:"auth_lifetime,omitempty"`

	// Client Client information representing the nature of front-end in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`].
	Client *ClientProfile `json:"client,omitempty"`

	// GraceLifetime The amount of time (in seconds) that an auth token for this session remains
	// valid after it has been refreshed and a new auth token has been issued. This
	// helps to address concurrency hazards, for example, if one thread makes requests
	// with auth token while another refreshes it.
	GraceLifetime *int64 `json:"grace_lifetime,omitempty"`

	// OsInfo OS information set in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`]
	OsInfo *OsInfo `json:"os_info,omitempty"`

	// Purpose A human readable description of the purpose of the key
	Purpose string `json:"purpose"`

	// RefreshLifetime The lifetime (in seconds) of refresh tokens for this session.
	// If this value is shorter than the session lifetime, inactive sessions
	// will become invalid once the auth and refresh tokens have both expired.
	RefreshLifetime *int64 `json:"refresh_lifetime,omitempty"`

	// Scopes Controls what capabilities this session will have. By default, it has all
	// signing capabilities, i.e., just the 'sign:*' scope.
	Scopes *[]Scope `json:"scopes"`

	// SessionLifetime The lifetime (in seconds) of the session.
	// The session cannot be extended beyond its original lifetime.
	SessionLifetime *int64 `json:"session_lifetime,omitempty"`
}

// CreationOptionsWithHash defines model for CreationOptionsWithHash.
type CreationOptionsWithHash struct {
	// Options Defines the parameters for the creation of a new public key credential
	//
	// https://www.w3.org/TR/webauthn-2/#dictdef-publickeycredentialcreationoptions
	Options PublicKeyCredentialCreationOptions `json:"options"`

	// Preimage A base64url encoding of UTF8 JSON. The data in that JSON is endpoint specific, and describes what this FIDO challenge will be used for.
	//
	// Clients can use `preimage` along with `random_seed` to reconstruct the challenge like so:
	//
	// `challenge = HMAC-SHA256(key=random_seed, message=preimage)`
	Preimage string `json:"preimage"`

	// RandomSeed A random seed that prevents replay attacks
	RandomSeed string `json:"random_seed"`
}

// CubeSignerUserInfo defines model for CubeSignerUserInfo.
type CubeSignerUserInfo struct {
	// ConfiguredMfa All multi-factor authentication methods configured for this user
	ConfiguredMfa []ConfiguredMfa `json:"configured_mfa"`

	// Initialized Set once the user successfully logs into CubeSigner
	Initialized bool `json:"initialized"`

	// Name Optional human name for the user
	Name *string `json:"name"`

	// UserId CubeSigner's user identifier
	UserId string `json:"user_id"`
}

// DepositTxn Information produced by a successful deposit
type DepositTxn struct {
	// ChainId Chain ID for which the deposit transaction was created
	ChainId int64 `json:"chain_id"`

	// DepositTxn The deposit transaction. Includes only `to`, `value`, and `data` fields.
	DepositTxn map[string]interface{} `json:"deposit_txn"`

	// NewValidatorPk The hex-encoded compressed form of the new validator BLS public key
	NewValidatorPk string `json:"new_validator_pk"`
}

// DepositType The type of deposit to perform
type DepositType string

// DeriveKeyRequest defines model for DeriveKeyRequest.
type DeriveKeyRequest struct {
	// DerivationPath List of derivation paths for which to derive.
	DerivationPath []string    `json:"derivation_path"`
	EditPolicy     *EditPolicy `json:"edit_policy"`

	// Idempotent When false (the default), nothing is returned when a derived key already
	// exists. When true, returns the KeyInfo struct for keys that already exist
	// if caller is allowed to list that key.
	Idempotent *bool   `json:"idempotent,omitempty"`
	KeyType    KeyType `json:"key_type"`

	// Metadata Set this key's metadata. If this value is `null`, the metadata is erased. If the field is
	// missing, the metadata remains unchanged.
	Metadata *interface{} `json:"metadata,omitempty"`

	// MnemonicId Material-id of the mnemonic to use for derivation.
	MnemonicId string `json:"mnemonic_id"`

	// Owner Specify a user other than themselves to be the (potentially new) owner of the key.
	// The specified owner must be an existing user who is a member of the same org.
	Owner *string `json:"owner"`

	// Policy Set this key's policies. For an existing key, this overwrites all its policies.
	Policy *[]interface{} `json:"policy"`
}

// DeriveKeysRequest defines model for DeriveKeysRequest.
type DeriveKeysRequest struct {
	EditPolicy *EditPolicy `json:"edit_policy"`

	// Idempotent When false (the default), nothing is returned when a derived key already
	// exists. When true, returns the KeyInfo struct for keys that already exist
	// if caller is allowed to list that key.
	Idempotent *bool `json:"idempotent,omitempty"`

	// KeyTypesAndDerivationPaths Key types and corresponding paths for derivation, plus optional
	// policies to include for specific keys. It is an error to specify
	// a policy that does not apply to the corresponding key type.
	KeyTypesAndDerivationPaths []KeyTypeAndDerivationPath `json:"key_types_and_derivation_paths"`

	// Metadata Set this key's metadata. If this value is `null`, the metadata is erased. If the field is
	// missing, the metadata remains unchanged.
	Metadata *interface{} `json:"metadata,omitempty"`

	// MnemonicId Material-id of the mnemonic to use for derivation. If unspecified,
	// a new mnemonic is first created.
	MnemonicId *string `json:"mnemonic_id"`

	// Owner Specify a user other than themselves to be the (potentially new) owner of the key.
	// The specified owner must be an existing user who is a member of the same org.
	Owner *string `json:"owner"`

	// Policy Set this key's policies. For an existing key, this overwrites all its policies.
	Policy *[]interface{} `json:"policy"`
}

// EditPolicy A policy which governs when and who is allowed to update the entity this policy is
// attached to (e.g., a role or a key).
//
// When attached to a role, by default, this policy applies to role deletion and all
// role updates (including adding/removing keys and users); in terms of scopes,
// it applies to `manage:role:update:*` and `manage:role:delete`.
//
// When attached to a key, by default, this policy applies to key deletion, all
// key updates, and adding/removing that key to/from a role; in terms of scopes,
// it applies to `manage:key:update:*`, `manage:key:delete`, `manage:role:update:key:*`.
//
// This default can be changed by setting the `applies_to_scopes` property.
type EditPolicy struct {
	// AppliesToScopes A set of scopes.
	AppliesToScopes *ScopeSet      `json:"applies_to_scopes,omitempty"`
	Mfa             *MfaPolicy     `json:"mfa"`
	TimeLockUntil   *EpochDateTime `json:"time_lock_until"`
}

// Eip191SignRequest defines model for Eip191SignRequest.
type Eip191SignRequest struct {
	// Data EIP-191 data to sign as hex-encoded bytes.
	Data string `json:"data"`

	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata *interface{} `json:"metadata"`
}

// Eip712SignRequest defines model for Eip712SignRequest.
type Eip712SignRequest struct {
	// ChainId The chain-id to which this typed data will be sent
	ChainId int64 `json:"chain_id"`

	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata *interface{} `json:"metadata"`

	// TypedData Represents the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) typed data object.
	//
	// Typed data is a JSON object containing type information, domain separator parameters and the
	// message object.
	TypedData TypedData `json:"typed_data"`
}

// Email defines model for Email.
type Email = string

// EmailOtpAnswer An answer to the challenge returned by the `mfa_email_init` endpoint.
type EmailOtpAnswer struct {
	// Token Full JWT token, constructed by concatenating the "partial token"
	// (i.e., `{header}.{payload}.`) returned by the `mail_email_init` endpoint
	// and the signature sent to the user's email.
	Token string `json:"token"`
}

// EmailOtpRequest The request users send to initiate email OTP
type EmailOtpRequest struct {
	// Email The email which will receive the OTP
	Email string `json:"email"`
}

// EmailOtpResponse The HTTP response to an email OTP request.
//
// This response contains an OIDC token without a signature.
// The signature is sent to the end-user in an email.
// The token can be reconstructed by concatenating the `partial_token` with the signature.
type EmailOtpResponse struct {
	// PartialToken The OIDC token without the signature.
	// (The signature, which is actually a MAC, is sent to the end-user in an email)
	PartialToken string `json:"partial_token"`
}

// EmailPreferences defines model for EmailPreferences.
type EmailPreferences struct {
	// AlertRecipients Recipient users for org-level alerts
	AlertRecipients *[]Id `json:"alert_recipients"`

	// LoginNotifications If true, send notifications on every login
	LoginNotifications *bool `json:"login_notifications"`

	// NewDevice If true, send notifications when logging in from a new device.
	// new_device takes precedence over login_notifications. E.g., email for
	// new_device is sent instead of a general login notification email when a
	// new device is detected
	NewDevice *bool `json:"new_device"`

	// PendingApprovals If true, send email notifications for mfa approvals
	PendingApprovals *bool `json:"pending_approvals"`

	// SubscribedAlerts Org-level alerts to send emails for
	SubscribedAlerts *[]AlertKind `json:"subscribed_alerts"`
}

// Empty defines model for Empty.
type Empty = interface{}

// EmptyImpl defines model for EmptyImpl.
type EmptyImpl struct {
	Status string `json:"status"`
}

// EotsCreateNonceRequest defines model for EotsCreateNonceRequest.
type EotsCreateNonceRequest struct {
	// ChainId The chain id for which the nonces will be used, as a hex string
	ChainId string `json:"chain_id"`

	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata *interface{} `json:"metadata"`

	// Num The number of nonces to generate
	Num int32 `json:"num"`

	// StartHeight The starting block height of the generated nonces (quoted decimal u64)
	StartHeight string `json:"start_height"`
}

// EotsCreateNonceResponse Response generated when creating EOTS nonces
type EotsCreateNonceResponse struct {
	// Nonces The generated nonces as an array of 0x-prefixed hex strings
	Nonces []string `json:"nonces"`
}

// EotsSignRequest defines model for EotsSignRequest.
type EotsSignRequest struct {
	// BlockHeight The block height for the signature (quoted decimal u64)
	BlockHeight string `json:"block_height"`

	// ChainId The chain id for the signature
	ChainId string `json:"chain_id"`

	// Message The message to sign
	Message string `json:"message"`

	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata *interface{} `json:"metadata"`
}

// Epoch Epoch is a quoted `uint64`.
type Epoch = string

// EpochDateTime DateTime measured in seconds since unix epoch.
// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
type EpochDateTime = int64

// ErrorObj defines model for ErrorObj.
type ErrorObj struct {
	// Code Code
	Code int32 `json:"code"`

	// Data Optional data
	Data *interface{} `json:"data"`

	// Message Message
	Message string `json:"message"`
}

// ErrorResponse The structure of ErrorResponse must match the response template that AWS uses
type ErrorResponse struct {
	Accepted  *AcceptedValue  `json:"accepted"`
	ErrorCode SignerErrorCode `json:"error_code"`

	// Message Error message
	Message string `json:"message"`

	// RequestId Optional request identifier
	RequestId *string `json:"request_id,omitempty"`
}

// EsploraRequest Esplora request
type EsploraRequest struct {
	// Body HTTP body
	Body *string `json:"body"`

	// Method HTTP method
	Method  string                `json:"method"`
	Network EsploraRequestNetwork `json:"network"`

	// Path HTTP relative path (which comes after '/{network}/api/')
	Path string `json:"path"`
}

// EsploraRequestNetwork defines model for EsploraRequest.Network.
type EsploraRequestNetwork string

// EsploraResponse defines model for EsploraResponse.
type EsploraResponse = interface{}

// Eth1SignRequest defines model for Eth1SignRequest.
type Eth1SignRequest struct {
	// ChainId The chain id to set in the given transaction.
	ChainId int64 `json:"chain_id"`

	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata *interface{} `json:"metadata"`

	// Tx EIP-2718 typed transaction, including EIP-1559 transactions (`{ "type": "0x02" ... }`), and legacy transactions (`{ "type": "0x00" ... }`). All values in the transaction are expected to be (0x-prefixed or not) hex strings or byte arrays.
	Tx Transaction `json:"tx"`
}

// Eth1SignResponse defines model for Eth1SignResponse.
type Eth1SignResponse struct {
	// RlpSignedTx Hex-encoded RLP encoding of the transaction and its signature
	RlpSignedTx string `json:"rlp_signed_tx"`
}

// Eth2SignRequest defines model for Eth2SignRequest.
type Eth2SignRequest struct {
	// Eth2SignRequest Subset of the Web3Signer Eth2 BLS signing request whose schema is defined
	// [here](https://consensys.github.io/web3signer/web3signer-eth2.html#tag/Signing/operation/ETH2_SIGN).
	// We handle deposits and voluntary exits separately.
	Eth2SignRequest map[string]interface{} `json:"eth2_sign_request"`

	// Network Network name ('mainnet', 'holesky')
	Network Network `json:"network"`
}

// Eth2SignResponse defines model for Eth2SignResponse.
type Eth2SignResponse struct {
	// Signature Hex encoded signature prefixed with 0x e.g. "0x0000..."
	Signature string `json:"signature"`
}

// EvmChain Supported EVM chains.
type EvmChain string

// EvmOptions EVM addresses. You may set a global address for every EVM chain,
// or a set of addresses for specific chains.
type EvmOptions struct {
	union json.RawMessage
}

// EvmOptionsObject EVM addresses associated with specific chains. The keys are
// `EvmChain`s and the values are addresses.
type EvmOptionsObject map[string]string

// EvmOptionsString An EVM address that is permitted for use on any EVM chain.
type EvmOptionsString = string

// EvmTxCmp defines model for EvmTxCmp.
type EvmTxCmp struct {
	// Grace To prevent replay attacks, any given MFA receipt is normally allowed to be used only once.
	//
	// In this case, however, because EVM transactions already have a replay prevention mechanism
	// (namely the 'nonce' property), we allow the user to specify a grace period (in seconds) to
	// indicate how long an MFA receipt should remain valid after its first use.
	//
	// Note that we allow both 'grace' and 'ignore_nonce' to be set because once an MFA request
	// enters its grace period we unconditionally set its 'ignore_nonce' property to 'false' to
	// ensure that any subsequent requests that claim the same receipt must sign for the same
	// nonce as the request we signed originally with that receipt.
	//
	// Also note that the grace period cannot extend the lifetime of an MFA request beyond its
	// original expiration date.
	//
	// The grace period must not be greater than 30 days.
	Grace *int64 `json:"grace"`

	// IgnoreGas Whether the 'gas' property of the EVM transaction is allowed to be different.
	IgnoreGas *bool `json:"ignore_gas,omitempty"`

	// IgnoreNonce Whether the 'nonce' property of the EVM transaction is allowed to be different.
	IgnoreNonce *bool `json:"ignore_nonce,omitempty"`
}

// EvmTxDepositErrorCode defines model for EvmTxDepositErrorCode.
type EvmTxDepositErrorCode string

// ExecutionSource The source of a policy execution, i.e. the reason it was executed.
type ExecutionSource string

// ExplicitScopes Explicitly named scopes for accessing CubeSigner APIs
type ExplicitScopes string

// FeeType This type specifies the interpretation of the `fee` field in Babylon
// staking requests. If `sats`, the field is intpreted as a fixed value
// in sats. If `sats_pr_vb`, the field is interpreted as a rate and the
// fee is computed by estimating the weight of the output transaction.
type FeeType string

// FidoAssertAnswer Sent from the client to the server to answer a fido challenge
type FidoAssertAnswer struct {
	// ChallengeId The ID of the challenge that was returned from the POST endpoint
	ChallengeId string `json:"challenge_id"`

	// Credential This type represents a wire-encodable form of the PublicKeyCredential interface
	// Clients may need to manually encode into this format to communicate with the server
	//
	// The PublicKeyCredential interface inherits from Credential
	// [CREDENTIAL-MANAGEMENT-1], and contains the attributes that are returned to
	// the caller when a new credential is created, or a new assertion is
	// requested.
	//
	// https://www.w3.org/TR/webauthn-2/#iface-pkcredential
	Credential PublicKeyCredential `json:"credential"`
}

// FidoAssertChallenge defines model for FidoAssertChallenge.
type FidoAssertChallenge struct {
	// ChallengeId The id of the challenge. Must be supplied when answering the challenge.
	ChallengeId string `json:"challenge_id"`

	// Options The `PublicKeyCredentialRequestOptions` dictionary supplies get() with the
	// data it needs to generate an assertion. Its challenge member MUST be
	// present, while its other members are OPTIONAL.
	//
	// This struct is also used as part of the verification procedure for assertions
	Options PublicKeyCredentialRequestOptions `json:"options"`

	// Preimage A base64url encoding of UTF8 JSON. The data in that JSON is endpoint specific, and describes what this FIDO challenge will be used for.
	//
	// Clients can use `preimage` along with `random_seed` to reconstruct the challenge like so:
	//
	// `challenge = HMAC-SHA256(key=random_seed, message=preimage)`
	Preimage string `json:"preimage"`

	// RandomSeed A random seed that prevents replay attacks
	RandomSeed string `json:"random_seed"`
}

// FidoCreateChallengeAnswer Sent from the client to the server to answer a fido challenge
type FidoCreateChallengeAnswer struct {
	// ChallengeId The ID of the challenge that was returned from the POST endpoint
	ChallengeId string `json:"challenge_id"`

	// Credential This type represents a wire-encodable form of the PublicKeyCredential interface
	// Clients may need to manually encode into this format to communicate with the server
	//
	// The PublicKeyCredential interface inherits from Credential
	// [CREDENTIAL-MANAGEMENT-1], and contains the attributes that are returned to
	// the caller when a new credential is created, or a new assertion is
	// requested.
	//
	// https://www.w3.org/TR/webauthn-2/#iface-pkcredential
	Credential PublicKeyCredential `json:"credential"`
}

// FidoCreateChallengeResponse defines model for FidoCreateChallengeResponse.
type FidoCreateChallengeResponse struct {
	// ChallengeId The id of the challenge. Must be supplied when answering the challenge.
	ChallengeId string `json:"challenge_id"`

	// Options Defines the parameters for the creation of a new public key credential
	//
	// https://www.w3.org/TR/webauthn-2/#dictdef-publickeycredentialcreationoptions
	Options PublicKeyCredentialCreationOptions `json:"options"`

	// Preimage A base64url encoding of UTF8 JSON. The data in that JSON is endpoint specific, and describes what this FIDO challenge will be used for.
	//
	// Clients can use `preimage` along with `random_seed` to reconstruct the challenge like so:
	//
	// `challenge = HMAC-SHA256(key=random_seed, message=preimage)`
	Preimage string `json:"preimage"`

	// RandomSeed A random seed that prevents replay attacks
	RandomSeed string `json:"random_seed"`
}

// FidoCreateRequest Declares intent to register a new FIDO key
type FidoCreateRequest struct {
	// Discoverable Whether this key can be used for passwordless login
	Discoverable *bool `json:"discoverable,omitempty"`

	// Name A human-readable name for the new fido credential
	Name string `json:"name"`
}

// ForbiddenErrorCode defines model for ForbiddenErrorCode.
type ForbiddenErrorCode string

// Fork Specifies a fork of the `BeaconChain`, to prevent replay attacks.
// The schema of `Fork` is defined in the [Beacon chain
// spec](https://github.com/ethereum/consensus-specs/blob/v1.0.1/specs/phase0/beacon-chain.md#fork).
type Fork struct {
	// CurrentVersion Current fork version.
	CurrentVersion string `json:"current_version"`

	// Epoch Epoch is a quoted `uint64`.
	Epoch Epoch `json:"epoch"`

	// PreviousVersion Previous fork version.
	PreviousVersion string `json:"previous_version"`
}

// GenesisData Genesis data as defined in the [Beacon API
// spec](https://ethereum.github.io/beacon-APIs/#/Beacon/getGenesis).
// You can get the genesis data from the Beacon node's `/eth/v1/beacon/genesis` end-point.
// This struct definition is originally from lighthouse's eth2.
type GenesisData struct {
	// GenesisForkVersion Genesis fork version.
	GenesisForkVersion string `json:"genesis_fork_version"`

	// GenesisTime Genesis time
	GenesisTime string `json:"genesis_time"`

	// GenesisValidatorsRoot Genesis validators root.
	GenesisValidatorsRoot string `json:"genesis_validators_root"`
}

// GetKeysInOrgRequest defines model for GetKeysInOrgRequest.
type GetKeysInOrgRequest struct {
	KeyType *KeyType `json:"key_type"`
}

// HeartbeatRequest Stats pertaining the the sender `cube3signer` instance
type HeartbeatRequest struct {
	// CurrentNumRequestsActive Number of requests currently active (received but not necessarily being processed yet)
	CurrentNumRequestsActive int64 `json:"current_num_requests_active"`

	// CurrentNumRequestsProcessing Number of requests currently being processed by cube3signer
	CurrentNumRequestsProcessing int64 `json:"current_num_requests_processing"`

	// Ignore Do not record metric data from this heartbeat
	Ignore *bool `json:"ignore,omitempty"`

	// NumRequests Number of new requests during this heartbeat period
	NumRequests int64 `json:"num_requests"`

	// NumRequestsFailed Number of requests that failed during this heartbeat period
	NumRequestsFailed int64 `json:"num_requests_failed"`

	// NumRequestsRetried Number of requests were retried during this heartbeat period
	NumRequestsRetried int64 `json:"num_requests_retried"`

	// NumRetries Number of retries during this heartbeat period
	NumRetries int64 `json:"num_retries"`

	// NumTokenRefreshes Number of times auth token was refreshed during this heartbeat period
	NumTokenRefreshes *int64 `json:"num_token_refreshes,omitempty"`

	// NumTokenRefreshesFailed Number of times auth token refresh failed during this heartbeat period
	NumTokenRefreshesFailed *int64 `json:"num_token_refreshes_failed,omitempty"`

	// ProxyVersion Version of the proxy sending the heart beat request
	//
	// TODO: Make non-optional once we do not support proxies without version information
	ProxyVersion *string `json:"proxy_version"`
}

// HistoricalDataConfiguration Configuration governing whether and how to save historical data.
type HistoricalDataConfiguration struct {
	// Tx Configuration governing whether and how to save historical transactions.
	Tx HistoricalTxConfiguration `json:"tx"`
}

// HistoricalTx A recently signed transaction that we store in the DB.
type HistoricalTx struct {
	// Date DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	Date EpochDateTime `json:"date"`

	// ExpEpoch DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	ExpEpoch          EpochDateTime `json:"exp_epoch"`
	HistoricalTxOrgId Id            `json:"historical_tx_org_id"`
	KeyId             Id            `json:"key_id"`
	MfaStatus         *Status       `json:"mfa_status"`

	// Operation All different kinds of sensitive operations
	Operation OperationKind `json:"operation"`

	// Request Information about the request.
	//
	// Captures all the relevant info (including the request body) about requests that require MFA.
	// We use this to verify that when a request is resumed (after obtaining necessary MFA approvals)
	// it is exactly the same as it originally was.
	Request HttpRequest `json:"request"`

	// RequestId Original request id
	RequestId *string `json:"request_id"`

	// Result Operation-specific result
	Result interface{} `json:"result"`
	RoleId *Id         `json:"role_id"`
	UserId *Id         `json:"user_id"`
}

// HistoricalTxConfiguration Configuration governing whether and how to save historical transactions.
type HistoricalTxConfiguration struct {
	Lifetime *Seconds `json:"lifetime"`
}

// HttpRequest Information about the request.
//
// Captures all the relevant info (including the request body) about requests that require MFA.
// We use this to verify that when a request is resumed (after obtaining necessary MFA approvals)
// it is exactly the same as it originally was.
type HttpRequest struct {
	// Body HTTP request body
	Body *map[string]interface{} `json:"body"`

	// Method HTTP method of the request
	Method string `json:"method"`

	// Path HTTP path of the request, excluding the host
	Path string `json:"path"`
}

// HttpRequestCmp How to compare HTTP requests when verifying MFA receipt (see [MfaRequest::verify_request])
type HttpRequestCmp struct {
	union json.RawMessage
}

// HttpRequestCmpEq The requests must match exactly. Any given MFA receipt can be used at most once.
type HttpRequestCmpEq string

// HttpRequestCmpEvmTx defines model for HttpRequestCmpEvmTx.
type HttpRequestCmpEvmTx struct {
	EvmTx EvmTxCmp `json:"EvmTx"`
}

// HttpRequestCmpSolanaTx defines model for HttpRequestCmpSolanaTx.
type HttpRequestCmpSolanaTx struct {
	SolanaTx SolanaTxCmp `json:"SolanaTx"`
}

// Id defines model for Id.
type Id = string

// IdentityInfo defines model for IdentityInfo.
type IdentityInfo struct {
	// Email The email associated with the user
	Email *string `json:"email"`

	// Iss The root-level issuer who administrates this user. From the OIDC spec:
	// Issuer Identifier for the Issuer of the response. The iss
	// value is a case sensitive URL using the https scheme that contains
	// scheme, host, and optionally, port number and path components and
	// no query or fragment components.
	Iss string `json:"iss"`

	// PreferredUsername The user name (if any) associated with the user
	PreferredUsername *string `json:"preferred_username"`

	// Sub From the OIDC spec:
	//
	// A locally unique and never reassigned identifier within the Issuer for
	// the End-User, which is intended to be consumed by the Client, e.g.,
	// 24400320 or AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4. It MUST NOT exceed
	// 255 ASCII characters in length. The sub value is a case sensitive
	// string.
	Sub string `json:"sub"`
}

// IdentityProof defines model for IdentityProof.
type IdentityProof struct {
	Aud *Aud `json:"aud"`

	// Email The email associated with the user
	Email *string `json:"email"`

	// ExpEpoch DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	ExpEpoch EpochDateTime `json:"exp_epoch"`

	// Id An opaque identifier for the proof
	Id       string        `json:"id"`
	Identity *OidcIdentity `json:"identity"`

	// PreferredUsername The username (if any) associated with the user
	PreferredUsername *string             `json:"preferred_username"`
	UserInfo          *CubeSignerUserInfo `json:"user_info"`
}

// IdpConfig IDP configuration
type IdpConfig struct {
	Throttle *ThrottleConfig `json:"throttle"`

	// Users Enable for certain user roles
	Users *[]MemberRole `json:"users"`
}

// ImportKeyRequest defines model for ImportKeyRequest.
type ImportKeyRequest struct {
	// DkEnc Base64-encoded, encrypted data key.
	DkEnc      string      `json:"dk_enc"`
	EditPolicy *EditPolicy `json:"edit_policy"`

	// Expires Expiration timestamp expressed as seconds since the UNIX epoch.
	Expires int64 `json:"expires"`

	// Idempotent When false (the default), nothing is returned when an imported key already
	// exists. When true, returns the KeyInfo struct for keys that already exist
	// if caller is allowed to list that key.
	Idempotent *bool `json:"idempotent,omitempty"`

	// KeyMaterial A set of encrypted keys to be imported
	KeyMaterial []ImportKeyRequestMaterial `json:"key_material"`
	KeyType     KeyType                    `json:"key_type"`

	// Metadata Set this key's metadata. If this value is `null`, the metadata is erased. If the field is
	// missing, the metadata remains unchanged.
	Metadata *interface{} `json:"metadata,omitempty"`

	// Owner Specify a user other than themselves to be the (potentially new) owner of the key.
	// The specified owner must be an existing user who is a member of the same org.
	Owner *string `json:"owner"`

	// Policy Set this key's policies. For an existing key, this overwrites all its policies.
	Policy *[]interface{} `json:"policy"`

	// PublicKey The ephemeral public key to which an imported key should be encrypted.
	// This is a P384 public key in base64-encoded uncompressed SECG format.
	PublicKey string `json:"public_key"`

	// SkEnc Base64-encoded, encrypted secret key.
	SkEnc string `json:"sk_enc"`
}

// ImportKeyRequestMaterial defines model for ImportKeyRequestMaterial.
type ImportKeyRequestMaterial struct {
	// ClientPublicKey The client's ephemeral public key used to derive a shared key.
	// This is a base64-encoded, SEC1-encoded P384 public key.
	ClientPublicKey string `json:"client_public_key"`

	// IkmEnc The encrypted keying material to be imported.
	// This is a base64-encoded ciphertext.
	IkmEnc string `json:"ikm_enc"`

	// Salt A salt value used to derive a shared key.
	// This is a base64-encoded byte string.
	Salt string `json:"salt"`
}

// ImportableSecrets Helper type for enforcing validation before having access to the configs and import key.
type ImportableSecrets struct {
	ImportKey *KeyImportKey `json:"import_key"`

	// Secrets The policy secrets.
	Secrets *map[string]SecretValue `json:"secrets"`
}

// InternalErrorCode defines model for InternalErrorCode.
type InternalErrorCode string

// InvitationAcceptRequest defines model for InvitationAcceptRequest.
type InvitationAcceptRequest struct {
	// Auth At redemption time, the user must provide a credential they wish to use to authenticate.
	// This enum represents the two possible sources of authentication.
	Auth AuthSource `json:"auth"`

	// Token Invitation token
	Token string `json:"token"`
}

// InviteKind Indicates the auth sources allowed to an invited user
type InviteKind string

// InviteRequest defines model for InviteRequest.
type InviteRequest struct {
	// Email The user's email address
	Email      string      `json:"email"`
	InviteKind *InviteKind `json:"invite_kind"`

	// MfaPolicy Optional login MFA policy
	MfaPolicy *map[string]interface{} `json:"mfa_policy"`

	// Name The user's full name
	Name string      `json:"name"`
	Role *MemberRole `json:"role"`

	// SkipEmail Skip sending an invitation email to this user if true.
	//
	// NOTE: this field is for internal testing use ONLY. If you do not
	// send an invitation email (and the invite kind is not SSO), the user will never be able to log in.
	SkipEmail bool `json:"skip_email"`
}

// InvokePolicyRequest A request containing the data that a Wasm policy should be invoked with.
type InvokePolicyRequest struct {
	// KeyId The Key ID that should be sent to the policy.
	KeyId string `json:"key_id"`

	// Request The "request body" that should be sent to the policy.
	Request *interface{} `json:"request"`

	// RoleId An optional Role ID. If `None`, the policy will be invoked from the current user session.
	RoleId *string `json:"role_id"`
}

// InvokePolicyResponse The result of invoking a Wasm policy.
type InvokePolicyResponse struct {
	// Response The response from invoking a Wasm policy.
	Response WasmPolicyResponse `json:"response"`

	// Stderr The bytes written to `stderr`, encoded as a hex-string.
	// In most cases, these bytes correspond to a UTF-8-encoded `String`.
	Stderr string `json:"stderr"`

	// Stdout The bytes written to `stdout`, encoded as a hex-string.
	// In most cases, these bytes correspond to a UTF-8-encoded `String`.
	Stdout string `json:"stdout"`
}

// JrpcResponse defines model for JrpcResponse.
type JrpcResponse struct {
	Error *ErrorObj `json:"error"`

	// Id ID from the corresponding request
	Id *interface{} `json:"id"`

	// Jsonrpc Constant "2.0"
	Jsonrpc string `json:"jsonrpc"`

	// Result Result, if success
	Result *map[string]interface{} `json:"result"`
}

// JsonKeyPackage defines model for JsonKeyPackage.
type JsonKeyPackage struct {
	// KeyType The type of key this package represents
	KeyType string `json:"key_type"`
	union   json.RawMessage
}

// JsonKeyPackageEnglishMnemonic A key derived from a mnemonic
type JsonKeyPackageEnglishMnemonic struct {
	// DerivationPath The derivation path
	DerivationPath string                                    `json:"derivation_path"`
	MaterialType   JsonKeyPackageEnglishMnemonicMaterialType `json:"material_type"`

	// Mnemonic The mnemonic
	Mnemonic string `json:"mnemonic"`

	// Password The password (which may be empty)
	Password string `json:"password"`
}

// JsonKeyPackageEnglishMnemonicMaterialType defines model for JsonKeyPackageEnglishMnemonic.MaterialType.
type JsonKeyPackageEnglishMnemonicMaterialType string

// JsonKeyPackageRawSecret A raw key
type JsonKeyPackageRawSecret struct {
	MaterialType JsonKeyPackageRawSecretMaterialType `json:"material_type"`

	// Secret The value of the raw secret
	Secret string `json:"secret"`
}

// JsonKeyPackageRawSecretMaterialType defines model for JsonKeyPackageRawSecret.MaterialType.
type JsonKeyPackageRawSecretMaterialType string

// JwkSetResponse defines model for JwkSetResponse.
type JwkSetResponse = map[string]interface{}

// KeyCountDimensions defines model for KeyCountDimensions.
type KeyCountDimensions struct {
	// KeyType The key type
	KeyType string `json:"key_type"`

	// OrgId All metrics must include 'org_id' as a dimension.
	OrgId string `json:"org_id"`
}

// KeyDerivationInfo Derivation-related metadata for keys derived from a long-lived mnemonic
type KeyDerivationInfo struct {
	// DerivationPath The derivation path used to derive this key
	DerivationPath string `json:"derivation_path"`

	// MnemonicId The mnemonic-id of the key's parent mnemonic
	MnemonicId string `json:"mnemonic_id"`
}

// KeyImportKey A wrapped key-import key
type KeyImportKey struct {
	// DkEnc Base64-encoded, encrypted data key.
	DkEnc string `json:"dk_enc"`

	// Expires Expiration timestamp expressed as seconds since the UNIX epoch.
	Expires int64 `json:"expires"`

	// PublicKey The ephemeral public key to which an imported key should be encrypted.
	// This is a P384 public key in base64-encoded uncompressed SECG format.
	PublicKey string `json:"public_key"`

	// SkEnc Base64-encoded, encrypted secret key.
	SkEnc string `json:"sk_enc"`
}

// KeyInRoleInfo defines model for KeyInRoleInfo.
type KeyInRoleInfo struct {
	// KeyId Key ID
	KeyId string `json:"key_id"`

	// Policy Policies that are checked before this key is used on behalf of this role
	Policy *[]map[string]interface{} `json:"policy,omitempty"`

	// RoleId Role ID
	RoleId string `json:"role_id"`
}

// KeyInfo defines model for KeyInfo.
type KeyInfo struct {
	Created        *EpochDateTime     `json:"created"`
	DerivationInfo *KeyDerivationInfo `json:"derivation_info"`

	// EditPolicy A policy which governs when and who is allowed to update the entity this policy is
	// attached to (e.g., a role or a key).
	//
	// When attached to a role, by default, this policy applies to role deletion and all
	// role updates (including adding/removing keys and users); in terms of scopes,
	// it applies to `manage:role:update:*` and `manage:role:delete`.
	//
	// When attached to a key, by default, this policy applies to key deletion, all
	// key updates, and adding/removing that key to/from a role; in terms of scopes,
	// it applies to `manage:key:update:*`, `manage:key:delete`, `manage:role:update:key:*`.
	//
	// This default can be changed by setting the `applies_to_scopes` property.
	EditPolicy *EditPolicy `json:"edit_policy,omitempty"`

	// Enabled Whether the key is enabled (only enabled keys may be used for signing)
	Enabled bool `json:"enabled"`

	// KeyId The id of the key: "Key#" followed by a unique identifier specific to
	// the type of key (such as a public key for BLS or an ethereum address for Secp)
	KeyId        string         `json:"key_id"`
	KeyType      KeyType        `json:"key_type"`
	LastModified *EpochDateTime `json:"last_modified"`

	// MaterialId A unique identifier specific to the type of key, such as a public key or an ethereum address
	MaterialId string `json:"material_id"`

	// Metadata User-defined metadata. When rendering (e.g., in the browser) you should treat
	// it as untrusted user data (and avoid injecting metadata into HTML directly) if
	// untrusted users can create/update keys (or their metadata).
	Metadata *interface{} `json:"metadata,omitempty"`

	// Owner Owner of the key
	Owner string `json:"owner"`

	// Policy Key policy
	Policy []interface{} `json:"policy"`

	// PublicKey Hex-encoded, serialized public key. The format used depends on the key type:
	// - Secp256k1 keys use 65-byte uncompressed SECG format;
	// - Stark keys use 33-byte compressed SECG format;
	// - BLS keys use 48-byte compressed BLS12-381 (ZCash) format;
	// - Ed25519 keys use the canonical 32-byte encoding specified in RFC 8032.
	PublicKey string `json:"public_key"`

	// Purpose The purpose for which the key can be used (e.g., chain id for which the key is allowed to sign messages)
	Purpose string `json:"purpose"`

	// Version Version of this object
	Version *int64 `json:"version,omitempty"`
}

// KeyInfos defines model for KeyInfos.
type KeyInfos struct {
	Keys []KeyInfo `json:"keys"`
}

// KeyType defines model for KeyType.
type KeyType string

// KeyTypeAndDerivationPath defines model for KeyTypeAndDerivationPath.
type KeyTypeAndDerivationPath struct {
	// DerivationPath List of derivation paths for which to derive.
	DerivationPath string  `json:"derivation_path"`
	KeyType        KeyType `json:"key_type"`

	// Policy Policies to apply to this key. It is an error to specify a policy
	// that is not compatible with `key_type`.
	Policy *[]interface{} `json:"policy"`
}

// LastEvalKey Wrapper around encrypted [UnencryptedLastEvalKey] bytes.
//
// We serialize this into a base64url-encoded string and return to the user
// so that they can pass this back to us as a url query parameter.
type LastEvalKey = string

// ListIdentitiesResponse Third-party identities associated with the user's account
type ListIdentitiesResponse struct {
	Identities []IdentityInfo `json:"identities"`
}

// ListMfaResponse defines model for ListMfaResponse.
type ListMfaResponse struct {
	// MfaRequests All pending MFA requests
	MfaRequests []MfaRequestInfo `json:"mfa_requests"`
}

// ListPendingMessagesResponse All pending MMI requests created by the current user.
type ListPendingMessagesResponse struct {
	// PendingMessages All pending messages for a user.
	PendingMessages []PendingMessageInfo `json:"pending_messages"`
}

// LoginRequest OIDC login request
type LoginRequest = OidcLoginRequest

// MemberRole Describes whether a user in an org is an Owner or just a regular member
type MemberRole string

// MembershipStatus defines model for MembershipStatus.
type MembershipStatus string

// MetricName The name of the metric to compute
type MetricName struct {
	union json.RawMessage
}

// MfaPolicy defines model for MfaPolicy.
type MfaPolicy struct {
	// AllowedApprovers Users who are allowed to approve. If empty at creation time, default to the current user.
	AllowedApprovers *[]string `json:"allowed_approvers,omitempty"`

	// AllowedMfaTypes Allowed approval types. When omitted, defaults to any.
	AllowedMfaTypes *[]MfaType `json:"allowed_mfa_types"`

	// Count How many users to require to approve (defaults to 1).
	Count *int32 `json:"count,omitempty"`

	// Lifetime Duration measured in seconds
	// A wrapper type for serialization that encodes a `Duration` as a `u64` representing the number of seconds.
	Lifetime *Seconds `json:"lifetime,omitempty"`

	// NumAuthFactors How many auth factors to require per user (defaults to 1).
	NumAuthFactors *int32 `json:"num_auth_factors,omitempty"`

	// RequestComparer How to compare HTTP requests when verifying MFA receipt (see [MfaRequest::verify_request])
	RequestComparer *HttpRequestCmp `json:"request_comparer,omitempty"`

	// RestrictedOperations CubeSigner operations to which this policy should apply.
	// When omitted, applies to all operations.
	RestrictedOperations *[]OperationKind `json:"restricted_operations"`

	// TimeDelay Duration measured in seconds
	// A wrapper type for serialization that encodes a `Duration` as a `u64` representing the number of seconds.
	TimeDelay *Seconds `json:"time_delay,omitempty"`
}

// MfaRequestInfo Returned as a response from multiple routes (e.g., 'get mfa', 'approve mfa', 'approve totp').
type MfaRequestInfo struct {
	// CreatedBy The session identity (user or role) that created this request.
	CreatedBy string `json:"created_by"`

	// ExpiresAt DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	ExpiresAt EpochDateTime `json:"expires_at"`

	// Id Approval request ID.
	Id string `json:"id"`

	// NotValidUntil DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	NotValidUntil *EpochDateTime `json:"not_valid_until,omitempty"`

	// Provenance MFA policy provenance
	Provenance MfaRequestInfoProvenance `json:"provenance"`
	Receipt    *Receipt                 `json:"receipt"`

	// RelatedIds If set, contains the IDs of all MFA requests (including this one!) that
	// were generated at once for the same CubeSigner operation.
	//
	// If not set, it means that this was the lone MFA request generated for `request`.
	//
	// This is useful so that a client can discover all the MFAs whose receipts must
	// be submitted together to carry out the original CubeSigner operation.
	RelatedIds *[]string `json:"related_ids,omitempty"`

	// Request Information about the request.
	//
	// Captures all the relevant info (including the request body) about requests that require MFA.
	// We use this to verify that when a request is resumed (after obtaining necessary MFA approvals)
	// it is exactly the same as it originally was.
	Request HttpRequest `json:"request"`
	Status  Status      `json:"status"`
}

// MfaRequestInfoProvenance MFA policy provenance
type MfaRequestInfoProvenance string

// MfaType defines model for MfaType.
type MfaType struct {
	union json.RawMessage
}

// MfaTypeCubeSigner Log in with CubeSigner user credentials
type MfaTypeCubeSigner string

// MfaTypeEmailOtp Provide OTP code sent via email
type MfaTypeEmailOtp string

// MfaTypeFido Answer a FIDO challenge using any registered FIDO key
type MfaTypeFido string

// MfaTypeFidoKey defines model for MfaTypeFidoKey.
type MfaTypeFidoKey struct {
	// FidoKey Answer a FIDO challenge with a specific FIDO key
	FidoKey struct {
		// KeyId The ID of the FIDO key that must be use to approve the request
		KeyId string `json:"key_id"`
	} `json:"FidoKey"`
}

// MfaTypeTotp Provide TOTP code
type MfaTypeTotp string

// MfaVote defines model for MfaVote.
type MfaVote string

// MigrateIdentityItem defines model for MigrateIdentityItem.
type MigrateIdentityItem struct {
	// Iss The root-level issuer who administrates this user. From the OIDC spec:
	// Issuer Identifier for the Issuer of the response. The iss
	// value is a case sensitive URL using the https scheme that contains
	// scheme, host, and optionally, port number and path components and
	// no query or fragment components.
	Iss string `json:"iss"`

	// Sub From the OIDC spec:
	//
	// A locally unique and never reassigned identifier within the Issuer for
	// the End-User, which is intended to be consumed by the Client, e.g.,
	// 24400320 or AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4. It MUST NOT exceed
	// 255 ASCII characters in length. The sub value is a case sensitive
	// string.
	Sub string `json:"sub"`

	// UserId The id of the user you want to operate on
	UserId string `json:"user_id"`
}

// MigrateIdentityRequest A request to add or remose an OIDC identities for an existing user
type MigrateIdentityRequest = []MigrateIdentityItem

// MmiMetadata defines model for MmiMetadata.
type MmiMetadata struct {
	// Accounts All accounts the user can access.
	// Only set when requested explicitly, i.e., via 'customer_listAccountsSigned'.
	Accounts *[]struct {
		// Address An Ethereum address, hex-encoded, with leading '0x'
		Address string `json:"address"`

		// Metadata Account metadata
		Metadata *interface{} `json:"metadata,omitempty"`

		// Name Account name
		Name string `json:"name"`

		// Tags Ordered list of name-value pairs
		Tags *[]struct {
			// Name Tag name
			Name string `json:"name"`

			// Value Tag value
			Value string `json:"value"`
		} `json:"tags,omitempty"`
	} `json:"accounts"`

	// ChainId Chain ID (not required when signing a personal message (EIP-191))
	ChainId *string `json:"chainId"`

	// CustodianPublishesTransaction If the custodian should publish the transaction
	CustodianPublishesTransaction *bool `json:"custodianPublishesTransaction"`

	// CustomerId The customer ID of the user, i.e., the customer's organization ID.
	CustomerId *string `json:"customerId"`

	// CustomerName A human readable name of the corresponding organization, if any.
	CustomerName *string `json:"customerName"`

	// Note A note to be attached to the transaction which can be specified by the user
	Note *string `json:"note"`

	// OriginUrl The web page/dapp where the transaction originated
	OriginUrl *string `json:"originUrl"`

	// RpcUrl User's preferred RPC URL, and it should be the same as the RPC URL for the network corresponding to the Chain ID
	RpcUrl *string `json:"rpcUrl"`

	// TransactionCategory The category of transaction, as best can be determined by the wallet
	TransactionCategory *string `json:"transactionCategory"`

	// UserId This must match the `sub` claim of the customer proof of
	// the user or role session which created the transaction.
	UserId *string `json:"userId"`
}

// MmiMetadataExt defines model for MmiMetadataExt.
type MmiMetadataExt struct {
	// Accounts All accounts the user can access.
	// Only set when requested explicitly, i.e., via 'customer_listAccountsSigned'.
	Accounts *[]struct {
		// Address An Ethereum address, hex-encoded, with leading '0x'
		Address string `json:"address"`

		// Metadata Account metadata
		Metadata *interface{} `json:"metadata,omitempty"`

		// Name Account name
		Name string `json:"name"`

		// Tags Ordered list of name-value pairs
		Tags *[]struct {
			// Name Tag name
			Name string `json:"name"`

			// Value Tag value
			Value string `json:"value"`
		} `json:"tags,omitempty"`
	} `json:"accounts"`

	// CustomerId The customer ID of the user, i.e., the customer's organization ID.
	CustomerId *string `json:"customerId"`

	// CustomerName A human readable name of the corresponding organization, if any.
	CustomerName *string `json:"customerName"`

	// UserId This must match the `sub` claim of the customer proof of
	// the user or role session which created the transaction.
	UserId *string `json:"userId"`
}

// MmiRejectRequest defines model for MmiRejectRequest.
type MmiRejectRequest struct {
	// Reason Optional reason for rejecting.
	Reason *string `json:"reason"`
}

// MmiStatus defines model for MmiStatus.
type MmiStatus struct {
	// DisplayText Short text to display to the user
	DisplayText string `json:"displayText"`

	// Finished Whether the signed message has finished, e.g. it is completed, failed or cancelled
	Finished bool `json:"finished"`

	// Reason The reason for the signed message status
	Reason *string `json:"reason"`

	// Signed Whether the message was signed
	Signed bool `json:"signed"`

	// Submitted Whether the transaction was submitted to the blockchain
	Submitted *bool `json:"submitted,omitempty"`

	// Success Whether the transaction was successful, i.e. it was included in a block and not reverted
	Success bool `json:"success"`
}

// MsgSignature Information about a signed message
type MsgSignature struct {
	// Signature The signature
	Signature string `json:"signature"`
}

// MsgStatus A struct representing the pending message status
type MsgStatus struct {
	union json.RawMessage
}

// MsgStatusPending defines model for MsgStatusPending.
type MsgStatusPending struct {
	Status MsgStatusPendingStatus `json:"status"`
}

// MsgStatusPendingStatus defines model for MsgStatusPending.Status.
type MsgStatusPendingStatus string

// MsgStatusRejected The message has been rejected, including the reason for the rejection.
type MsgStatusRejected struct {
	Reason string                  `json:"reason"`
	Status MsgStatusRejectedStatus `json:"status"`
}

// MsgStatusRejectedStatus defines model for MsgStatusRejected.Status.
type MsgStatusRejectedStatus string

// MsgStatusSigned The message has been signed, including the signature information.
type MsgStatusSigned struct {
	// Sig Information about a signed message
	Sig struct {
		// Signature The signature
		Signature string `json:"signature"`
	} `json:"sig"`
	Status MsgStatusSignedStatus `json:"status"`
}

// MsgStatusSignedStatus defines model for MsgStatusSigned.Status.
type MsgStatusSignedStatus string

// Network Network name ('mainnet', 'holesky')
type Network string

// NewSessionResponse Information about a new session, returned from multiple endpoints (e.g., login, refresh, etc.).
type NewSessionResponse struct {
	// Expiration Session expiration (in seconds since UNIX epoch), beyond which it cannot be refreshed.
	Expiration *int64 `json:"expiration,omitempty"`
	OrgId      *Id    `json:"org_id"`

	// RefreshToken Token that can be used to refresh this session.
	RefreshToken string `json:"refresh_token"`

	// SessionInfo Session information sent to the client.
	// This struct works in tandem with its server-side counterpart [`SessionData`].
	SessionInfo ClientSessionInfo `json:"session_info"`

	// Token New token to be used for authentication. Requests to signing endpoints
	// should include this value in the `Authorization` header.
	Token string `json:"token"`
}

// NonceValue defines model for NonceValue.
type NonceValue = openapi_types.File

// NotFoundErrorCode defines model for NotFoundErrorCode.
type NotFoundErrorCode string

// NotificationEndpoint defines model for NotificationEndpoint.
type NotificationEndpoint struct {
	// Arn The ARN of the subscription
	Arn string `json:"arn"`

	// Config The configuration for an org event endpoint
	Config NotificationEndpointConfiguration `json:"config"`

	// Status The status of a subscription
	Status SubscriptionStatus `json:"status"`
}

// NotificationEndpointConfiguration The configuration for an org event endpoint
type NotificationEndpointConfiguration struct {
	// Filter Filter for org events
	Filter *OrgEventFilter `json:"filter,omitempty"`

	// Url URL of the endpoint
	Url string `json:"url"`
}

// NotificationEndpointSubscription A notification endpoint subscription
type NotificationEndpointSubscription struct {
	// Arn The ARN of the subscription
	Arn string `json:"arn"`

	// Config The configuration for an org event endpoint
	Config NotificationEndpointConfiguration `json:"config"`
}

// OidcIdentity Represents a globally unique OIDC-authorized user by expressing the full "path" to a user. That is:
//
// (iss) (sub)
// Issuer -> Subresource
type OidcIdentity struct {
	// Iss The root-level issuer who administrates this user. From the OIDC spec:
	// Issuer Identifier for the Issuer of the response. The iss
	// value is a case sensitive URL using the https scheme that contains
	// scheme, host, and optionally, port number and path components and
	// no query or fragment components.
	Iss string `json:"iss"`

	// Sub From the OIDC spec:
	//
	// A locally unique and never reassigned identifier within the Issuer for
	// the End-User, which is intended to be consumed by the Client, e.g.,
	// 24400320 or AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4. It MUST NOT exceed
	// 255 ASCII characters in length. The sub value is a case sensitive
	// string.
	Sub string `json:"sub"`
}

// OidcIssuerInfo Information about an explicitly configured (allowlisted) OpenID provider for an org
type OidcIssuerInfo struct {
	// Audiences Intended audiences (client IDs)
	Audiences []string `json:"audiences"`

	// Issuer Issuer URL
	Issuer string `json:"issuer"`

	// Nickname Optional issuer nickname
	Nickname *string `json:"nickname"`

	// Users The user roles allowed to use this IDP
	Users []MemberRole `json:"users"`
}

// OidcLoginDimensions defines model for OidcLoginDimensions.
type OidcLoginDimensions struct {
	// Issuer The OIDC issuer (provider)
	Issuer string `json:"issuer"`

	// OrgId All metrics must include 'org_id' as a dimension.
	OrgId string `json:"org_id"`
}

// OidcLoginRequest defines model for OidcLoginRequest.
type OidcLoginRequest struct {
	// Client Client information representing the nature of front-end in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`].
	Client *ClientProfile `json:"client,omitempty"`

	// OsInfo OS information set in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`]
	OsInfo *OsInfo `json:"os_info,omitempty"`

	// Purpose A human readable description of the purpose of the session
	Purpose *string `json:"purpose"`

	// Scopes Controls what capabilities this session will have.
	Scopes []Scope        `json:"scopes"`
	Tokens *RatchetConfig `json:"tokens,omitempty"`
}

// OidcUserInfo defines model for OidcUserInfo.
type OidcUserInfo struct {
	// Email The email associated with the user
	Email *string `json:"email"`

	// PreferredUsername The user name (if any) associated with the user
	PreferredUsername *string `json:"preferred_username"`
}

// OperationKind All different kinds of sensitive operations
type OperationKind string

// OrgAlertsPrefs defines model for OrgAlertsPrefs.
type OrgAlertsPrefs struct {
	// AlertRecipients Recipient users for org-level alerts
	AlertRecipients *[]Id `json:"alert_recipients"`

	// SubscribedAlerts Org-level alerts to send emails for
	SubscribedAlerts *[]AlertKind `json:"subscribed_alerts"`
}

// OrgData defines model for OrgData.
type OrgData struct {
	// OrgId The id of the org
	OrgId string `json:"org_id"`

	// OrgName The human-readable name for the org
	OrgName *string `json:"org_name"`
}

// OrgEventDiscriminants Auto-generated discriminant enum variants
type OrgEventDiscriminants string

// OrgEventFilter Filter for org events
type OrgEventFilter struct {
	union json.RawMessage
}

// OrgEventFilterAll Do not filter any org events
type OrgEventFilterAll string

// OrgEventFilterAllExcept defines model for OrgEventFilterAllExcept.
type OrgEventFilterAllExcept struct {
	// AllExcept Accepts all org events other than the ones listed
	AllExcept []OrgEventDiscriminants `json:"AllExcept"`
}

// OrgEventFilterOneOf defines model for OrgEventFilterOneOf.
type OrgEventFilterOneOf struct {
	// OneOf Only accepts org events that are one of the listed events
	OneOf []OrgEventDiscriminants `json:"OneOf"`
}

// OrgExportResponse An org-export ciphertext retrieved via the org-export API.
type OrgExportResponse struct {
	// Ciphertext A base64-encoded export ciphertext.
	Ciphertext string `json:"ciphertext"`
}

// OrgInfo defines model for OrgInfo.
type OrgInfo struct {
	// DefaultInviteKind Indicates the auth sources allowed to an invited user
	DefaultInviteKind *InviteKind `json:"default_invite_kind,omitempty"`

	// EmailPreferences Describes email preferences at an Org level - what emails to send and options associated
	EmailPreferences *EmailPreferences `json:"email_preferences,omitempty"`

	// Enabled When false, all cryptographic operations involving keys in this org are disabled.
	Enabled bool `json:"enabled"`

	// HistoricalDataConfiguration Configuration governing whether and how to save historical data.
	HistoricalDataConfiguration *HistoricalDataConfiguration `json:"historical_data_configuration,omitempty"`

	// IdpConfiguration IDP configuration
	IdpConfiguration *IdpConfig `json:"idp_configuration,omitempty"`

	// KeyImportKey Deprecated: this field should be ignored.
	KeyImportKey *string `json:"key_import_key"`

	// KwkId The organization's universally unique key-wrapping-key identifier.
	// This value is required when setting up key export.
	KwkId string `json:"kwk_id"`

	// LastUnstake Date/time (in UTC) when last 'unstake' was performed. Unix epoch if none.
	LastUnstake string `json:"last_unstake"`

	// LastUnstakeDayCount How many 'unstake' calls happened on the day when `last_unstake` was performed.
	LastUnstakeDayCount int32 `json:"last_unstake_day_count"`

	// MetricsEnabled Whether metrics are collected for this org
	MetricsEnabled *bool `json:"metrics_enabled,omitempty"`

	// Name The human-readable name for the org
	Name *string `json:"name"`

	// NotificationEndpoints The organization's notification endpoints, which are HTTPS URLs are notified about a
	// configurable set of events in an organization. For each event, CubeSigner sends a POST
	// request with a JSON-formatted body that contains the event details.
	NotificationEndpoints *[]NotificationEndpoint `json:"notification_endpoints,omitempty"`

	// OrgId The ID of the organization
	OrgId string `json:"org_id"`

	// Policy Org-wide policies that are checked before a key is used for signing
	Policy *[]map[string]interface{} `json:"policy,omitempty"`

	// PolicyEngineConfiguration A struct containing Org-level configurations for the workings of the Policy Engine.
	PolicyEngineConfiguration *PolicyEngineConfiguration `json:"policy_engine_configuration,omitempty"`

	// TotpFailureLimit The organization's currently configured TOTP failure limit, i.e., the number
	// of times a user can provide an incorrect TOTP code before being rate limited.
	// This value can be between 1 and 5 (inclusive).
	TotpFailureLimit int32 `json:"totp_failure_limit"`

	// UserExportDelay The organization's currently configured user-export delay, i.e., the minimum
	// amount of time (in seconds) between when a user-export is initiated and when
	// it may be completed. (This value is meaningless for organizations that use
	// org-wide export.)
	UserExportDelay int64 `json:"user_export_delay"`

	// UserExportDisabled Whether user export is disabled
	UserExportDisabled *bool `json:"user_export_disabled,omitempty"`

	// UserExportWindow The organization's currently configured user-export window, i.e., the amount
	// of time (in seconds) between when the user-export delay is completed and when
	// the user export request has expired and can no longer be completed. (This value
	// is meaningless for organizations that use org-wide export.)
	UserExportWindow int64 `json:"user_export_window"`

	// WebappEnabled If set, the official webapp origin is automatically allowed
	WebappEnabled *bool `json:"webapp_enabled,omitempty"`
}

// OrgMetric Supported org metrics.
type OrgMetric struct {
	union json.RawMessage
}

// OrgMetricBillingEvent defines model for OrgMetricBillingEvent.
type OrgMetricBillingEvent struct {
	BillingEvent BillingDimensions `json:"BillingEvent"`
}

// OrgMetricData defines model for OrgMetricData.
type OrgMetricData struct {
	// Data The data points, one for each time period (time periods for which the value is 0 are omitted).
	Data map[string]float64 `json:"data"`

	// Dimensions The metric dimensions.
	Dimensions map[string]string `json:"dimensions"`
}

// OrgMetricDiscriminants Auto-generated discriminant enum variants
type OrgMetricDiscriminants string

// OrgMetricKeyCount defines model for OrgMetricKeyCount.
type OrgMetricKeyCount struct {
	KeyCount KeyCountDimensions `json:"KeyCount"`
}

// OrgMetricOidcLoginEvent defines model for OrgMetricOidcLoginEvent.
type OrgMetricOidcLoginEvent struct {
	OidcLoginEvent OidcLoginDimensions `json:"OidcLoginEvent"`
}

// OrgMetricSignEvent defines model for OrgMetricSignEvent.
type OrgMetricSignEvent struct {
	SignEvent SignDimensions `json:"SignEvent"`
}

// OrgMetricStat Available statistics to compute
type OrgMetricStat string

// OrgMetricUserCount defines model for OrgMetricUserCount.
type OrgMetricUserCount struct {
	UserCount UserCountDimensions `json:"UserCount"`
}

// OsInfo OS information set in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`]
type OsInfo struct {
	Architecture *string `json:"architecture"`
	Name         *string `json:"name"`
	Version      *string `json:"version"`
	WordSize     *string `json:"word_size"`
}

// OtherScopes Scopes including wildcard fragments for accessing CubeSigner APIs
type OtherScopes = string

// Page The rocket query parameter representing the page from which to start a paginated query.
//
// MUST be named `<page>` in rocket url spec so that 'serde(rename = "page.*")' below continues to work
type Page struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `json:"page.start"`
}

// PaginatedGetUsersInOrgResponse defines model for PaginatedGetUsersInOrgResponse.
type PaginatedGetUsersInOrgResponse struct {
	// LastEvaluatedKey If set, the content of `response` does not contain the entire result set.
	// To fetch the next page of the result set, call the same endpoint
	// but specify this value as the 'page.start' query parameter.
	LastEvaluatedKey *string `json:"last_evaluated_key"`

	// Users The list of users in the org
	Users []UserInOrgInfo `json:"users"`
}

// PaginatedListContactsResponse defines model for PaginatedListContactsResponse.
type PaginatedListContactsResponse struct {
	// Contacts All contacts in an organization.
	Contacts []ContactInfo `json:"contacts"`

	// LastEvaluatedKey If set, the content of `response` does not contain the entire result set.
	// To fetch the next page of the result set, call the same endpoint
	// but specify this value as the 'page.start' query parameter.
	LastEvaluatedKey *string `json:"last_evaluated_key"`
}

// PaginatedListHistoricalTxResponse defines model for PaginatedListHistoricalTxResponse.
type PaginatedListHistoricalTxResponse struct {
	// LastEvaluatedKey If set, the content of `response` does not contain the entire result set.
	// To fetch the next page of the result set, call the same endpoint
	// but specify this value as the 'page.start' query parameter.
	LastEvaluatedKey *string `json:"last_evaluated_key"`

	// Txs Historical transactions signed with the requested key, sorted from most to least recent.
	Txs []HistoricalTx `json:"txs"`
}

// PaginatedListKeyRolesResponse defines model for PaginatedListKeyRolesResponse.
type PaginatedListKeyRolesResponse struct {
	// LastEvaluatedKey If set, the content of `response` does not contain the entire result set.
	// To fetch the next page of the result set, call the same endpoint
	// but specify this value as the 'page.start' query parameter.
	LastEvaluatedKey *string `json:"last_evaluated_key"`

	// Roles All roles the key is in
	Roles []KeyInRoleInfo `json:"roles"`
}

// PaginatedListKeysResponse defines model for PaginatedListKeysResponse.
type PaginatedListKeysResponse struct {
	Keys []KeyInfo `json:"keys"`

	// LastEvaluatedKey If set, the content of `response` does not contain the entire result set.
	// To fetch the next page of the result set, call the same endpoint
	// but specify this value as the 'page.start' query parameter.
	LastEvaluatedKey *string `json:"last_evaluated_key"`
}

// PaginatedListPoliciesResponse defines model for PaginatedListPoliciesResponse.
type PaginatedListPoliciesResponse struct {
	// LastEvaluatedKey If set, the content of `response` does not contain the entire result set.
	// To fetch the next page of the result set, call the same endpoint
	// but specify this value as the 'page.start' query parameter.
	LastEvaluatedKey *string `json:"last_evaluated_key"`

	// Policies The Org's named policies.
	Policies []PolicyInfo `json:"policies"`
}

// PaginatedListRoleKeysResponse defines model for PaginatedListRoleKeysResponse.
type PaginatedListRoleKeysResponse struct {
	// Keys All keys in a role
	Keys []KeyInRoleInfo `json:"keys"`

	// LastEvaluatedKey If set, the content of `response` does not contain the entire result set.
	// To fetch the next page of the result set, call the same endpoint
	// but specify this value as the 'page.start' query parameter.
	LastEvaluatedKey *string `json:"last_evaluated_key"`
}

// PaginatedListRoleUsersResponse defines model for PaginatedListRoleUsersResponse.
type PaginatedListRoleUsersResponse struct {
	// LastEvaluatedKey If set, the content of `response` does not contain the entire result set.
	// To fetch the next page of the result set, call the same endpoint
	// but specify this value as the 'page.start' query parameter.
	LastEvaluatedKey *string `json:"last_evaluated_key"`

	// Users All users in a role
	Users []UserInRoleInfo `json:"users"`
}

// PaginatedListRolesResponse defines model for PaginatedListRolesResponse.
type PaginatedListRolesResponse struct {
	// LastEvaluatedKey If set, the content of `response` does not contain the entire result set.
	// To fetch the next page of the result set, call the same endpoint
	// but specify this value as the 'page.start' query parameter.
	LastEvaluatedKey *string `json:"last_evaluated_key"`

	// Roles All roles in an organization.
	Roles []RoleInfo `json:"roles"`
}

// PaginatedPolicyLogsResponse defines model for PaginatedPolicyLogsResponse.
type PaginatedPolicyLogsResponse struct {
	// LastEvaluatedKey If set, the content of `response` does not contain the entire result set.
	// To fetch the next page of the result set, call the same endpoint
	// but specify this value as the 'page.start' query parameter.
	LastEvaluatedKey *string `json:"last_evaluated_key"`

	// Logs The policy execution logs
	Logs []map[string]string `json:"logs"`
}

// PaginatedQueryMetricsResponse defines model for PaginatedQueryMetricsResponse.
type PaginatedQueryMetricsResponse struct {
	// LastEvaluatedKey If set, the content of `response` does not contain the entire result set.
	// To fetch the next page of the result set, call the same endpoint
	// but specify this value as the 'page.start' query parameter.
	LastEvaluatedKey *string `json:"last_evaluated_key"`

	// Messages Advisory messages (e.g., if max number of results is reached).
	Messages *[]string `json:"messages,omitempty"`

	// Period The period for which the statistic is computed, if any (not all metrics support splitting the requested time range into bins).
	// If set, equals to the value from the request rounded up to the closest multiple of 60.
	Period *int64 `json:"period,omitempty"`

	// RawData Some metrics can optionally return the raw data, when requested.
	RawData []map[string]string `json:"raw_data"`

	// Results Computed data points.
	Results []struct {
		// Data The data points, one for each time period (time periods for which the value is 0 are omitted).
		Data map[string]float64 `json:"data"`

		// Dimensions The metric dimensions.
		Dimensions map[string]string `json:"dimensions"`
	} `json:"results"`
	Stat *OrgMetricStat `json:"stat"`
}

// PaginatedSessionsResponse defines model for PaginatedSessionsResponse.
type PaginatedSessionsResponse struct {
	// LastEvaluatedKey If set, the content of `response` does not contain the entire result set.
	// To fetch the next page of the result set, call the same endpoint
	// but specify this value as the 'page.start' query parameter.
	LastEvaluatedKey *string `json:"last_evaluated_key"`

	// Sessions The list of sessions
	Sessions []SessionInfo `json:"sessions"`
}

// PaginatedUserExportListResponse defines model for PaginatedUserExportListResponse.
type PaginatedUserExportListResponse struct {
	ExportRequests []UserExportInitResponse `json:"export_requests"`

	// LastEvaluatedKey If set, the content of `response` does not contain the entire result set.
	// To fetch the next page of the result set, call the same endpoint
	// but specify this value as the 'page.start' query parameter.
	LastEvaluatedKey *string `json:"last_evaluated_key"`
}

// PasskeyAssertAnswer Sent from the client to the server to answer a fido challenge
type PasskeyAssertAnswer struct {
	// ChallengeId The ID of the challenge that was returned from the POST endpoint
	ChallengeId string `json:"challenge_id"`

	// Credential This type represents a wire-encodable form of the PublicKeyCredential interface
	// Clients may need to manually encode into this format to communicate with the server
	//
	// The PublicKeyCredential interface inherits from Credential
	// [CREDENTIAL-MANAGEMENT-1], and contains the attributes that are returned to
	// the caller when a new credential is created, or a new assertion is
	// requested.
	//
	// https://www.w3.org/TR/webauthn-2/#iface-pkcredential
	Credential PublicKeyCredential `json:"credential"`
}

// PasskeyAssertChallenge defines model for PasskeyAssertChallenge.
type PasskeyAssertChallenge struct {
	// ChallengeId The id of the challenge. Must be supplied when answering the challenge.
	ChallengeId string `json:"challenge_id"`

	// Options The `PublicKeyCredentialRequestOptions` dictionary supplies get() with the
	// data it needs to generate an assertion. Its challenge member MUST be
	// present, while its other members are OPTIONAL.
	//
	// This struct is also used as part of the verification procedure for assertions
	Options PublicKeyCredentialRequestOptions `json:"options"`

	// Preimage A base64url encoding of UTF8 JSON. The data in that JSON is endpoint specific, and describes what this FIDO challenge will be used for.
	//
	// Clients can use `preimage` along with `random_seed` to reconstruct the challenge like so:
	//
	// `challenge = HMAC-SHA256(key=random_seed, message=preimage)`
	Preimage string `json:"preimage"`

	// RandomSeed A random seed that prevents replay attacks
	RandomSeed string `json:"random_seed"`
}

// PasskeyConfig Org-level passkey configuration
type PasskeyConfig struct {
	// Users Enable passkey login for certain user roles (disabled for everyone by default)
	Users *[]MemberRole `json:"users,omitempty"`
}

// PasswordResetConfirmRequest defines model for PasswordResetConfirmRequest.
type PasswordResetConfirmRequest struct {
	// NewPassword The new password to set.
	NewPassword string `json:"new_password"`

	// Token Invitation token, constructed by concatenating the "partial token"
	// (i.e., `{header}.{payload}.`) returned by the `idp_password_reset_request` endpoint
	// and the signature sent to the user's email.
	Token string `json:"token"`
}

// PasswordResetRequest The request body for the idp password reset endpoint
type PasswordResetRequest struct {
	// Email The email address of the user requesting to reset their password
	Email string `json:"email"`
}

// PendingMessageInfo defines model for PendingMessageInfo.
type PendingMessageInfo struct {
	// ExpiresAt DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	ExpiresAt EpochDateTime `json:"expires_at"`

	// Id The ID of the pending message
	Id string `json:"id"`

	// Identity The identity (a user or a role id) which created this message.
	Identity      string `json:"identity"`
	MessageEip191 *struct {
		// Address From address, hex-encoded, with leading '0x'
		Address string `json:"address"`

		// Message Hex-encoded (including a '0x' prefix) message to sign.
		Message string `json:"message"`
	} `json:"message_eip191"`
	MessageEip712 *struct {
		// Address From address, hex-encoded, with leading '0x'
		Address string `json:"address"`

		// Data Represents the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) typed data object.
		//
		// Typed data is a JSON object containing type information, domain separator parameters and the
		// message object.
		Data    TypedData                              `json:"data"`
		Version PendingMessageInfoMessageEip712Version `json:"version"`
	} `json:"message_eip712"`
	MessageTx     *TypedTransaction     `json:"message_tx"`
	Metadata      MmiMetadata           `json:"metadata"`
	SignedMessage *SignedMessage        `json:"signedMessage"`
	Transaction   *TransactionAndStatus `json:"transaction"`
}

// PendingMessageInfoMessageEip712Version defines model for PendingMessageInfo.MessageEip712.Version.
type PendingMessageInfoMessageEip712Version string

// PendingMessageSignResponse defines model for PendingMessageSignResponse.
type PendingMessageSignResponse struct {
	// ExpiresAt DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	ExpiresAt EpochDateTime `json:"expires_at"`

	// Id The ID of the pending message
	Id string `json:"id"`

	// Identity The identity (a user or a role id) which created this message.
	Identity      string `json:"identity"`
	MessageEip191 *struct {
		// Address From address, hex-encoded, with leading '0x'
		Address string `json:"address"`

		// Message Hex-encoded (including a '0x' prefix) message to sign.
		Message string `json:"message"`
	} `json:"message_eip191"`
	MessageEip712 *struct {
		// Address From address, hex-encoded, with leading '0x'
		Address string `json:"address"`

		// Data Represents the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) typed data object.
		//
		// Typed data is a JSON object containing type information, domain separator parameters and the
		// message object.
		Data    TypedData                                      `json:"data"`
		Version PendingMessageSignResponseMessageEip712Version `json:"version"`
	} `json:"message_eip712"`
	MessageTx     *TypedTransaction     `json:"message_tx"`
	Metadata      MmiMetadata           `json:"metadata"`
	SignedMessage *SignedMessage        `json:"signedMessage"`
	Transaction   *TransactionAndStatus `json:"transaction"`
}

// PendingMessageSignResponseMessageEip712Version defines model for PendingMessageSignResponse.MessageEip712.Version.
type PendingMessageSignResponseMessageEip712Version string

// PolicyAttachedToId The id for attaching a named policy to a key, role, or key in role.
type PolicyAttachedToId struct {
	union json.RawMessage
}

// PolicyAttachedToIdObject defines model for PolicyAttachedToIdObject.
type PolicyAttachedToIdObject struct {
	// KeyId The id of the key in the role the policy should be attached to.
	KeyId string `json:"key_id"`

	// RoleId The id of the role the key is in.
	RoleId string `json:"role_id"`
}

// PolicyAttachedToIdkeyId defines model for PolicyAttachedToIdkey_id.
type PolicyAttachedToIdkeyId struct {
	// KeyId The id of the key the policy should be attached to.
	KeyId string `json:"key_id"`
}

// PolicyAttachedToIdroleId defines model for PolicyAttachedToIdrole_id.
type PolicyAttachedToIdroleId struct {
	// RoleId The id of the role the policy should be attached to.
	RoleId string `json:"role_id"`
}

// PolicyEngineConfiguration A struct containing Org-level configurations for the workings of the Policy Engine.
type PolicyEngineConfiguration struct {
	// AllowedHttpAuthorities Allowed domains for HTTP requests
	AllowedHttpAuthorities []string `json:"allowed_http_authorities"`
}

// PolicyErrorCode defines model for PolicyErrorCode.
type PolicyErrorCode struct {
	union json.RawMessage
}

// PolicyErrorOwnCodes defines model for PolicyErrorOwnCodes.
type PolicyErrorOwnCodes string

// PolicyInfo A struct containing all the information about a specific version of a policy.
type PolicyInfo struct {
	// AttachedTo A list of entities (keys, roles, etc.) the policy is attached to.
	AttachedTo []PolicyAttachedToId `json:"attached_to"`

	// Created DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	Created EpochDateTime `json:"created"`

	// EditPolicy A policy which governs when and who is allowed to update the entity this policy is
	// attached to (e.g., a role or a key).
	//
	// When attached to a role, by default, this policy applies to role deletion and all
	// role updates (including adding/removing keys and users); in terms of scopes,
	// it applies to `manage:role:update:*` and `manage:role:delete`.
	//
	// When attached to a key, by default, this policy applies to key deletion, all
	// key updates, and adding/removing that key to/from a role; in terms of scopes,
	// it applies to `manage:key:update:*`, `manage:key:delete`, `manage:role:update:key:*`.
	//
	// This default can be changed by setting the `applies_to_scopes` property.
	EditPolicy *EditPolicy `json:"edit_policy,omitempty"`

	// Metadata User-defined metadata for the named policy.
	Metadata *interface{} `json:"metadata,omitempty"`

	// Name The name of the policy.
	Name  string `json:"name"`
	Owner Id     `json:"owner"`

	// PolicyId The policy id
	PolicyId string `json:"policy_id"`

	// PolicyType The type of a [NamedPolicy].
	//
	// The type of a policy is set at creation time, and is used to offer guarantees
	// about the current and all future versions of a [NamedPolicy].
	PolicyType PolicyType `json:"policy_type"`

	// Rules The policy rule.
	Rules []interface{} `json:"rules"`

	// Version The policy rule's version.
	Version int64 `json:"version"`
}

// PolicyLogsRequest A request for querying Wasm policy logs.
type PolicyLogsRequest struct {
	// EndTime End time in seconds since unix epoch. If omitted, defaults to 'now'.
	EndTime *int64 `json:"end_time"`

	// StartTime Start time in seconds since unix epoch. If omitted, defaults to 24 hours ago.
	StartTime *int64 `json:"start_time"`

	// Version The version of the policy to get the logs for.
	// If omitted, all policy logs are retrieved.
	Version *string `json:"version,omitempty"`
}

// PolicyResultResponse PolicyResultResponse is a wrapper on PolicyResult with two important
// properties:
// * derives OkToLogResponse, so that it can be used in the rocket handler.
// * derives ToSchema and ToResponse, with the `val` field with value_type
// Object, so that we don't have to provide all of the OpenAPI type
// descriptions of a PolicyResult.
//
// The PolicyResult includes enums and other standard types (e.g.
// std::time::Interval) which are nontrivial to represent in OpenAPI. Since
// this endpoint is just for testing, we don't really care about how accurate
// the schema is, and can lean on serde_json when decoding this response to a
// PolicyResult in a client. Note that there is a bug in utoipa where the
// value_type annotation will not work for a tuple-struct, only a struct with
// fields.
type PolicyResultResponse struct {
	Val map[string]interface{} `json:"val"`
}

// PolicySecretsInfo defines model for PolicySecretsInfo.
type PolicySecretsInfo struct {
	Created *EpochDateTime `json:"created"`

	// EditPolicy A policy which governs when and who is allowed to update the entity this policy is
	// attached to (e.g., a role or a key).
	//
	// When attached to a role, by default, this policy applies to role deletion and all
	// role updates (including adding/removing keys and users); in terms of scopes,
	// it applies to `manage:role:update:*` and `manage:role:delete`.
	//
	// When attached to a key, by default, this policy applies to key deletion, all
	// key updates, and adding/removing that key to/from a role; in terms of scopes,
	// it applies to `manage:key:update:*`, `manage:key:delete`, `manage:role:update:key:*`.
	//
	// This default can be changed by setting the `applies_to_scopes` property.
	EditPolicy   *EditPolicy    `json:"edit_policy,omitempty"`
	LastModified *EpochDateTime `json:"last_modified"`

	// Metadata User-defined metadata. When rendering (e.g., in the browser) you should treat
	// it as untrusted user data (and avoid injecting metadata into HTML directly) if
	// untrusted users can create/update keys (or their metadata).
	Metadata *interface{} `json:"metadata,omitempty"`

	// Names The names of the secrets.,
	Names []string `json:"names"`

	// Version Version of this object
	Version *int64 `json:"version,omitempty"`
}

// PolicyType The type of a [NamedPolicy].
//
// The type of a policy is set at creation time, and is used to offer guarantees
// about the current and all future versions of a [NamedPolicy].
type PolicyType string

// PreconditionErrorCode defines model for PreconditionErrorCode.
type PreconditionErrorCode struct {
	union json.RawMessage
}

// PreconditionErrorOwnCodes defines model for PreconditionErrorOwnCodes.
type PreconditionErrorOwnCodes string

// PrevOutputs Contains outputs of previous transactions.
type PrevOutputs struct {
	union json.RawMessage
}

// PrevOutputsAll defines model for PrevOutputsAll.
type PrevOutputsAll struct {
	// All When `SIGHASH_ANYONECANPAY` is not provided, or when the caller is giving all
	// previous outputs so the same variable can be used for multiple inputs.
	All []BtcTxOut `json:"All"`
}

// PrevOutputsOne defines model for PrevOutputsOne.
type PrevOutputsOne struct {
	// One `One` variant allows provision of the single previous output needed. It's useful,
	// for example, when modifier `SIGHASH_ANYONECANPAY` is provided, only previous output
	// of the current input is needed. The first `index` argument is the input index
	// this output is referring to.
	One struct {
		Index int      `json:"index"`
		TxOut BtcTxOut `json:"tx_out"`
	} `json:"One"`
}

// PsbtSignRequest defines model for PsbtSignRequest.
type PsbtSignRequest struct {
	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata *interface{} `json:"metadata"`

	// Psbt A hex-serialized PSBT (version 0), with or without leading 0x prefix.
	// This PSBT must contain the transaction inputs and outputs, plus all
	// information needed to sign (e.g., taproot path and leaf information).
	Psbt string `json:"psbt"`

	// SignAllScripts When true, unconditionally sign every input to the PSBT controlled by a script
	// spend. Otherwise (false, the default), this endpoint uses a heuristic to decide
	// whether the script controlling a given UTXO requires a signature from this key.
	SignAllScripts *bool `json:"sign_all_scripts,omitempty"`
}

// PsbtSignResponse Response to a PSBT signing request
type PsbtSignResponse struct {
	// Psbt The PSBT in standard hex serialization, without leading "0x".
	Psbt string `json:"psbt"`
}

// PublicKeyCredential This type represents a wire-encodable form of the PublicKeyCredential interface
// Clients may need to manually encode into this format to communicate with the server
//
// The PublicKeyCredential interface inherits from Credential
// [CREDENTIAL-MANAGEMENT-1], and contains the attributes that are returned to
// the caller when a new credential is created, or a new assertion is
// requested.
//
// https://www.w3.org/TR/webauthn-2/#iface-pkcredential
type PublicKeyCredential struct {
	// ClientExtensionResults This internal slot contains the results of processing client extensions
	// requested by the Relying Party upon the Relying Party's invocation of
	// either navigator.credentials.create() or navigator.credentials.get().
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredential-clientextensionsresults-slot
	//
	// IMPLEMENTATION NOTE: The type for this field comes from the type of getClientExtensionResults() which as the following doc:
	//
	// This operation returns the value of [[clientExtensionsResults]], which is a map containing extension identifier → client extension output entries produced by the extension’s client extension processing.
	// https://www.w3.org/TR/webauthn-2/#ref-for-dom-publickeycredential-getclientextensionresults
	ClientExtensionResults *map[string]interface{} `json:"clientExtensionResults"`

	// Id This internal slot contains the credential ID, chosen by the
	// authenticator. The credential ID is used to look up credentials for use,
	// and is therefore expected to be globally unique with high probability
	// across all credentials of the same type, across all authenticators.
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredential-identifier-slot
	Id string `json:"id"`

	// Response Authenticators respond to Relying Party requests by returning an object derived from the AuthenticatorResponse interface
	Response PublicKeyCredential_Response `json:"response"`
}

// PublicKeyCredential_Response Authenticators respond to Relying Party requests by returning an object derived from the AuthenticatorResponse interface
type PublicKeyCredential_Response struct {
	union json.RawMessage
}

// PublicKeyCredentialCreationOptions Defines the parameters for the creation of a new public key credential
//
// https://www.w3.org/TR/webauthn-2/#dictdef-publickeycredentialcreationoptions
type PublicKeyCredentialCreationOptions struct {
	// Attestation WebAuthn Relying Parties may use AttestationConveyancePreference to specify
	// their preference regarding attestation conveyance during credential
	// generation.
	//
	// https://www.w3.org/TR/webauthn-2/#enumdef-attestationconveyancepreference
	Attestation            *AttestationConveyancePreference `json:"attestation,omitempty"`
	AuthenticatorSelection *AuthenticatorSelectionCriteria  `json:"authenticatorSelection"`

	// Challenge This member contains a challenge intended to be used for generating the
	// newly created credential’s attestation object. See the § 13.4.3
	// Cryptographic Challenges security consideration.
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialcreationoptions-challenge
	Challenge string `json:"challenge"`

	// ExcludeCredentials This member is intended for use by Relying Parties that wish to limit
	// the creation of multiple credentials for the same account on a single
	// authenticator. The client is requested to return an error if the new
	// credential would be created on an authenticator that also contains one
	// of the credentials enumerated in this parameter.
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialcreationoptions-excludecredentials
	ExcludeCredentials *[]PublicKeyCredentialDescriptor `json:"excludeCredentials,omitempty"`

	// Extensions This member contains additional parameters requesting additional
	// processing by the client and authenticator. For example, the caller may
	// request that only authenticators with certain capabilities be used to
	// create the credential, or that particular information be returned in the
	// attestation object. Some extensions are defined in § 9 WebAuthn
	// Extensions; consult the IANA "WebAuthn Extension Identifiers" registry
	// [IANA-WebAuthn-Registries] established by [RFC8809] for an up-to-date
	// list of registered WebAuthn Extensions.
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialcreationoptions-extensions
	Extensions *map[string]interface{} `json:"extensions"`

	// PubKeyCredParams This member contains information about the desired properties of the
	// credential to be created. The sequence is ordered from most preferred to
	// least preferred. The client makes a best-effort to create the most
	// preferred credential that it can.
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialcreationoptions-pubkeycredparams
	PubKeyCredParams []PublicKeyCredentialParameters `json:"pubKeyCredParams"`

	// Rp The PublicKeyCredentialRpEntity dictionary is used to supply additional
	// Relying Party attributes when creating a new credential.
	//
	// https://www.w3.org/TR/webauthn-2/#dictionary-rp-credential-params
	Rp PublicKeyCredentialRpEntity `json:"rp"`

	// Timeout This member specifies a time, in milliseconds, that the caller is
	// willing to wait for the call to complete. This is treated as a hint, and
	// MAY be overridden by the client.
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialcreationoptions-timeout
	Timeout *int32 `json:"timeout"`

	// User The PublicKeyCredentialUserEntity dictionary is used to supply additional
	// user account attributes when creating a new credential.
	User PublicKeyCredentialUserEntity `json:"user"`
}

// PublicKeyCredentialDescriptor This dictionary contains the attributes that are specified by a caller when
// referring to a public key credential as an input parameter to the create()
// or get() methods. It mirrors the fields of the PublicKeyCredential object
// returned by the latter methods.
//
// https://www.w3.org/TR/webauthn-2/#dictionary-credential-descriptor
type PublicKeyCredentialDescriptor struct {
	// Id This member contains the credential ID of the public key credential the caller is referring to.
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialdescriptor-id
	Id string `json:"id"`

	// Transports This OPTIONAL member contains a hint as to how the client might
	// communicate with the managing authenticator of the public key credential
	// the caller is referring to. The values SHOULD be members of
	// AuthenticatorTransport but client platforms MUST ignore unknown values.
	//
	// The getTransports() operation can provide suitable values for this
	// member. When registering a new credential, the Relying Party SHOULD
	// store the value returned from getTransports(). When creating a
	// PublicKeyCredentialDescriptor for that credential, the Relying Party
	// SHOULD retrieve that stored value and set it as the value of the
	// transports member.
	Transports *[]AuthenticatorTransport `json:"transports"`

	// Type This enumeration defines the valid credential types. It is an extension
	// point; values can be added to it in the future, as more credential types are
	// defined. The values of this enumeration are used for versioning the
	// Authentication Assertion and attestation structures according to the type of
	// the authenticator. Currently one credential type is defined, namely
	// "public-key".
	//
	// https://www.w3.org/TR/webauthn-2/#enumdef-publickeycredentialtype
	Type PublicKeyCredentialType `json:"type"`
}

// PublicKeyCredentialParameters This dictionary is used to supply additional parameters when creating a new
// credential.
//
// https://www.w3.org/TR/webauthn-2/#dictionary-credential-params
type PublicKeyCredentialParameters struct {
	// Alg This member specifies the cryptographic signature algorithm with which
	// the newly generated credential will be used, and thus also the type of
	// asymmetric key pair to be generated, e.g., RSA or Elliptic Curve.
	Alg int64 `json:"alg"`

	// Type This enumeration defines the valid credential types. It is an extension
	// point; values can be added to it in the future, as more credential types are
	// defined. The values of this enumeration are used for versioning the
	// Authentication Assertion and attestation structures according to the type of
	// the authenticator. Currently one credential type is defined, namely
	// "public-key".
	//
	// https://www.w3.org/TR/webauthn-2/#enumdef-publickeycredentialtype
	Type PublicKeyCredentialType `json:"type"`
}

// PublicKeyCredentialRequestOptions The `PublicKeyCredentialRequestOptions` dictionary supplies get() with the
// data it needs to generate an assertion. Its challenge member MUST be
// present, while its other members are OPTIONAL.
//
// This struct is also used as part of the verification procedure for assertions
type PublicKeyCredentialRequestOptions struct {
	// AllowCredentials This OPTIONAL member contains a list of PublicKeyCredentialDescriptor
	// objects representing public key credentials acceptable to the caller, in
	// descending order of the caller’s preference (the first item in the list
	// is the most preferred credential, and so on down the list).
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialrequestoptions-allowcredentials
	AllowCredentials *[]PublicKeyCredentialDescriptor `json:"allowCredentials,omitempty"`

	// Challenge This member represents a challenge that the selected authenticator
	// signs, along with other data, when producing an authentication
	// assertion.
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialrequestoptions-challenge
	Challenge  string                  `json:"challenge"`
	Extensions *map[string]interface{} `json:"extensions"`

	// RpId This OPTIONAL member specifies the relying party identifier claimed by
	// the caller. If omitted, its value will be the CredentialsContainer
	// object’s relevant settings object's origin's effective domain.
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialrequestoptions-rpid
	RpId *string `json:"rpId"`

	// Timeout This OPTIONAL member specifies a time, in milliseconds, that the caller
	// is willing to wait for the call to complete. The value is treated as a
	// hint, and MAY be overridden by the client.
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialrequestoptions-timeout
	Timeout *int32 `json:"timeout"`

	// UserVerification A WebAuthn Relying Party may require user verification for some of its
	// operations but not for others, and may use this type to express its needs.
	//
	// https://www.w3.org/TR/webauthn-2/#enum-userVerificationRequirement
	UserVerification *UserVerificationRequirement `json:"userVerification,omitempty"`
}

// PublicKeyCredentialRpEntity The PublicKeyCredentialRpEntity dictionary is used to supply additional
// Relying Party attributes when creating a new credential.
//
// https://www.w3.org/TR/webauthn-2/#dictionary-rp-credential-params
type PublicKeyCredentialRpEntity struct {
	// Id A unique identifier for the Relying Party entity, which sets the RP ID.
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialrpentity-id
	Id *string `json:"id"`

	// Name A human-palatable name for the entity. Its function depends on what the
	// PublicKeyCredentialEntity represents: When inherited by
	// PublicKeyCredentialRpEntity it is a human-palatable identifier for the
	// Relying Party, intended only for display. For example, "ACME
	// Corporation", "Wonderful Widgets, Inc." or "ОАО Примертех".
	//
	// Relying Parties SHOULD perform enforcement, as prescribed in Section 2.3
	// of [RFC8266] for the Nickname Profile of the PRECIS FreeformClass
	// [RFC8264], when setting name's value, or displaying the value to the
	// user.
	//
	// This string MAY contain language and direction metadata. Relying Parties
	// SHOULD consider providing this information. See § 6.4.2 Language and
	// Direction Encoding about how this metadata is encoded.
	Name string `json:"name"`
}

// PublicKeyCredentialType This enumeration defines the valid credential types. It is an extension
// point; values can be added to it in the future, as more credential types are
// defined. The values of this enumeration are used for versioning the
// Authentication Assertion and attestation structures according to the type of
// the authenticator. Currently one credential type is defined, namely
// "public-key".
//
// https://www.w3.org/TR/webauthn-2/#enumdef-publickeycredentialtype
type PublicKeyCredentialType string

// PublicKeyCredentialUserEntity The PublicKeyCredentialUserEntity dictionary is used to supply additional
// user account attributes when creating a new credential.
type PublicKeyCredentialUserEntity struct {
	// DisplayName A human-palatable name for the user account, intended only for display.
	// For example, "Alex Müller" or "田中倫". The Relying Party SHOULD let the
	// user choose this, and SHOULD NOT restrict the choice more than
	// necessary.
	//
	// Relying Parties SHOULD perform enforcement, as prescribed in Section 2.3
	// of [RFC8266] for the Nickname Profile of the PRECIS FreeformClass
	// [RFC8264], when setting displayName's value, or displaying the value to
	// the user.
	//
	// This string MAY contain language and direction metadata. Relying Parties
	// SHOULD consider providing this information. See § 6.4.2 Language and
	// Direction Encoding about how this metadata is encoded.
	//
	// Clients SHOULD perform enforcement, as prescribed in Section 2.3 of
	// [RFC8266] for the Nickname Profile of the PRECIS FreeformClass
	// [RFC8264], on displayName's value prior to displaying the value to the
	// user or including the value as a parameter of the
	// authenticatorMakeCredential operation.
	//
	// When clients, client platforms, or authenticators display a
	// displayName's value, they should always use UI elements to provide a
	// clear boundary around the displayed value, and not allow overflow into
	// other elements [css-overflow-3].
	//
	// Authenticators MUST accept and store a 64-byte minimum length for a
	// displayName member’s value. Authenticators MAY truncate a displayName
	// member’s value so that it fits within 64 bytes. See § 6.4.1 String
	// Truncation about truncation and other considerations.
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialuserentity-displayname
	DisplayName string `json:"displayName"`

	// Id The user handle of the user account entity. A user handle is an opaque
	// byte sequence with a maximum size of 64 bytes, and is not meant to be
	// displayed to the user.
	//
	// To ensure secure operation, authentication and authorization decisions
	// MUST be made on the basis of this id member, not the displayName nor
	// name members. See Section 6.1 of [RFC8266].
	//
	// The user handle MUST NOT contain personally identifying information
	// about the user, such as a username or e-mail address; see § 14.6.1 User
	// Handle Contents for details. The user handle MUST NOT be empty, though
	// it MAY be null.
	//
	// Note: the user handle ought not be a constant value across different
	// accounts, even for non-discoverable credentials, because some
	// authenticators always create discoverable credentials. Thus a constant
	// user handle would prevent a user from using such an authenticator with
	// more than one account at the Relying Party.
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialuserentity-id
	Id string `json:"id"`

	// Name When inherited by PublicKeyCredentialUserEntity, it is a human-palatable
	// identifier for a user account. It is intended only for display, i.e.,
	// aiding the user in determining the difference between user accounts with
	// similar displayNames. For example, "alexm", "alex.mueller@example.com"
	// or "+14255551234".
	//
	// The Relying Party MAY let the user choose this value. The Relying Party
	// SHOULD perform enforcement, as prescribed in Section 3.4.3 of [RFC8265]
	// for the UsernameCasePreserved Profile of the PRECIS IdentifierClass
	// [RFC8264], when setting name's value, or displaying the value to the
	// user.
	//
	// This string MAY contain language and direction metadata. Relying Parties
	// SHOULD consider providing this information. See § 6.4.2 Language and
	// Direction Encoding about how this metadata is encoded.
	//
	// Clients SHOULD perform enforcement, as prescribed in Section 3.4.3 of [RFC8265] for the UsernameCasePreserved Profile of the PRECIS IdentifierClass [RFC8264], on name's value prior to displaying the value to the user or including the value as a parameter of the authenticatorMakeCredential operation.
	Name string `json:"name"`
}

// PublicOrgInfo Public information about an organization.
type PublicOrgInfo struct {
	// OidcIssuers Explicitly configured (allowlisted) OpenID providers for an org
	OidcIssuers []struct {
		// Audiences Intended audiences (client IDs)
		Audiences []string `json:"audiences"`

		// Issuer Issuer URL
		Issuer string `json:"issuer"`

		// Nickname Optional issuer nickname
		Nickname *string `json:"nickname"`

		// Users The user roles allowed to use this IDP
		Users []MemberRole `json:"users"`
	} `json:"oidc_issuers"`

	// OrgId Org identifier
	OrgId string `json:"org_id"`

	// PasskeyLoginEnabled Whether logging in with just a passkey is allowed
	PasskeyLoginEnabled bool `json:"passkey_login_enabled"`
}

// Purpose defines model for Purpose.
type Purpose string

// QueryMetricsRequest defines model for QueryMetricsRequest.
type QueryMetricsRequest struct {
	// EndTime End time in seconds since unix epoch. If omitted, defaults to 'now'.
	EndTime *int64 `json:"end_time"`

	// MetricName The name of the metric to compute
	MetricName MetricName `json:"metric_name"`

	// Period The granularity, in seconds, of the returned data points.
	//
	// This value is automatically rounded up to a multiple of 3600 (i.e., 1 hour).
	// If omitted, defaults to the duration between `end_time` and `start_time`.
	// Must be no less than 1 hour (3600 seconds) for "event" metrics, and 1 day
	// (86400 seconds) for "count" metrics. Also, this period must not
	// divide the `end_time - start_time` period into more than 100 data points.
	Period *int64 `json:"period"`

	// RawData Return the raw data instead of computing the metric values
	// (not supported by all metrics).
	RawData *bool `json:"raw_data,omitempty"`

	// StartTime Start time in seconds since unix epoch.
	StartTime int64 `json:"start_time"`
}

// QueryMetricsResponse The metric data points.
type QueryMetricsResponse struct {
	// Messages Advisory messages (e.g., if max number of results is reached).
	Messages *[]string `json:"messages,omitempty"`

	// Period The period for which the statistic is computed, if any (not all metrics support splitting the requested time range into bins).
	// If set, equals to the value from the request rounded up to the closest multiple of 60.
	Period *int64 `json:"period,omitempty"`

	// RawData Some metrics can optionally return the raw data, when requested.
	RawData []map[string]string `json:"raw_data"`

	// Results Computed data points.
	Results []struct {
		// Data The data points, one for each time period (time periods for which the value is 0 are omitted).
		Data map[string]float64 `json:"data"`

		// Dimensions The metric dimensions.
		Dimensions map[string]string `json:"dimensions"`
	} `json:"results"`
	Stat *OrgMetricStat `json:"stat"`
}

// RatchetConfig defines model for RatchetConfig.
type RatchetConfig struct {
	// AuthLifetime The lifetime (in seconds) of auth tokens for this session.
	// Auth tokens can be refreshed (renewed) using a valid (unexpired)
	// refresh token, but not beyond the session lifetime.
	AuthLifetime *int64 `json:"auth_lifetime,omitempty"`

	// GraceLifetime The amount of time (in seconds) that an auth token for this session remains
	// valid after it has been refreshed and a new auth token has been issued. This
	// helps to address concurrency hazards, for example, if one thread makes requests
	// with auth token while another refreshes it.
	GraceLifetime *int64 `json:"grace_lifetime,omitempty"`

	// RefreshLifetime The lifetime (in seconds) of refresh tokens for this session.
	// If this value is shorter than the session lifetime, inactive sessions
	// will become invalid once the auth and refresh tokens have both expired.
	RefreshLifetime *int64 `json:"refresh_lifetime,omitempty"`

	// SessionLifetime The lifetime (in seconds) of the session.
	// The session cannot be extended beyond its original lifetime.
	SessionLifetime *int64 `json:"session_lifetime,omitempty"`
}

// Receipt Receipt that an MFA request was approved.
type Receipt struct {
	// Confirmation Confirmation code the user needs to present when resuming the original request.
	Confirmation string `json:"confirmation"`

	// FinalApprover The ID of the logged-in user whose action created this approval.
	FinalApprover string `json:"final_approver"`

	// Timestamp DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	Timestamp EpochDateTime `json:"timestamp"`
}

// RefreshGrantType defines model for RefreshGrantType.
type RefreshGrantType string

// Request JSON-RPC request object
type Request struct {
	// Id Request ID
	Id *interface{} `json:"id"`

	// Jsonrpc JSON-RPC version.
	Jsonrpc string `json:"jsonrpc"`

	// Method Name of the method to be invoked.
	Method string `json:"method"`

	// Params Parameter values of the request.
	Params *interface{} `json:"params"`
}

// RequestOptionsWithHash defines model for RequestOptionsWithHash.
type RequestOptionsWithHash struct {
	// Options The `PublicKeyCredentialRequestOptions` dictionary supplies get() with the
	// data it needs to generate an assertion. Its challenge member MUST be
	// present, while its other members are OPTIONAL.
	//
	// This struct is also used as part of the verification procedure for assertions
	Options PublicKeyCredentialRequestOptions `json:"options"`

	// Preimage A base64url encoding of UTF8 JSON. The data in that JSON is endpoint specific, and describes what this FIDO challenge will be used for.
	//
	// Clients can use `preimage` along with `random_seed` to reconstruct the challenge like so:
	//
	// `challenge = HMAC-SHA256(key=random_seed, message=preimage)`
	Preimage string `json:"preimage"`

	// RandomSeed A random seed that prevents replay attacks
	RandomSeed string `json:"random_seed"`
}

// ResidentKeyRequirement This enumeration’s values describe the Relying Party's requirements for
// client-side discoverable credentials (formerly known as resident credentials
// or resident keys):
//
// https://www.w3.org/TR/webauthn-2/#enumdef-residentkeyrequirement
type ResidentKeyRequirement string

// Response JSON-RPC response object
type Response struct {
	Error *ErrorObj `json:"error"`

	// Id ID from the corresponding request
	Id *interface{} `json:"id"`

	// Jsonrpc Constant "2.0"
	Jsonrpc string `json:"jsonrpc"`

	// Result Result, if success
	Result *map[string]interface{} `json:"result"`
}

// RestrictedActionsMap A map of actions to sets of membership roles
type RestrictedActionsMap map[string][]MemberRole

// RoleAction List of role actions that can be restricted to a set of member roles
type RoleAction string

// RoleInfo defines model for RoleInfo.
type RoleInfo struct {
	Created *EpochDateTime `json:"created"`

	// EditPolicy A policy which governs when and who is allowed to update the entity this policy is
	// attached to (e.g., a role or a key).
	//
	// When attached to a role, by default, this policy applies to role deletion and all
	// role updates (including adding/removing keys and users); in terms of scopes,
	// it applies to `manage:role:update:*` and `manage:role:delete`.
	//
	// When attached to a key, by default, this policy applies to key deletion, all
	// key updates, and adding/removing that key to/from a role; in terms of scopes,
	// it applies to `manage:key:update:*`, `manage:key:delete`, `manage:role:update:key:*`.
	//
	// This default can be changed by setting the `applies_to_scopes` property.
	EditPolicy *EditPolicy `json:"edit_policy,omitempty"`

	// Enabled Whether the role is enabled
	Enabled bool `json:"enabled"`

	// Keys Deprecated The CubeSigner IDs of at most 100 keys associated with this role
	Keys         *[]KeyInRoleInfo `json:"keys"`
	LastModified *EpochDateTime   `json:"last_modified"`

	// Metadata User-defined metadata. When rendering (e.g., in the browser) you should treat
	// it as untrusted user data (and avoid injecting metadata into HTML directly) if
	// untrusted users can create/update keys (or their metadata).
	Metadata *interface{} `json:"metadata,omitempty"`

	// Name The human-readable name for the role (must be alphanumeric)
	Name *string `json:"name"`

	// Policy Policy that is checked whenever a key is accessed for signing via this role.
	Policy *[]map[string]interface{} `json:"policy,omitempty"`

	// RestrictedActions A map of actions to sets of membership roles
	RestrictedActions RestrictedActionsMap `json:"restricted_actions"`

	// RoleId The ID of the role
	RoleId string `json:"role_id"`

	// Users Deprecated. The list of at most 100 users with access to the role.
	Users *[]string `json:"users"`

	// Version Version of this object
	Version *int64 `json:"version,omitempty"`
}

// Scope All scopes for accessing CubeSigner APIs
type Scope string

type ScopeType struct {
	union json.RawMessage
}

// ScopeSet A set of scopes.
type ScopeSet struct {
	union json.RawMessage
}

// ScopeSetAll All scopes
type ScopeSetAll string

// ScopeSetAllExcept defines model for ScopeSetAllExcept.
type ScopeSetAllExcept struct {
	// AllExcept All scopes except these (including those transitively implied).
	AllExcept []Scope `json:"AllExcept"`
}

// ScopeSetAllOf defines model for ScopeSetAllOf.
type ScopeSetAllOf struct {
	// AllOf All of these scopes (including those transitively implied).
	AllOf []Scope `json:"AllOf"`
}

// SecondFactorRequirement Represents the number of MFA approvals required for a given operation
// (e.g. login). Can be used to produce a concrete policy for a given user
type SecondFactorRequirement string

// Seconds Duration measured in seconds
// A wrapper type for serialization that encodes a `Duration` as a `u64` representing the number of seconds.
type Seconds = int64

// SecretValue The value of a policy secret.
type SecretValue struct {
	union json.RawMessage
}

// SecretValueObject A secret value encrypted to this organization's Wasm policy.
// Each value is encrypted with its own ephemeral key.
type SecretValueObject struct {
	// ClientPublicKey The client's ephemeral public key used to derive a shared key.
	// This is a base64-encoded, SEC1-encoded P384 public key.
	ClientPublicKey string `json:"client_public_key"`

	// EncryptedValue The encrypted secret value.
	// This is a base64-encoded ciphertext.
	EncryptedValue string `json:"encrypted_value"`

	// Salt A salt value used to derive a shared key for AES-GCM.
	// This is a base64-encoded byte string.
	Salt string `json:"salt"`
}

// SecretValueString A secret value.
// Config values are encrypted in transit and at rest.
type SecretValueString = string

// SessionInfo defines model for SessionInfo.
type SessionInfo struct {
	// Client Client information representing the nature of front-end in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`].
	Client *ClientProfile `json:"client,omitempty"`

	// CreatedBy The id of the user who created the session.
	CreatedBy *string `json:"created_by,omitempty"`

	// Exp Expiration date (in seconds since unix epoch)
	Exp int64 `json:"exp"`

	// Os OS String for backwards compatibility, see os_info instead.
	Os *string `json:"os"`

	// OsInfo OS information set in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`]
	OsInfo *OsInfo `json:"os_info,omitempty"`

	// Purpose A human-readable description for the session
	Purpose string `json:"purpose"`

	// Scopes Lists user permission and access for the session
	Scopes *[]Scope `json:"scopes,omitempty"`

	// SessionId Session ID. Uniquely identifies the session, but cannot be used for auth.
	SessionId string    `json:"session_id"`
	SourceIp  *SourceIp `json:"source_ip,omitempty"`

	// UserAgent User agent that created the session.
	UserAgent *string `json:"user_agent"`
}

// SessionMetadata Collection of attributes related to a Session.
// This is the backend variant of [`ClientSessionMetadata`] and works in tandem with its frontend counterpart.
type SessionMetadata struct {
	// Client Client information representing the nature of front-end in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`].
	Client *ClientProfile `json:"client,omitempty"`

	// CreatedBy The id of the user who created the session.
	CreatedBy *string `json:"created_by,omitempty"`

	// Os OS String for backwards compatibility, see os_info instead.
	Os *string `json:"os"`

	// OsInfo OS information set in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`]
	OsInfo   *OsInfo   `json:"os_info,omitempty"`
	SourceIp *SourceIp `json:"source_ip,omitempty"`

	// UserAgent User agent that created the session.
	UserAgent *string `json:"user_agent"`
}

// SessionsResponse The response from any operation operating on multiple sessions
type SessionsResponse struct {
	// Sessions The list of sessions
	Sessions []SessionInfo `json:"sessions"`
}

// SetPolicySecretRequest A request for setting an Org-level policy secret
type SetPolicySecretRequest struct {
	ImportKey *KeyImportKey `json:"import_key"`

	// Value The value of a policy secret.
	Value SecretValue `json:"value"`
}

// SignDimensions defines model for SignDimensions.
type SignDimensions struct {
	// Operation The sign operation
	Operation string `json:"operation"`

	// OrgId All metrics must include 'org_id' as a dimension.
	OrgId string `json:"org_id"`
}

// SignResponse defines model for SignResponse.
type SignResponse struct {
	// Signature The hex-encoded resulting signature.
	Signature string `json:"signature"`
}

// SignatureVersion defines model for SignatureVersion.
type SignatureVersion string

// SignedMessage defines model for SignedMessage.
type SignedMessage struct {
	// Address The address of the signer, with leading '0x'
	Address string `json:"address"`

	// Id The ID of the request record.
	Id string `json:"id"`

	// Signature The signature, hex encoded, with leading '0x'
	Signature        *string          `json:"signature"`
	SignatureVersion SignatureVersion `json:"signatureVersion"`
	Status           MmiStatus        `json:"status"`
}

// SignerErrorCode defines model for SignerErrorCode.
type SignerErrorCode struct {
	union json.RawMessage
}

// SignerErrorOwnCodes defines model for SignerErrorOwnCodes.
type SignerErrorOwnCodes string

// SolanaSignRequest defines model for SolanaSignRequest.
type SolanaSignRequest struct {
	// MessageBase64 Solana base64-encoded serialized Message
	MessageBase64 string `json:"message_base64"`

	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata *interface{} `json:"metadata"`
}

// SolanaTxCmp defines model for SolanaTxCmp.
type SolanaTxCmp struct {
	// IgnoreBlockhash Whether the 'recent_blockhash' property of the Solana transaction is allowed to be different.
	IgnoreBlockhash *bool `json:"ignore_blockhash,omitempty"`
}

// SourceIp defines model for SourceIp.
type SourceIp struct {
	SourceIp string `json:"source_ip"`
}

// StakeRequest defines model for StakeRequest.
type StakeRequest struct {
	// ChainId The chain on which we will deposit
	ChainId int64 `json:"chain_id"`

	// DepositType The type of deposit to perform
	DepositType DepositType `json:"deposit_type"`

	// StakingAmountGwei Optional staking amount in GWEI.
	// If not specified, defaults to 32_000_000_000 (32 ETH).
	// Must be between 1 ETH and 32 ETH.
	// Must not be different from the default value when 'deposit_type' is "Wrapper".
	StakingAmountGwei *int64      `json:"staking_amount_gwei,omitempty"`
	UnsafeConf        *UnsafeConf `json:"unsafe_conf"`

	// ValidatorKey The validator BLS public key to use, or `None` to generate a fresh one.
	ValidatorKey *string `json:"validator_key"`

	// WithdrawalAddr The ethereum address to which withdrawn funds go
	WithdrawalAddr string `json:"withdrawal_addr"`
}

// StakeResponse defines model for StakeResponse.
type StakeResponse struct {
	// CreatedValidatorKeyId The validator key id ("Key#...")
	CreatedValidatorKeyId string `json:"created_validator_key_id"`

	// DepositTx Information produced by a successful deposit
	DepositTx DepositTxn `json:"deposit_tx"`
}

// Status defines model for Status.
type Status struct {
	// AllowedApprovers Users who are allowed to approve. Must be non-empty.
	AllowedApprovers []string `json:"allowed_approvers"`

	// AllowedMfaTypes Allowed approval types. When omitted, defaults to any.
	AllowedMfaTypes *[]MfaType `json:"allowed_mfa_types"`

	// ApprovedBy Users who have already approved
	ApprovedBy map[string]map[string]ApprovalInfo `json:"approved_by"`

	// Count How many users must approve
	Count int32 `json:"count"`

	// NumAuthFactors How many auth factors to require per user
	NumAuthFactors int32 `json:"num_auth_factors"`

	// RequestComparer How to compare HTTP requests when verifying MFA receipt (see [MfaRequest::verify_request])
	RequestComparer *HttpRequestCmp `json:"request_comparer,omitempty"`
}

// SubscriptionStatus The status of a subscription
type SubscriptionStatus string

// SuiChain Supported Sui chains.
type SuiChain string

// SuiSignRequest defines model for SuiSignRequest.
type SuiSignRequest struct {
	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata *interface{} `json:"metadata"`

	// Tx Base64-encoding of a BCS-serialized SUI transaction.
	//
	// When using the SUI TypeScript SDK, these bytes
	// are returned by the `Transaction.build()` method.
	Tx string `json:"tx"`
}

// TaprootSignRequest defines model for TaprootSignRequest.
type TaprootSignRequest struct {
	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata *interface{}         `json:"metadata"`
	SigKind  TaprootSignatureKind `json:"sig_kind"`
	Tx       BtcTx                `json:"tx"`
}

// TaprootSignatureKind defines model for TaprootSignatureKind.
type TaprootSignatureKind struct {
	// Annex Optional annex, as per BIP341
	Annex *string `json:"annex"`

	// InputIndex Transaction input index
	InputIndex            int                       `json:"input_index"`
	LeafHashCodeSeparator *BtcLeafHashCodeSeparator `json:"leaf_hash_code_separator"`

	// MerkleRoot If this field is not present or null, no tweak is applied. If the field is an
	// empty string, the key is tweaked with an unspendable script path per BIP0341.
	// Otherwise, this field must contain a base-64 string encoding 32 bytes that
	// represent the Merkle root with which to tweak the key before signing.
	MerkleRoot *string `json:"merkle_root"`

	// Prevouts Contains outputs of previous transactions.
	Prevouts PrevOutputs `json:"prevouts"`

	// SighashType Hash type of an input's signature, encoded in the last byte of the signature.
	// Possible values:
	// - SIGHASH_ALL
	// - SIGHASH_ALL|SIGHASH_ANYONECANPAY
	// - SIGHASH_DEFAULT
	// - SIGHASH_NONE
	// - SIGHASH_NONE|SIGHASH_ANYONECANPAY
	// - SIGHASH_SINGLE
	// - SIGHASH_SINGLE|SIGHASH_ANYONECANPAY
	SighashType string `json:"sighash_type"`
}

// TelegramAuthRequest defines model for TelegramAuthRequest.
type TelegramAuthRequest struct {
	// BotId The telegram bot ID
	BotId string `json:"bot_id"`

	// Environment Telegram has two environments: production and test
	// Each one has an associated public key for verifying signatures,
	// and we assign each one a unique OIDC issuer
	Environment TelegramEnvironment `json:"environment"`

	// TgWebAppData The telegram webapp data (found in the `tgWebAppData` parameter encoded in the hash section of the URL)
	TgWebAppData string `json:"tg_web_app_data"`
}

// TelegramAuthResponse defines model for TelegramAuthResponse.
type TelegramAuthResponse struct {
	// IdToken The OIDC token corresponding to this telegram user
	IdToken string `json:"id_token"`
}

// TelegramEnvironment Telegram has two environments: production and test
// Each one has an associated public key for verifying signatures,
// and we assign each one a unique OIDC issuer
type TelegramEnvironment string

// TendermintSignRequest defines model for TendermintSignRequest.
type TendermintSignRequest struct {
	// MessageBase64 The bytes of the protobuf-encoded message to sign as a BASE64 string.
	MessageBase64 string `json:"message_base64"`

	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata *interface{} `json:"metadata"`
}

// ThrottleConfig Configuration object for a throttle which limits the number of entities within a given time window
type ThrottleConfig struct {
	// Threshold The number of entities allowed within the window
	Threshold int32 `json:"threshold"`

	// Window Duration measured in seconds
	// A wrapper type for serialization that encodes a `Duration` as a `u64` representing the number of seconds.
	Window Seconds `json:"window"`
}

// TimeoutErrorCode defines model for TimeoutErrorCode.
type TimeoutErrorCode string

// TokenRequest defines model for TokenRequest.
type TokenRequest struct {
	GrantType RefreshGrantType `json:"grant_type"`

	// RefreshToken The refresh token issued to the client.
	RefreshToken string `json:"refresh_token"`
}

// TokenResponse defines model for TokenResponse.
type TokenResponse struct {
	// AccessToken The access token issued by the authorization server.
	AccessToken string `json:"access_token"`

	// ExpiresIn Duration measured in seconds
	// A wrapper type for serialization that encodes a `Duration` as a `u64` representing the number of seconds.
	ExpiresIn Seconds `json:"expires_in"`

	// IdToken An OIDC token issued by Cubist, containing user information
	IdToken *string `json:"id_token"`

	// RefreshToken The refresh token issued by the authorization server.
	RefreshToken *string `json:"refresh_token"`

	// TokenType The type of the token issued. Value is case insensitive.
	TokenType            string                 `json:"token_type"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// TotpApproveRequest defines model for TotpApproveRequest.
type TotpApproveRequest struct {
	// Code TOTP verification code
	Code string `json:"code"`
}

// TotpChallengeAnswer Sent from the client to the server to answer a TOTP challenge
type TotpChallengeAnswer struct {
	// Code The current TOTP code
	Code string `json:"code"`

	// TotpId The ID of the challenge that was returned from the POST endpoint
	TotpId string `json:"totp_id"`
}

// TotpInfo defines model for TotpInfo.
type TotpInfo struct {
	// TotpId The ID of the TOTP challenge.
	TotpId string `json:"totp_id"`

	// TotpUrl Standard TOTP url which includes everything needed to initialize TOTP.
	TotpUrl string `json:"totp_url"`
}

// TotpResetRequest Request to reset TOTP.
type TotpResetRequest struct {
	// Issuer The name of the issuer; defaults to "Cubist".
	Issuer *string `json:"issuer"`
}

// Transaction EIP-2718 typed transaction, including EIP-1559 transactions (`{ "type": "0x02" ... }`), and legacy transactions (`{ "type": "0x00" ... }`). All values in the transaction are expected to be (0x-prefixed or not) hex strings or byte arrays.
type Transaction = TypedTransaction

// TransactionAndStatus defines model for TransactionAndStatus.
type TransactionAndStatus struct {
	// Hash The hash of the transaction that was signed
	Hash *string `json:"hash"`

	// Id The ID of the request record.
	Id string `json:"id"`

	// Nonce The nonce (computed right before signing)
	Nonce *string `json:"nonce"`

	// SignedRawTransaction The signature
	SignedRawTransaction *string   `json:"signedRawTransaction"`
	Status               MmiStatus `json:"status"`
	union                json.RawMessage
}

// TransactionAndStatus0 Legacy (pre EIP-2718) Ethereum transaction type
type TransactionAndStatus0 struct {
	Data     *string `json:"data,omitempty"`
	From     *string `json:"from,omitempty"`
	Gas      *string `json:"gas,omitempty"`
	GasPrice *string `json:"gasPrice,omitempty"`
	Nonce    *string `json:"nonce,omitempty"`
	To       *string `json:"to,omitempty"`
	Type     string  `json:"type"`
	Value    *string `json:"value,omitempty"`
}

// TransactionAndStatus1 EIP-1559 Ethereum transaction type
type TransactionAndStatus1 struct {
	AccessList *[]struct {
		Address     *string   `json:"address,omitempty"`
		StorageKeys *[]string `json:"storageKeys,omitempty"`
	} `json:"accessList,omitempty"`
	Data                 *string `json:"data,omitempty"`
	From                 *string `json:"from,omitempty"`
	Gas                  *string `json:"gas,omitempty"`
	MaxFeePerGas         *string `json:"maxFeePerGas,omitempty"`
	MaxPriorityFeePerGas *string `json:"maxPriorityFeePerGas,omitempty"`
	Nonce                *string `json:"nonce,omitempty"`
	To                   *string `json:"to,omitempty"`
	Type                 string  `json:"type"`
	Value                *string `json:"value,omitempty"`
}

// TsQueryName Supported queries
type TsQueryName string

// TxSignature Information about a signed transaction
type TxSignature struct {
	// Hash Keccak 256 Hash of the RLP encoding of the transaction
	Hash string `json:"hash"`

	// Nonce The nonce (either provided explicitly or computed right before signing)
	Nonce string `json:"nonce"`

	// SignedTx The signed raw transaction
	SignedTx string `json:"signed_tx"`
}

// TxStatus A struct representing the pending message status
type TxStatus struct {
	union json.RawMessage
}

// TxStatusPending defines model for TxStatusPending.
type TxStatusPending struct {
	Status TxStatusPendingStatus `json:"status"`
}

// TxStatusPendingStatus defines model for TxStatusPending.Status.
type TxStatusPendingStatus string

// TxStatusRejected The message has been rejected, including the reason for the rejection.
type TxStatusRejected struct {
	Reason string                 `json:"reason"`
	Status TxStatusRejectedStatus `json:"status"`
}

// TxStatusRejectedStatus defines model for TxStatusRejected.Status.
type TxStatusRejectedStatus string

// TxStatusSigned The message has been signed, including the signature information.
type TxStatusSigned struct {
	// Sig Information about a signed transaction
	Sig struct {
		// Hash Keccak 256 Hash of the RLP encoding of the transaction
		Hash string `json:"hash"`

		// Nonce The nonce (either provided explicitly or computed right before signing)
		Nonce string `json:"nonce"`

		// SignedTx The signed raw transaction
		SignedTx string `json:"signed_tx"`
	} `json:"sig"`
	Status TxStatusSignedStatus `json:"status"`
}

// TxStatusSignedStatus defines model for TxStatusSigned.Status.
type TxStatusSignedStatus string

// TypedData Represents the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) typed data object.
//
// Typed data is a JSON object containing type information, domain separator parameters and the
// message object.
type TypedData struct {
	// Domain Represents the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) EIP712Domain object.
	//
	// EIP712Domain is a JSON object with one or more of the below fields. Protocol designers only need to include the fields that make sense for their signing domain.
	Domain struct {
		// ChainId The EIP-155 chain id. The user-agent should refuse signing if it does not match the
		// currently active chain.
		ChainId *string `json:"chainId"`

		// Name The user readable name of signing domain, i.e., the name of the DApp or the protocol.
		Name *string `json:"name"`

		// Salt A disambiguating salt for the protocol. This can be used as a domain separator of last resort. Can be either a hex-encoded string or byte array
		Salt *TypedDataDomainSalt `json:"salt,omitempty"`

		// VerifyingContract The address of the contract that will verify the signature.
		VerifyingContract *string `json:"verifyingContract"`

		// Version The current major version of the signing domain. Signatures from different versions are not
		// compatible.
		Version *string `json:"version"`
	} `json:"domain"`

	// Message The message to be signed.
	Message map[string]interface{} `json:"message"`

	// PrimaryType The type of the message.
	PrimaryType string `json:"primaryType"`

	// Types The custom types used by this message.
	Types map[string][]struct {
		Name string `json:"name"`
		Type string `json:"type"`
	} `json:"types"`
}

// TypedDataDomainSalt A disambiguating salt for the protocol. This can be used as a domain separator of last resort. Can be either a hex-encoded string or byte array
type TypedDataDomainSalt struct {
	union json.RawMessage
}

// TypedDataArray Byte array of length 32
type TypedDataArray = []float32

// TypedDataString Hex-encoded byte array of length 32
type TypedDataString = string

// TypedTransaction EIP-2718 typed transaction, including EIP-1559 transactions (`{ "type": "0x02" ... }`), and legacy transactions (`{ "type": "0x00" ... }`). All values in the transaction are expected to be (0x-prefixed or not) hex strings or byte arrays.
type TypedTransaction struct {
	union json.RawMessage
}

// TypedTransactionLegacy Legacy (pre EIP-2718) Ethereum transaction type
type TypedTransactionLegacy struct {
	Data     *string `json:"data,omitempty"`
	From     *string `json:"from,omitempty"`
	Gas      *string `json:"gas,omitempty"`
	GasPrice *string `json:"gasPrice,omitempty"`
	Nonce    *string `json:"nonce,omitempty"`
	To       *string `json:"to,omitempty"`
	Type     string  `json:"type"`
	Value    *string `json:"value,omitempty"`
}

// TypedTransactionEip1559 EIP-1559 Ethereum transaction type
type TypedTransactionEip1559 struct {
	AccessList *[]struct {
		Address     *string   `json:"address,omitempty"`
		StorageKeys *[]string `json:"storageKeys,omitempty"`
	} `json:"accessList,omitempty"`
	Data                 *string `json:"data,omitempty"`
	From                 *string `json:"from,omitempty"`
	Gas                  *string `json:"gas,omitempty"`
	MaxFeePerGas         *string `json:"maxFeePerGas,omitempty"`
	MaxPriorityFeePerGas *string `json:"maxPriorityFeePerGas,omitempty"`
	Nonce                *string `json:"nonce,omitempty"`
	To                   *string `json:"to,omitempty"`
	Type                 string  `json:"type"`
	Value                *string `json:"value,omitempty"`
}

// UnauthorizedErrorCode defines model for UnauthorizedErrorCode.
type UnauthorizedErrorCode string

// UnsafeConf Options that should be set only for local devnet testing.
type UnsafeConf struct {
	// DepositContractAddr The hex-encoded address of the deposit contract. If omitted, inferred from `chain_id`
	DepositContractAddr *string `json:"deposit_contract_addr"`

	// GenesisForkVersion The hex-encoded 4-byte fork version
	GenesisForkVersion *string `json:"genesis_fork_version"`
}

// UnstakeRequest Unstake message request.
type UnstakeRequest struct {
	Epoch *Epoch `json:"epoch"`

	// Fork Specifies a fork of the `BeaconChain`, to prevent replay attacks.
	// The schema of `Fork` is defined in the [Beacon chain
	// spec](https://github.com/ethereum/consensus-specs/blob/v1.0.1/specs/phase0/beacon-chain.md#fork).
	Fork Fork `json:"fork"`

	// GenesisData Genesis data as defined in the [Beacon API
	// spec](https://ethereum.github.io/beacon-APIs/#/Beacon/getGenesis).
	// You can get the genesis data from the Beacon node's `/eth/v1/beacon/genesis` end-point.
	// This struct definition is originally from lighthouse's eth2.
	GenesisData GenesisData `json:"genesis_data"`

	// Network Network name ('mainnet', 'holesky')
	Network Network `json:"network"`

	// ValidatorIndex Validator index (`uint64`) to exit. You can get the validator index from the Beacon node's
	// `/eth/v1/beacon/states/head/validators/{pubkey}` end-point. This end point returns an
	// object that contains information about the validator (whose public key is `{pubkey}`),
	// including the validator index. The schema of this end-point is defined
	// [here](https://ethereum.github.io/beacon-APIs/#/Beacon/getStateValidator).
	ValidatorIndex string `json:"validator_index"`
}

// UnstakeResponse Unstake responses are signed voluntary exit messages.
// The schema for this message is defined
// [here](https://github.com/ethereum/consensus-specs/blob/v1.0.1/specs/phase0/beacon-chain.md#signedvoluntaryexit).
// This message can be directly POSTed to the Beacon node's
// `/eth/v1/beacon/pool/voluntary_exits` end-point (see expected schema
// [here](https://ethereum.github.io/beacon-APIs/#/Beacon/submitPoolVoluntaryExit)).
type UnstakeResponse struct {
	// Message An exit voluntarily submitted a validator who wishes to withdraw.
	// The schema for this message is defined
	// [here](https://github.com/ethereum/consensus-specs/blob/v1.0.1/specs/phase0/beacon-chain.md#signedvoluntaryexit).
	Message VoluntaryExit `json:"message"`

	// Signature BLS signature.
	Signature string `json:"signature"`
}

// UpdateContactRequest The information needed to update a Contact.
type UpdateContactRequest struct {
	Addresses  *AddressMap `json:"addresses"`
	EditPolicy *EditPolicy `json:"edit_policy"`

	// Metadata Optional user-defined metadata about the contact.
	Metadata *interface{} `json:"metadata"`

	// Name The name for the contact. Must be unique among contacts in the
	// org. Duplicate contact names will be rejected. Name must consist of
	// alphanumeric characters, spaces, `.` and `-`, and cannot be longer than
	// 50 characters.
	Name  *string `json:"name"`
	Owner *Id     `json:"owner"`
}

// UpdateKeyRequest defines model for UpdateKeyRequest.
type UpdateKeyRequest struct {
	EditPolicy *EditPolicy `json:"edit_policy"`

	// Enabled If set, updates the key's `enabled` property to this value.
	// Once disabled, a key cannot be used for signing.
	Enabled *bool `json:"enabled"`

	// Metadata Set this key's metadata. If this value is `null`, the metadata is erased. If the field is
	// missing, the metadata remains unchanged.
	Metadata *interface{} `json:"metadata,omitempty"`

	// Owner Specify a user other than themselves to be the (potentially new) owner of the key.
	// The specified owner must be an existing user who is a member of the same org.
	Owner *string `json:"owner"`

	// Policy Set this key's policies. For an existing key, this overwrites all its policies.
	Policy *[]interface{} `json:"policy"`

	// Version If set, updating the metadata only succeeds if the version matches this value.
	Version *int64 `json:"version"`
}

// UpdateOrgRequest defines model for UpdateOrgRequest.
type UpdateOrgRequest struct {
	AlienLoginRequirement *SecondFactorRequirement `json:"alien_login_requirement"`
	DefaultInviteKind     *InviteKind              `json:"default_invite_kind"`
	EmailPreferences      *EmailPreferences        `json:"email_preferences"`

	// Enabled If set, update this org's `enabled` field to this value.
	Enabled                     *bool                        `json:"enabled"`
	HistoricalDataConfiguration *HistoricalDataConfiguration `json:"historical_data_configuration"`
	IdpConfiguration            *IdpConfig                   `json:"idp_configuration"`
	MemberLoginRequirement      *SecondFactorRequirement     `json:"member_login_requirement"`

	// NotificationEndpoints If set, update this org's notification endpoints. Notification endpoints are expected to be
	// HTTPS URLs, which accept POST requests. The body of the requests sent to these endpoints are
	// are formatted in JSON and have the following format:
	//
	// ```json
	// {
	// "org": "...",
	// "utc_timestamp": "...",
	// "org_event": "...",
	// ...
	// }
	// ```
	//
	// `org` is the org id, `utc_timestamp` is the UTC timestamp of the event in milliseconds, and
	// `org_event` is a string identifying the type of event that has occurred. The rest of the
	// fields provide additional information related to the type of the event.
	//
	// Endpoints can optionally include filters to customize the org events that they are notified
	// about. Currently, the only supported filter type is `OneOf`, which expects a list of org
	// event types to send to the endpoint. If no filter is configured, the system sends all org
	// events to the endpoint.
	NotificationEndpoints *[]NotificationEndpointConfiguration `json:"notification_endpoints"`
	PasskeyConfiguration  *PasskeyConfig                       `json:"passkey_configuration"`

	// Policy If set, update this org's policies (old policies will be overwritten!).
	Policy                    *[]map[string]interface{}  `json:"policy"`
	PolicyEngineConfiguration *PolicyEngineConfiguration `json:"policy_engine_configuration"`

	// RequireScopeCeiling If set, all user logins will require the claim `cubesigner_scope_ceiling` to be present in
	// the user's token. This claim is an array of scopes (e.g. `[ "manage:keys:list", "sign:evm:tx" ]`),
	// which define a maximum set of scopes the user may request. If the user's token does not contain
	// this claim, the login will be rejected.
	//
	// Owners of the org are exempt from this requirement.
	RequireScopeCeiling *bool `json:"require_scope_ceiling"`

	// TotpFailureLimit If set, update this org's TOTP failure limit. After this many failures,
	// the user is rate limited until the next 30-second TOTP window.
	TotpFailureLimit *int32 `json:"totp_failure_limit"`

	// UserExportDelay If set, update this org's user-export delay, i.e., the amount of time
	// (in seconds) between a user's initiating an export and the time when
	// export is allowed. For security, this delay cannot be set to less than
	// 172800, i.e., 2 days.
	UserExportDelay *int64 `json:"user_export_delay"`

	// UserExportDisabled If set, turn this org's user export off (by passing `true`) or on (by passing `false`).
	UserExportDisabled *bool `json:"user_export_disabled"`

	// UserExportWindow If set, update this org's user-export window, i.e., the amount of time
	// (in seconds) that export is allowed after the user-export delay. After
	// this amount of time, the export is canceled and must be re-initiated.
	// For security, this window cannot be set to greater than 259200, i.e.,
	// 3 days.
	UserExportWindow *int64 `json:"user_export_window"`
}

// UpdateOrgResponse defines model for UpdateOrgResponse.
type UpdateOrgResponse struct {
	AlienLoginRequirement *SecondFactorRequirement `json:"alien_login_requirement"`
	DefaultInviteKind     *InviteKind              `json:"default_invite_kind"`
	EmailPreferences      *EmailPreferences        `json:"email_preferences"`

	// Enabled The new value of the 'enabled' property
	Enabled                     *bool                        `json:"enabled"`
	HistoricalDataConfiguration *HistoricalDataConfiguration `json:"historical_data_configuration"`
	IdpConfiguration            *IdpConfig                   `json:"idp_configuration"`
	MemberLoginRequirement      *SecondFactorRequirement     `json:"member_login_requirement"`

	// Name The new human-readable name for the org (must be alphanumeric)
	Name *string `json:"name"`

	// NotificationEndpoints The new notification endpoint configurations
	NotificationEndpoints *[]NotificationEndpointConfiguration `json:"notification_endpoints"`

	// OrgId The ID of the organization
	OrgId                string         `json:"org_id"`
	PasskeyConfiguration *PasskeyConfig `json:"passkey_configuration"`

	// Policy The new value of org-wide policies
	Policy                    *[]map[string]interface{}  `json:"policy"`
	PolicyEngineConfiguration *PolicyEngineConfiguration `json:"policy_engine_configuration"`

	// RequireScopeCeiling The new value of require_scope_ceiling
	RequireScopeCeiling *bool `json:"require_scope_ceiling"`

	// TotpFailureLimit The new value of the TOTP failure limit
	TotpFailureLimit *int32 `json:"totp_failure_limit"`

	// UserExportDelay The new value of user-export delay
	UserExportDelay *int64 `json:"user_export_delay"`

	// UserExportDisabled The new value of user-export disabled
	UserExportDisabled *bool `json:"user_export_disabled"`

	// UserExportWindow The new value of user-export window
	UserExportWindow *int64 `json:"user_export_window"`
}

// UpdatePolicyRequest Request body for updating a named policy.
type UpdatePolicyRequest struct {
	EditPolicy *EditPolicy `json:"edit_policy"`

	// Metadata A new metadata.
	Metadata *interface{} `json:"metadata"`

	// Name A new name for the policy.
	Name *string `json:"name"`

	// Owner A new owner for the policy.
	Owner *string `json:"owner"`

	// Rules New policy rules.
	Rules *[]interface{} `json:"rules"`
}

// UpdatePolicySecretsRequest defines model for UpdatePolicySecretsRequest.
type UpdatePolicySecretsRequest struct {
	EditPolicy *EditPolicy   `json:"edit_policy"`
	ImportKey  *KeyImportKey `json:"import_key"`

	// Secrets The policy secrets.
	Secrets *map[string]SecretValue `json:"secrets"`
}

// UpdateRoleRequest defines model for UpdateRoleRequest.
type UpdateRoleRequest struct {
	EditPolicy *EditPolicy `json:"edit_policy"`

	// Enabled If set, updates the role's `enabled` property to this value.
	// Once disabled, a role cannot be used; and it's tokens cannot be used for signing.
	Enabled *bool `json:"enabled"`

	// Policy If set, update this role's key policies (old policies will be overwritten!).
	// Only "deny" style policies may be set.
	Policy *[]interface{} `json:"policy"`

	// RestrictedActions If set, update this role's settings for restricting which member roles are allowed to
	// perform actions on this role.
	RestrictedActions *map[string][]MemberRole `json:"restricted_actions"`
}

// UpdateUserMembershipRequest Request to update an existing user
type UpdateUserMembershipRequest struct {
	// Disabled Enable or disable user
	Disabled *bool       `json:"disabled"`
	Role     *MemberRole `json:"role"`
}

// UploadObjectHash The SHA-256 hash of the object for an [UploadRequest].
type UploadObjectHash = openapi_types.File

// UploadWasmPolicyRequest Request for uploading a wasm policy
type UploadWasmPolicyRequest struct {
	// Hash The SHA-256 hash of the object for an [UploadRequest].
	Hash UploadObjectHash `json:"hash"`
}

// UploadWasmPolicyResponse The response to a request for uploading a wasm policy
type UploadWasmPolicyResponse struct {
	// SignedUrl A signed URL for uploading the requested wasm policy.
	SignedUrl string `json:"signed_url"`
}

// UserCountDimensions defines model for UserCountDimensions.
type UserCountDimensions struct {
	// Membership User's membership in the org
	Membership string `json:"membership"`

	// OrgId All metrics must include 'org_id' as a dimension.
	OrgId string `json:"org_id"`
}

// UserExportCompleteRequest A request to complete a user export
type UserExportCompleteRequest struct {
	// KeyId The id of the key to be exported. The key-id must correspond to the one in
	// the specified export request, and the caller must own this key.
	KeyId string `json:"key_id"`

	// PublicKey The NIST P-256 public key (base64-encoded SEC1 with or without compression)
	// to which the export will be encrypted. If a public key was provided when
	// `user_export_init` was called, this key must match that one.
	PublicKey string `json:"public_key"`
}

// UserExportCompleteResponse An encrypted user-export
type UserExportCompleteResponse struct {
	// EncryptedKeyMaterial The exported key material, encrypted with AES-256-GCM under a key
	// derived from the public key supplied in the request via HPKE (RFC9180)
	// with DHKEM(P-256, HKDF-SHA256) and base64 encoded.
	EncryptedKeyMaterial string `json:"encrypted_key_material"`

	// EphemeralPublicKey The ephemeral public key used for HPKE key derivation as base64-encoded
	// uncompressed SEC1 serialization.
	EphemeralPublicKey string `json:"ephemeral_public_key"`

	// UserId The user-id to which this key belongs.
	UserId string `json:"user_id"`
}

// UserExportInitRequest A request to initiate a user export
type UserExportInitRequest struct {
	// KeyId The id of the key to be exported. This key must be owned by the caller.
	KeyId string `json:"key_id"`

	// PublicKey An optional NIST P-256 public key (base64-encoded SEC1 with or without
	// compression) to which the export will be encrypted. If provided, this
	// public key MUST be the one used to encrypt the export once the delay has
	// expired. Otherwise, the user can provide any public key when completing
	// the export request post delay.
	//
	// This option may provide extra security when the user has a secure hardware
	// device (e.g., a phone's secure element or a YubiKey) in which a NIST P-256
	// secret key can be generated. Providing the corresponding public key here
	// ensures that only that specific device will be capable of decrypting
	// the export ciphertext.
	//
	// If no secure hardware device is available to store the secret key, this
	// option SHOULD NOT be used because of the risk of secret key theft during
	// the export delay period.
	PublicKey *string `json:"public_key"`
}

// UserExportInitResponse defines model for UserExportInitResponse.
type UserExportInitResponse struct {
	// ExpEpoch DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	ExpEpoch EpochDateTime `json:"exp_epoch"`

	// KeyId The key-id being requested.
	KeyId string `json:"key_id"`

	// OrgId The org-id in which the key is housed.
	OrgId string `json:"org_id"`

	// PublicKeyHash The SHA-256 hash of the public key provided at export initiation,
	// if any. If a key was provided, only that key can be used to complete
	// the export procedure. Otherwise, any key can be used.
	//
	// IMPORTANT: if a public key is supplied at export initiation, it is
	// STRONGLY RECOMMENDED that the corresponding secret key be stored in
	// a secure hardware device, e.g., a YubiKey or a phone's secure element.
	// If no such hardware is available, supplying a public key at export
	// initiation is STRONGLY DISCOURAGED because of the risk of theft during
	// the export delay period.
	//
	// (See also the comment in the `public_key` field of `UserInitRequest`.)
	PublicKeyHash *string `json:"public_key_hash"`

	// ValidEpoch DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	ValidEpoch EpochDateTime `json:"valid_epoch"`
}

// UserExportRequest Pending user-export request as stored in the database.
type UserExportRequest struct {
	// ExpEpoch DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	ExpEpoch EpochDateTime `json:"exp_epoch"`

	// OrgId The org-id in which the key is housed.
	OrgId string `json:"org_id"`

	// PublicKeyHash The SHA-256 hash of the public key provided at export initiation,
	// if any. If a key was provided, only that key can be used to complete
	// the export procedure. Otherwise, any key can be used.
	//
	// IMPORTANT: if a public key is supplied at export initiation, it is
	// STRONGLY RECOMMENDED that the corresponding secret key be stored in
	// a secure hardware device, e.g., a YubiKey or a phone's secure element.
	// If no such hardware is available, supplying a public key at export
	// initiation is STRONGLY DISCOURAGED because of the risk of theft during
	// the export delay period.
	//
	// (See also the comment in the `public_key` field of `UserInitRequest`.)
	PublicKeyHash *string `json:"public_key_hash"`

	// ValidEpoch DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	ValidEpoch EpochDateTime `json:"valid_epoch"`
}

// UserInOrgInfo defines model for UserInOrgInfo.
type UserInOrgInfo struct {
	// Email The user's email (optional)
	Email *string `json:"email"`

	// Id The id of the user
	Id string `json:"id"`

	// Initialized Whether the user has ever successfully logged in
	Initialized *bool `json:"initialized,omitempty"`

	// Membership Describes whether a user in an org is an Owner or just a regular member
	Membership MemberRole `json:"membership"`

	// Name Optional user name.
	Name   *string          `json:"name"`
	Status MembershipStatus `json:"status"`
}

// UserInOrgMembership Information about a user's membership in an organization
// (without including any info about the user)
type UserInOrgMembership struct {
	// Membership Describes whether a user in an org is an Owner or just a regular member
	Membership MemberRole `json:"membership"`

	// OrgId Organization id
	OrgId  string           `json:"org_id"`
	Status MembershipStatus `json:"status"`
}

// UserInRoleInfo defines model for UserInRoleInfo.
type UserInRoleInfo struct {
	UserId string `json:"user_id"`
}

// UserInfo defines model for UserInfo.
type UserInfo struct {
	// Email Optional email
	Email *string `json:"email"`

	// Mfa All multi-factor authentication methods configured for this user
	Mfa       []ConfiguredMfa `json:"mfa"`
	MfaPolicy *MfaPolicy      `json:"mfa_policy"`

	// Name Optional name
	Name *string `json:"name"`

	// OrgIds All organizations the user belongs to. Deprecated in favor of 'orgs'.
	// Deprecated:
	OrgIds []string `json:"org_ids"`

	// Orgs All organizations the user belongs to, including the membership role in each.
	Orgs []UserInOrgMembership `json:"orgs"`

	// UserId The id of the currently logged in user
	UserId string `json:"user_id"`
}

// UserOrgsResponse The response to the user/orgs endpoint
type UserOrgsResponse struct {
	// Orgs The list of orgs this user is a member of
	Orgs []OrgData `json:"orgs"`
}

// UserVerificationRequirement A WebAuthn Relying Party may require user verification for some of its
// operations but not for others, and may use this type to express its needs.
//
// https://www.w3.org/TR/webauthn-2/#enum-userVerificationRequirement
type UserVerificationRequirement string

// VoluntaryExit An exit voluntarily submitted a validator who wishes to withdraw.
// The schema for this message is defined
// [here](https://github.com/ethereum/consensus-specs/blob/v1.0.1/specs/phase0/beacon-chain.md#signedvoluntaryexit).
type VoluntaryExit struct {
	// Epoch Epoch is a quoted `uint64`.
	Epoch Epoch `json:"epoch"`

	// ValidatorIndex Index of the exiting validator.
	ValidatorIndex string `json:"validator_index"`
}

// WasmPolicyResponse The response from invoking a Wasm policy.
type WasmPolicyResponse struct {
	union json.RawMessage
}

// WasmPolicyResponseAllow defines model for WasmPolicyResponseAllow.
type WasmPolicyResponseAllow struct {
	Response WasmPolicyResponseAllowResponse `json:"response"`
}

// WasmPolicyResponseAllowResponse defines model for WasmPolicyResponseAllow.Response.
type WasmPolicyResponseAllowResponse string

// WasmPolicyResponseDeny The policy denied signing the transaction.
type WasmPolicyResponseDeny struct {
	// Reason The reason for the denial.
	Reason   string                         `json:"reason"`
	Response WasmPolicyResponseDenyResponse `json:"response"`
}

// WasmPolicyResponseDenyResponse defines model for WasmPolicyResponseDeny.Response.
type WasmPolicyResponseDenyResponse string

// WasmPolicyResponseError The policy failed to execute successfully, and exited with an error.
type WasmPolicyResponseError struct {
	// Error The error from the Policy Engine.
	Error    string                          `json:"error"`
	Response WasmPolicyResponseErrorResponse `json:"response"`
}

// WasmPolicyResponseErrorResponse defines model for WasmPolicyResponseError.Response.
type WasmPolicyResponseErrorResponse string

// WasmRule A wasm policy rule that can be executed in the wasm engine.
type WasmRule struct {
	// Hash The SHA-256 hash of a wasm policy that can be used to look it up in the policy store.
	Hash string `json:"hash"`

	// PolicyId The Id of the policy this wasm rule belongs to.
	PolicyId string `json:"policy_id"`
}

// WebhookMethod Allowed webhook methods
type WebhookMethod string

// WebhookPayload The payload that is sent to the webhook.
//
// The webhook should respond with HTTP status code 200 if the operation is permitted.
//
// All non-200 status codes imply that the operation is denied; any response body returned
// by the webhook will be included in the error response sent back to the client.
type WebhookPayload struct {
	// KeyAddress The address (material id) of the key used to sign the request
	KeyAddress string  `json:"key_address"`
	KeyType    KeyType `json:"key_type"`

	// Operation All different kinds of sensitive operations
	Operation OperationKind `json:"operation"`

	// Request The payload (if any) of the sign operation
	Request *interface{} `json:"request"`
}

// WebhookPolicyParams Parameters for the [Deny::Webhook] policy.
type WebhookPolicyParams struct {
	// Headers Optional HTTP headers to set
	Headers *map[string]string `json:"headers,omitempty"`

	// Method Optional HTTP method to use. Defaults to POST.
	Method *string `json:"method,omitempty"`

	// RestrictedOperations CubeSigner operations to which this policy should apply.
	// When omitted, applies to all operations.
	RestrictedOperations *[]OperationKind `json:"restricted_operations"`

	// Timeout Request execution timeout in seconds; must not exceed 5 seconds.
	Timeout *int64 `json:"timeout,omitempty"`

	// Url The url of the webhook
	Url string `json:"url"`
}

// EmailMyOrgsParams defines parameters for EmailMyOrgs.
type EmailMyOrgsParams struct {
	// Email The email of the user
	Email string `form:"email" json:"email"`
}

// SentryApiCallPublicTextBody defines parameters for SentryApiCallPublic.
type SentryApiCallPublicTextBody = string

// ListContactsParams defines parameters for ListContacts.
type ListContactsParams struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `form:"page.size,omitempty" json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `form:"page.start,omitempty" json:"page.start,omitempty"`
}

// ConfigureEmailParamsPurpose defines parameters for ConfigureEmail.
type ConfigureEmailParamsPurpose string

// SentryApiCallTextBody defines parameters for SentryApiCall.
type SentryApiCallTextBody = string

// ListKeysInOrgParams defines parameters for ListKeysInOrg.
type ListKeysInOrgParams struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `form:"page.size,omitempty" json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `form:"page.start,omitempty" json:"page.start,omitempty"`

	// KeyType Filter by key type
	KeyType *KeyType `form:"key_type,omitempty" json:"key_type,omitempty"`

	// KeyOwner Filter by key owner
	KeyOwner *Id `form:"key_owner,omitempty" json:"key_owner,omitempty"`

	// Search Search key metadata
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// ListKeyRolesParams defines parameters for ListKeyRoles.
type ListKeyRolesParams struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `form:"page.size,omitempty" json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `form:"page.start,omitempty" json:"page.start,omitempty"`
}

// ListHistoricalKeyTxParams defines parameters for ListHistoricalKeyTx.
type ListHistoricalKeyTxParams struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `form:"page.size,omitempty" json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `form:"page.start,omitempty" json:"page.start,omitempty"`
}

// QueryMetricsParams defines parameters for QueryMetrics.
type QueryMetricsParams struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `form:"page.size,omitempty" json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `form:"page.start,omitempty" json:"page.start,omitempty"`
}

// MfaVoteCsParams defines parameters for MfaVoteCs.
type MfaVoteCsParams struct {
	MfaVote *MfaVote `form:"mfa_vote,omitempty" json:"mfa_vote,omitempty"`
}

// MfaEmailInitParams defines parameters for MfaEmailInit.
type MfaEmailInitParams struct {
	MfaVote *MfaVote `form:"mfa_vote,omitempty" json:"mfa_vote,omitempty"`
}

// MfaVoteFidoCompleteParams defines parameters for MfaVoteFidoComplete.
type MfaVoteFidoCompleteParams struct {
	MfaVote *MfaVote `form:"mfa_vote,omitempty" json:"mfa_vote,omitempty"`
}

// MfaVoteTotpParams defines parameters for MfaVoteTotp.
type MfaVoteTotpParams struct {
	MfaVote *MfaVote `form:"mfa_vote,omitempty" json:"mfa_vote,omitempty"`
}

// MmiMessageRejectJSONBody defines parameters for MmiMessageReject.
type MmiMessageRejectJSONBody = MmiRejectRequest

// Oauth2TwitterJSONBody defines parameters for Oauth2Twitter.
type Oauth2TwitterJSONBody map[string]string

// ListPoliciesParams defines parameters for ListPolicies.
type ListPoliciesParams struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `form:"page.size,omitempty" json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `form:"page.start,omitempty" json:"page.start,omitempty"`
}

// GetPolicyLogsParams defines parameters for GetPolicyLogs.
type GetPolicyLogsParams struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `form:"page.size,omitempty" json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `form:"page.start,omitempty" json:"page.start,omitempty"`
}

// ListRolesParams defines parameters for ListRoles.
type ListRolesParams struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `form:"page.size,omitempty" json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `form:"page.start,omitempty" json:"page.start,omitempty"`

	// Summarize Don't include keys and users for each role
	Summarize *bool `form:"summarize,omitempty" json:"summarize,omitempty"`
}

// CreateRoleJSONBody defines parameters for CreateRole.
type CreateRoleJSONBody = CreateRoleRequest

// ListRoleKeysParams defines parameters for ListRoleKeys.
type ListRoleKeysParams struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `form:"page.size,omitempty" json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `form:"page.start,omitempty" json:"page.start,omitempty"`
}

// ListHistoricalRoleTxParams defines parameters for ListHistoricalRoleTx.
type ListHistoricalRoleTxParams struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `form:"page.size,omitempty" json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `form:"page.start,omitempty" json:"page.start,omitempty"`
}

// ListRoleUsersParams defines parameters for ListRoleUsers.
type ListRoleUsersParams struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `form:"page.size,omitempty" json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `form:"page.start,omitempty" json:"page.start,omitempty"`
}

// RevokeSessionsParams defines parameters for RevokeSessions.
type RevokeSessionsParams struct {
	// Role If provided, the name or ID of a role to operate on.
	// Cannot be specified together with `user`.
	Role *string `form:"role,omitempty" json:"role,omitempty"`

	// User If provided, the ID of a user to operate on.
	// Cannot be specified together with `role`.
	User *string `form:"user,omitempty" json:"user,omitempty"`
}

// ListSessionsParams defines parameters for ListSessions.
type ListSessionsParams struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `form:"page.size,omitempty" json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `form:"page.start,omitempty" json:"page.start,omitempty"`

	// Role If provided, the name or ID of a role to operate on.
	// Cannot be specified together with `user`.
	Role *string `form:"role,omitempty" json:"role,omitempty"`

	// User If provided, the ID of a user to operate on.
	// Cannot be specified together with `role`.
	User *string `form:"user,omitempty" json:"user,omitempty"`
}

// UserExportDeleteParams defines parameters for UserExportDelete.
type UserExportDeleteParams struct {
	// KeyId The key-id whose export request should be deleted
	KeyId string `form:"key_id" json:"key_id"`

	// UserId The user-id who owns this request. If omitted, defaults to the current user.
	// Only the org owner may delete user-export requests for another user.
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`
}

// UserExportListParams defines parameters for UserExportList.
type UserExportListParams struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `form:"page.size,omitempty" json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `form:"page.start,omitempty" json:"page.start,omitempty"`

	// UserId If provided, the user-id whose user-export requests to list. Defaults to the
	// current user. Only the org owner may list requests for another user.
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`

	// KeyId If provided, the key-id for which to list an existing user-export request.
	KeyId *string `form:"key_id,omitempty" json:"key_id,omitempty"`
}

// UserResetTotpInitJSONBody defines parameters for UserResetTotpInit.
type UserResetTotpInitJSONBody = TotpResetRequest

// ListUsersInOrgParams defines parameters for ListUsersInOrg.
type ListUsersInOrgParams struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `form:"page.size,omitempty" json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `form:"page.start,omitempty" json:"page.start,omitempty"`
}

// PolicyExecuteJSONBody defines parameters for PolicyExecute.
type PolicyExecuteJSONBody = map[string]interface{}

// ResetTotpInitLegacyJSONBody defines parameters for ResetTotpInitLegacy.
type ResetTotpInitLegacyJSONBody = TotpResetRequest

// Cube3signerHeartbeatJSONBody defines parameters for Cube3signerHeartbeat.
type Cube3signerHeartbeatJSONBody = HeartbeatRequest

// SentryApiCallPublicTextRequestBody defines body for SentryApiCallPublic for text/plain ContentType.
type SentryApiCallPublicTextRequestBody = SentryApiCallPublicTextBody

// MmiJSONRequestBody defines body for Mmi for application/json ContentType.
type MmiJSONRequestBody = Request

// Oauth2TokenRefreshJSONRequestBody defines body for Oauth2TokenRefresh for application/json ContentType.
type Oauth2TokenRefreshJSONRequestBody = TokenRequest

// UpdateOrgJSONRequestBody defines body for UpdateOrg for application/json ContentType.
type UpdateOrgJSONRequestBody = UpdateOrgRequest

// AuthMigrationIdentityAddJSONRequestBody defines body for AuthMigrationIdentityAdd for application/json ContentType.
type AuthMigrationIdentityAddJSONRequestBody = MigrateIdentityRequest

// AuthMigrationIdentityRemoveJSONRequestBody defines body for AuthMigrationIdentityRemove for application/json ContentType.
type AuthMigrationIdentityRemoveJSONRequestBody = MigrateIdentityRequest

// AvaSerializedTxSignJSONRequestBody defines body for AvaSerializedTxSign for application/json ContentType.
type AvaSerializedTxSignJSONRequestBody = AvaSerializedTxSignRequest

// AvaSignJSONRequestBody defines body for AvaSign for application/json ContentType.
type AvaSignJSONRequestBody = AvaSignRequest

// BabylonCovSignJSONRequestBody defines body for BabylonCovSign for application/json ContentType.
type BabylonCovSignJSONRequestBody = BabylonCovSignRequest

// CreateEotsNoncesJSONRequestBody defines body for CreateEotsNonces for application/json ContentType.
type CreateEotsNoncesJSONRequestBody = EotsCreateNonceRequest

// EotsSignJSONRequestBody defines body for EotsSign for application/json ContentType.
type EotsSignJSONRequestBody = EotsSignRequest

// BabylonRegistrationJSONRequestBody defines body for BabylonRegistration for application/json ContentType.
type BabylonRegistrationJSONRequestBody = BabylonRegistrationRequest

// BabylonStakingJSONRequestBody defines body for BabylonStaking for application/json ContentType.
type BabylonStakingJSONRequestBody = BabylonStakingRequest

// BtcMessageSignJSONRequestBody defines body for BtcMessageSign for application/json ContentType.
type BtcMessageSignJSONRequestBody = BtcMessageSignRequest

// PsbtSignJSONRequestBody defines body for PsbtSign for application/json ContentType.
type PsbtSignJSONRequestBody = PsbtSignRequest

// BtcSignJSONRequestBody defines body for BtcSign for application/json ContentType.
type BtcSignJSONRequestBody = BtcSignRequest

// BtcTaprootSignJSONRequestBody defines body for BtcTaprootSign for application/json ContentType.
type BtcTaprootSignJSONRequestBody = TaprootSignRequest

// CreateContactJSONRequestBody defines body for CreateContact for application/json ContentType.
type CreateContactJSONRequestBody = CreateContactRequest

// DeleteContactJSONRequestBody defines body for DeleteContact for application/json ContentType.
type DeleteContactJSONRequestBody = Empty

// UpdateContactJSONRequestBody defines body for UpdateContact for application/json ContentType.
type UpdateContactJSONRequestBody = UpdateContactRequest

// DeriveKeyLegacyJSONRequestBody defines body for DeriveKeyLegacy for application/json ContentType.
type DeriveKeyLegacyJSONRequestBody = DeriveKeyRequest

// DeriveKeyJSONRequestBody defines body for DeriveKey for application/json ContentType.
type DeriveKeyJSONRequestBody = DeriveKeysRequest

// ConfigureEmailJSONRequestBody defines body for ConfigureEmail for application/json ContentType.
type ConfigureEmailJSONRequestBody = ConfigureEmailRequest

// Eip191SignJSONRequestBody defines body for Eip191Sign for application/json ContentType.
type Eip191SignJSONRequestBody = Eip191SignRequest

// Eip712SignJSONRequestBody defines body for Eip712Sign for application/json ContentType.
type Eip712SignJSONRequestBody = Eip712SignRequest

// RemoveOidcIdentityJSONRequestBody defines body for RemoveOidcIdentity for application/json ContentType.
type RemoveOidcIdentityJSONRequestBody = OidcIdentity

// AddOidcIdentityJSONRequestBody defines body for AddOidcIdentity for application/json ContentType.
type AddOidcIdentityJSONRequestBody = AddIdentityRequest

// VerifyProofJSONRequestBody defines body for VerifyProof for application/json ContentType.
type VerifyProofJSONRequestBody = IdentityProof

// IdpAuthenticateJSONRequestBody defines body for IdpAuthenticate for application/json ContentType.
type IdpAuthenticateJSONRequestBody = AuthenticationRequest

// IdpPasswordResetConfirmJSONRequestBody defines body for IdpPasswordResetConfirm for application/json ContentType.
type IdpPasswordResetConfirmJSONRequestBody = PasswordResetConfirmRequest

// IdpPasswordResetRequestJSONRequestBody defines body for IdpPasswordResetRequest for application/json ContentType.
type IdpPasswordResetRequestJSONRequestBody = PasswordResetRequest

// ImportKeyJSONRequestBody defines body for ImportKey for application/json ContentType.
type ImportKeyJSONRequestBody = ImportKeyRequest

// EsploraApiCallJSONRequestBody defines body for EsploraApiCall for application/json ContentType.
type EsploraApiCallJSONRequestBody = EsploraRequest

// SentryApiCallTextRequestBody defines body for SentryApiCall for text/plain ContentType.
type SentryApiCallTextRequestBody = SentryApiCallTextBody

// InvitationAcceptJSONRequestBody defines body for InvitationAccept for application/json ContentType.
type InvitationAcceptJSONRequestBody = InvitationAcceptRequest

// InviteJSONRequestBody defines body for Invite for application/json ContentType.
type InviteJSONRequestBody = InviteRequest

// CreateKeyJSONRequestBody defines body for CreateKey for application/json ContentType.
type CreateKeyJSONRequestBody = CreateKeyRequest

// DeleteKeyJSONRequestBody defines body for DeleteKey for application/json ContentType.
type DeleteKeyJSONRequestBody = Empty

// UpdateKeyJSONRequestBody defines body for UpdateKey for application/json ContentType.
type UpdateKeyJSONRequestBody = UpdateKeyRequest

// QueryMetricsJSONRequestBody defines body for QueryMetrics for application/json ContentType.
type QueryMetricsJSONRequestBody = QueryMetricsRequest

// MfaVoteEmailCompleteJSONRequestBody defines body for MfaVoteEmailComplete for application/json ContentType.
type MfaVoteEmailCompleteJSONRequestBody = EmailOtpAnswer

// MfaVoteFidoCompleteJSONRequestBody defines body for MfaVoteFidoComplete for application/json ContentType.
type MfaVoteFidoCompleteJSONRequestBody = FidoAssertAnswer

// MfaVoteTotpJSONRequestBody defines body for MfaVoteTotp for application/json ContentType.
type MfaVoteTotpJSONRequestBody = TotpApproveRequest

// MmiMessageRejectJSONRequestBody defines body for MmiMessageReject for application/json ContentType.
type MmiMessageRejectJSONRequestBody = MmiMessageRejectJSONBody

// MmiMessageSignJSONRequestBody defines body for MmiMessageSign for application/json ContentType.
type MmiMessageSignJSONRequestBody = PendingMessageInfo

// Oauth2TwitterJSONRequestBody defines body for Oauth2Twitter for application/json ContentType.
type Oauth2TwitterJSONRequestBody Oauth2TwitterJSONBody

// OidcAuthJSONRequestBody defines body for OidcAuth for application/json ContentType.
type OidcAuthJSONRequestBody = OidcLoginRequest

// EmailOtpAuthJSONRequestBody defines body for EmailOtpAuth for application/json ContentType.
type EmailOtpAuthJSONRequestBody = EmailOtpRequest

// TelegramAuthJSONRequestBody defines body for TelegramAuth for application/json ContentType.
type TelegramAuthJSONRequestBody = TelegramAuthRequest

// CreateOrgJSONRequestBody defines body for CreateOrg for application/json ContentType.
type CreateOrgJSONRequestBody = CreateOrgRequest

// CreatePolicyJSONRequestBody defines body for CreatePolicy for application/json ContentType.
type CreatePolicyJSONRequestBody = CreatePolicyRequest

// DeletePolicyJSONRequestBody defines body for DeletePolicy for application/json ContentType.
type DeletePolicyJSONRequestBody = Empty

// UpdatePolicyJSONRequestBody defines body for UpdatePolicy for application/json ContentType.
type UpdatePolicyJSONRequestBody = UpdatePolicyRequest

// GetPolicyLogsJSONRequestBody defines body for GetPolicyLogs for application/json ContentType.
type GetPolicyLogsJSONRequestBody = PolicyLogsRequest

// InvokePolicyJSONRequestBody defines body for InvokePolicy for application/json ContentType.
type InvokePolicyJSONRequestBody = InvokePolicyRequest

// UpdatePolicySecretsJSONRequestBody defines body for UpdatePolicySecrets for application/json ContentType.
type UpdatePolicySecretsJSONRequestBody = UpdatePolicySecretsRequest

// DeletePolicySecretJSONRequestBody defines body for DeletePolicySecret for application/json ContentType.
type DeletePolicySecretJSONRequestBody = Empty

// SetPolicySecretJSONRequestBody defines body for SetPolicySecret for application/json ContentType.
type SetPolicySecretJSONRequestBody = SetPolicySecretRequest

// UploadWasmPolicyJSONRequestBody defines body for UploadWasmPolicy for application/json ContentType.
type UploadWasmPolicyJSONRequestBody = UploadWasmPolicyRequest

// CreateRoleJSONRequestBody defines body for CreateRole for application/json ContentType.
type CreateRoleJSONRequestBody = CreateRoleJSONBody

// DeleteRoleJSONRequestBody defines body for DeleteRole for application/json ContentType.
type DeleteRoleJSONRequestBody = Empty

// UpdateRoleJSONRequestBody defines body for UpdateRole for application/json ContentType.
type UpdateRoleJSONRequestBody = UpdateRoleRequest

// AddKeysToRoleJSONRequestBody defines body for AddKeysToRole for application/json ContentType.
type AddKeysToRoleJSONRequestBody = AddKeysToRoleRequest

// AddUserToRoleJSONRequestBody defines body for AddUserToRole for application/json ContentType.
type AddUserToRoleJSONRequestBody = Empty

// RemoveKeyFromRoleJSONRequestBody defines body for RemoveKeyFromRole for application/json ContentType.
type RemoveKeyFromRoleJSONRequestBody = Empty

// CreateRoleTokenJSONRequestBody defines body for CreateRoleToken for application/json ContentType.
type CreateRoleTokenJSONRequestBody = CreateTokenRequest

// RemoveUserFromRoleJSONRequestBody defines body for RemoveUserFromRole for application/json ContentType.
type RemoveUserFromRoleJSONRequestBody = Empty

// CreateSessionJSONRequestBody defines body for CreateSession for application/json ContentType.
type CreateSessionJSONRequestBody = CreateSessionRequest

// SolanaSignJSONRequestBody defines body for SolanaSign for application/json ContentType.
type SolanaSignJSONRequestBody = SolanaSignRequest

// SuiSignJSONRequestBody defines body for SuiSign for application/json ContentType.
type SuiSignJSONRequestBody = SuiSignRequest

// TendermintSignJSONRequestBody defines body for TendermintSign for application/json ContentType.
type TendermintSignJSONRequestBody = TendermintSignRequest

// UserExportCompleteJSONRequestBody defines body for UserExportComplete for application/json ContentType.
type UserExportCompleteJSONRequestBody = UserExportCompleteRequest

// UserExportInitJSONRequestBody defines body for UserExportInit for application/json ContentType.
type UserExportInitJSONRequestBody = UserExportInitRequest

// UserRegisterFidoCompleteJSONRequestBody defines body for UserRegisterFidoComplete for application/json ContentType.
type UserRegisterFidoCompleteJSONRequestBody = FidoCreateChallengeAnswer

// UserRegisterFidoInitJSONRequestBody defines body for UserRegisterFidoInit for application/json ContentType.
type UserRegisterFidoInitJSONRequestBody = FidoCreateRequest

// UserDeleteFidoJSONRequestBody defines body for UserDeleteFido for application/json ContentType.
type UserDeleteFidoJSONRequestBody = Empty

// UserDeleteTotpJSONRequestBody defines body for UserDeleteTotp for application/json ContentType.
type UserDeleteTotpJSONRequestBody = Empty

// UserResetTotpCompleteJSONRequestBody defines body for UserResetTotpComplete for application/json ContentType.
type UserResetTotpCompleteJSONRequestBody = TotpChallengeAnswer

// UserResetTotpInitJSONRequestBody defines body for UserResetTotpInit for application/json ContentType.
type UserResetTotpInitJSONRequestBody = UserResetTotpInitJSONBody

// UserVerifyTotpJSONRequestBody defines body for UserVerifyTotp for application/json ContentType.
type UserVerifyTotpJSONRequestBody = TotpApproveRequest

// CreateOidcUserJSONRequestBody defines body for CreateOidcUser for application/json ContentType.
type CreateOidcUserJSONRequestBody = AddThirdPartyUserRequest

// DeleteOidcUserJSONRequestBody defines body for DeleteOidcUser for application/json ContentType.
type DeleteOidcUserJSONRequestBody = OidcIdentity

// UpdateUserMembershipJSONRequestBody defines body for UpdateUserMembership for application/json ContentType.
type UpdateUserMembershipJSONRequestBody = UpdateUserMembershipRequest

// PasskeyAuthCompleteJSONRequestBody defines body for PasskeyAuthComplete for application/json ContentType.
type PasskeyAuthCompleteJSONRequestBody = PasskeyAssertAnswer

// PasskeyAuthInitJSONRequestBody defines body for PasskeyAuthInit for application/json ContentType.
type PasskeyAuthInitJSONRequestBody = LoginRequest

// PolicyExecuteJSONRequestBody defines body for PolicyExecute for application/json ContentType.
type PolicyExecuteJSONRequestBody = PolicyExecuteJSONBody

// RegisterFidoCompleteLegacyJSONRequestBody defines body for RegisterFidoCompleteLegacy for application/json ContentType.
type RegisterFidoCompleteLegacyJSONRequestBody = FidoCreateChallengeAnswer

// RegisterFidoInitLegacyJSONRequestBody defines body for RegisterFidoInitLegacy for application/json ContentType.
type RegisterFidoInitLegacyJSONRequestBody = FidoCreateRequest

// ResetTotpCompleteLegacyJSONRequestBody defines body for ResetTotpCompleteLegacy for application/json ContentType.
type ResetTotpCompleteLegacyJSONRequestBody = TotpChallengeAnswer

// ResetTotpInitLegacyJSONRequestBody defines body for ResetTotpInitLegacy for application/json ContentType.
type ResetTotpInitLegacyJSONRequestBody = ResetTotpInitLegacyJSONBody

// VerifyTotpLegacyJSONRequestBody defines body for VerifyTotpLegacy for application/json ContentType.
type VerifyTotpLegacyJSONRequestBody = TotpApproveRequest

// BlobSignJSONRequestBody defines body for BlobSign for application/json ContentType.
type BlobSignJSONRequestBody = BlobSignRequest

// Cube3signerHeartbeatJSONRequestBody defines body for Cube3signerHeartbeat for application/json ContentType.
type Cube3signerHeartbeatJSONRequestBody = Cube3signerHeartbeatJSONBody

// Eth1SignJSONRequestBody defines body for Eth1Sign for application/json ContentType.
type Eth1SignJSONRequestBody = Eth1SignRequest

// Eth2SignJSONRequestBody defines body for Eth2Sign for application/json ContentType.
type Eth2SignJSONRequestBody = Eth2SignRequest

// StakeJSONRequestBody defines body for Stake for application/json ContentType.
type StakeJSONRequestBody = StakeRequest

// UnstakeJSONRequestBody defines body for Unstake for application/json ContentType.
type UnstakeJSONRequestBody = UnstakeRequest

// SignerSessionRefreshJSONRequestBody defines body for SignerSessionRefresh for application/json ContentType.
type SignerSessionRefreshJSONRequestBody = AuthData

// Getter for additional properties for TokenResponse. Returns the specified
// element and whether it was found
func (a TokenResponse) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TokenResponse
func (a *TokenResponse) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TokenResponse to handle AdditionalProperties
func (a *TokenResponse) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["access_token"]; found {
		err = json.Unmarshal(raw, &a.AccessToken)
		if err != nil {
			return fmt.Errorf("error reading 'access_token': %w", err)
		}
		delete(object, "access_token")
	}

	if raw, found := object["expires_in"]; found {
		err = json.Unmarshal(raw, &a.ExpiresIn)
		if err != nil {
			return fmt.Errorf("error reading 'expires_in': %w", err)
		}
		delete(object, "expires_in")
	}

	if raw, found := object["id_token"]; found {
		err = json.Unmarshal(raw, &a.IdToken)
		if err != nil {
			return fmt.Errorf("error reading 'id_token': %w", err)
		}
		delete(object, "id_token")
	}

	if raw, found := object["refresh_token"]; found {
		err = json.Unmarshal(raw, &a.RefreshToken)
		if err != nil {
			return fmt.Errorf("error reading 'refresh_token': %w", err)
		}
		delete(object, "refresh_token")
	}

	if raw, found := object["token_type"]; found {
		err = json.Unmarshal(raw, &a.TokenType)
		if err != nil {
			return fmt.Errorf("error reading 'token_type': %w", err)
		}
		delete(object, "token_type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TokenResponse to handle AdditionalProperties
func (a TokenResponse) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["access_token"], err = json.Marshal(a.AccessToken)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'access_token': %w", err)
	}

	object["expires_in"], err = json.Marshal(a.ExpiresIn)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'expires_in': %w", err)
	}

	if a.IdToken != nil {
		object["id_token"], err = json.Marshal(a.IdToken)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id_token': %w", err)
		}
	}

	if a.RefreshToken != nil {
		object["refresh_token"], err = json.Marshal(a.RefreshToken)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'refresh_token': %w", err)
		}
	}

	object["token_type"], err = json.Marshal(a.TokenType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'token_type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsAudString returns the union data inside the Aud as a AudString
func (t Aud) AsAudString() (AudString, error) {
	var body AudString
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAudString overwrites any union data inside the Aud as the provided AudString
func (t *Aud) FromAudString(v AudString) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAudString performs a merge with any union data inside the Aud, using the provided AudString
func (t *Aud) MergeAudString(v AudString) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAudArray returns the union data inside the Aud as a AudArray
func (t Aud) AsAudArray() (AudArray, error) {
	var body AudArray
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAudArray overwrites any union data inside the Aud as the provided AudArray
func (t *Aud) FromAudArray(v AudArray) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAudArray performs a merge with any union data inside the Aud, using the provided AudArray
func (t *Aud) MergeAudArray(v AudArray) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Aud) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Aud) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBabylonStakingRequestDeposit returns the union data inside the BabylonStakingRequest as a BabylonStakingRequestDeposit
func (t BabylonStakingRequest) AsBabylonStakingRequestDeposit() (BabylonStakingRequestDeposit, error) {
	var body BabylonStakingRequestDeposit
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBabylonStakingRequestDeposit overwrites any union data inside the BabylonStakingRequest as the provided BabylonStakingRequestDeposit
func (t *BabylonStakingRequest) FromBabylonStakingRequestDeposit(v BabylonStakingRequestDeposit) error {
	v.Action = "BabylonStakingRequestDeposit"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBabylonStakingRequestDeposit performs a merge with any union data inside the BabylonStakingRequest, using the provided BabylonStakingRequestDeposit
func (t *BabylonStakingRequest) MergeBabylonStakingRequestDeposit(v BabylonStakingRequestDeposit) error {
	v.Action = "BabylonStakingRequestDeposit"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBabylonStakingRequestEarlyUnbond returns the union data inside the BabylonStakingRequest as a BabylonStakingRequestEarlyUnbond
func (t BabylonStakingRequest) AsBabylonStakingRequestEarlyUnbond() (BabylonStakingRequestEarlyUnbond, error) {
	var body BabylonStakingRequestEarlyUnbond
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBabylonStakingRequestEarlyUnbond overwrites any union data inside the BabylonStakingRequest as the provided BabylonStakingRequestEarlyUnbond
func (t *BabylonStakingRequest) FromBabylonStakingRequestEarlyUnbond(v BabylonStakingRequestEarlyUnbond) error {
	v.Action = "BabylonStakingRequestEarlyUnbond"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBabylonStakingRequestEarlyUnbond performs a merge with any union data inside the BabylonStakingRequest, using the provided BabylonStakingRequestEarlyUnbond
func (t *BabylonStakingRequest) MergeBabylonStakingRequestEarlyUnbond(v BabylonStakingRequestEarlyUnbond) error {
	v.Action = "BabylonStakingRequestEarlyUnbond"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBabylonStakingRequestWithdrawTimelock returns the union data inside the BabylonStakingRequest as a BabylonStakingRequestWithdrawTimelock
func (t BabylonStakingRequest) AsBabylonStakingRequestWithdrawTimelock() (BabylonStakingRequestWithdrawTimelock, error) {
	var body BabylonStakingRequestWithdrawTimelock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBabylonStakingRequestWithdrawTimelock overwrites any union data inside the BabylonStakingRequest as the provided BabylonStakingRequestWithdrawTimelock
func (t *BabylonStakingRequest) FromBabylonStakingRequestWithdrawTimelock(v BabylonStakingRequestWithdrawTimelock) error {
	v.Action = "BabylonStakingRequestWithdrawTimelock"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBabylonStakingRequestWithdrawTimelock performs a merge with any union data inside the BabylonStakingRequest, using the provided BabylonStakingRequestWithdrawTimelock
func (t *BabylonStakingRequest) MergeBabylonStakingRequestWithdrawTimelock(v BabylonStakingRequestWithdrawTimelock) error {
	v.Action = "BabylonStakingRequestWithdrawTimelock"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBabylonStakingRequestWithdrawEarlyUnbond returns the union data inside the BabylonStakingRequest as a BabylonStakingRequestWithdrawEarlyUnbond
func (t BabylonStakingRequest) AsBabylonStakingRequestWithdrawEarlyUnbond() (BabylonStakingRequestWithdrawEarlyUnbond, error) {
	var body BabylonStakingRequestWithdrawEarlyUnbond
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBabylonStakingRequestWithdrawEarlyUnbond overwrites any union data inside the BabylonStakingRequest as the provided BabylonStakingRequestWithdrawEarlyUnbond
func (t *BabylonStakingRequest) FromBabylonStakingRequestWithdrawEarlyUnbond(v BabylonStakingRequestWithdrawEarlyUnbond) error {
	v.Action = "BabylonStakingRequestWithdrawEarlyUnbond"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBabylonStakingRequestWithdrawEarlyUnbond performs a merge with any union data inside the BabylonStakingRequest, using the provided BabylonStakingRequestWithdrawEarlyUnbond
func (t *BabylonStakingRequest) MergeBabylonStakingRequestWithdrawEarlyUnbond(v BabylonStakingRequestWithdrawEarlyUnbond) error {
	v.Action = "BabylonStakingRequestWithdrawEarlyUnbond"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBabylonStakingRequestWithdrawSlashing returns the union data inside the BabylonStakingRequest as a BabylonStakingRequestWithdrawSlashing
func (t BabylonStakingRequest) AsBabylonStakingRequestWithdrawSlashing() (BabylonStakingRequestWithdrawSlashing, error) {
	var body BabylonStakingRequestWithdrawSlashing
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBabylonStakingRequestWithdrawSlashing overwrites any union data inside the BabylonStakingRequest as the provided BabylonStakingRequestWithdrawSlashing
func (t *BabylonStakingRequest) FromBabylonStakingRequestWithdrawSlashing(v BabylonStakingRequestWithdrawSlashing) error {
	v.Action = "BabylonStakingRequestWithdrawSlashing"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBabylonStakingRequestWithdrawSlashing performs a merge with any union data inside the BabylonStakingRequest, using the provided BabylonStakingRequestWithdrawSlashing
func (t *BabylonStakingRequest) MergeBabylonStakingRequestWithdrawSlashing(v BabylonStakingRequestWithdrawSlashing) error {
	v.Action = "BabylonStakingRequestWithdrawSlashing"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBabylonStakingRequestSlashDeposit returns the union data inside the BabylonStakingRequest as a BabylonStakingRequestSlashDeposit
func (t BabylonStakingRequest) AsBabylonStakingRequestSlashDeposit() (BabylonStakingRequestSlashDeposit, error) {
	var body BabylonStakingRequestSlashDeposit
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBabylonStakingRequestSlashDeposit overwrites any union data inside the BabylonStakingRequest as the provided BabylonStakingRequestSlashDeposit
func (t *BabylonStakingRequest) FromBabylonStakingRequestSlashDeposit(v BabylonStakingRequestSlashDeposit) error {
	v.Action = "BabylonStakingRequestSlashDeposit"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBabylonStakingRequestSlashDeposit performs a merge with any union data inside the BabylonStakingRequest, using the provided BabylonStakingRequestSlashDeposit
func (t *BabylonStakingRequest) MergeBabylonStakingRequestSlashDeposit(v BabylonStakingRequestSlashDeposit) error {
	v.Action = "BabylonStakingRequestSlashDeposit"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBabylonStakingRequestSlashEarlyUnbond returns the union data inside the BabylonStakingRequest as a BabylonStakingRequestSlashEarlyUnbond
func (t BabylonStakingRequest) AsBabylonStakingRequestSlashEarlyUnbond() (BabylonStakingRequestSlashEarlyUnbond, error) {
	var body BabylonStakingRequestSlashEarlyUnbond
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBabylonStakingRequestSlashEarlyUnbond overwrites any union data inside the BabylonStakingRequest as the provided BabylonStakingRequestSlashEarlyUnbond
func (t *BabylonStakingRequest) FromBabylonStakingRequestSlashEarlyUnbond(v BabylonStakingRequestSlashEarlyUnbond) error {
	v.Action = "BabylonStakingRequestSlashEarlyUnbond"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBabylonStakingRequestSlashEarlyUnbond performs a merge with any union data inside the BabylonStakingRequest, using the provided BabylonStakingRequestSlashEarlyUnbond
func (t *BabylonStakingRequest) MergeBabylonStakingRequestSlashEarlyUnbond(v BabylonStakingRequestSlashEarlyUnbond) error {
	v.Action = "BabylonStakingRequestSlashEarlyUnbond"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BabylonStakingRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"action"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t BabylonStakingRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "BabylonStakingRequestDeposit":
		return t.AsBabylonStakingRequestDeposit()
	case "BabylonStakingRequestEarlyUnbond":
		return t.AsBabylonStakingRequestEarlyUnbond()
	case "BabylonStakingRequestSlashDeposit":
		return t.AsBabylonStakingRequestSlashDeposit()
	case "BabylonStakingRequestSlashEarlyUnbond":
		return t.AsBabylonStakingRequestSlashEarlyUnbond()
	case "BabylonStakingRequestWithdrawEarlyUnbond":
		return t.AsBabylonStakingRequestWithdrawEarlyUnbond()
	case "BabylonStakingRequestWithdrawSlashing":
		return t.AsBabylonStakingRequestWithdrawSlashing()
	case "BabylonStakingRequestWithdrawTimelock":
		return t.AsBabylonStakingRequestWithdrawTimelock()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t BabylonStakingRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BabylonStakingRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsConfiguredMfaTotp returns the union data inside the ConfiguredMfa as a ConfiguredMfaTotp
func (t ConfiguredMfa) AsConfiguredMfaTotp() (ConfiguredMfaTotp, error) {
	var body ConfiguredMfaTotp
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConfiguredMfaTotp overwrites any union data inside the ConfiguredMfa as the provided ConfiguredMfaTotp
func (t *ConfiguredMfa) FromConfiguredMfaTotp(v ConfiguredMfaTotp) error {
	v.Type = "ConfiguredMfaTotp"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConfiguredMfaTotp performs a merge with any union data inside the ConfiguredMfa, using the provided ConfiguredMfaTotp
func (t *ConfiguredMfa) MergeConfiguredMfaTotp(v ConfiguredMfaTotp) error {
	v.Type = "ConfiguredMfaTotp"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConfiguredMfaFido returns the union data inside the ConfiguredMfa as a ConfiguredMfaFido
func (t ConfiguredMfa) AsConfiguredMfaFido() (ConfiguredMfaFido, error) {
	var body ConfiguredMfaFido
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConfiguredMfaFido overwrites any union data inside the ConfiguredMfa as the provided ConfiguredMfaFido
func (t *ConfiguredMfa) FromConfiguredMfaFido(v ConfiguredMfaFido) error {
	v.Type = "ConfiguredMfaFido"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConfiguredMfaFido performs a merge with any union data inside the ConfiguredMfa, using the provided ConfiguredMfaFido
func (t *ConfiguredMfa) MergeConfiguredMfaFido(v ConfiguredMfaFido) error {
	v.Type = "ConfiguredMfaFido"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ConfiguredMfa) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ConfiguredMfa) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ConfiguredMfaFido":
		return t.AsConfiguredMfaFido()
	case "ConfiguredMfaTotp":
		return t.AsConfiguredMfaTotp()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ConfiguredMfa) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ConfiguredMfa) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEvmOptionsString returns the union data inside the EvmOptions as a EvmOptionsString
func (t EvmOptions) AsEvmOptionsString() (EvmOptionsString, error) {
	var body EvmOptionsString
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmOptionsString overwrites any union data inside the EvmOptions as the provided EvmOptionsString
func (t *EvmOptions) FromEvmOptionsString(v EvmOptionsString) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmOptionsString performs a merge with any union data inside the EvmOptions, using the provided EvmOptionsString
func (t *EvmOptions) MergeEvmOptionsString(v EvmOptionsString) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmOptionsObject returns the union data inside the EvmOptions as a EvmOptionsObject
func (t EvmOptions) AsEvmOptionsObject() (EvmOptionsObject, error) {
	var body EvmOptionsObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmOptionsObject overwrites any union data inside the EvmOptions as the provided EvmOptionsObject
func (t *EvmOptions) FromEvmOptionsObject(v EvmOptionsObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmOptionsObject performs a merge with any union data inside the EvmOptions, using the provided EvmOptionsObject
func (t *EvmOptions) MergeEvmOptionsObject(v EvmOptionsObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EvmOptions) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EvmOptions) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsHttpRequestCmpEq returns the union data inside the HttpRequestCmp as a HttpRequestCmpEq
func (t HttpRequestCmp) AsHttpRequestCmpEq() (HttpRequestCmpEq, error) {
	var body HttpRequestCmpEq
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHttpRequestCmpEq overwrites any union data inside the HttpRequestCmp as the provided HttpRequestCmpEq
func (t *HttpRequestCmp) FromHttpRequestCmpEq(v HttpRequestCmpEq) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHttpRequestCmpEq performs a merge with any union data inside the HttpRequestCmp, using the provided HttpRequestCmpEq
func (t *HttpRequestCmp) MergeHttpRequestCmpEq(v HttpRequestCmpEq) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsHttpRequestCmpEvmTx returns the union data inside the HttpRequestCmp as a HttpRequestCmpEvmTx
func (t HttpRequestCmp) AsHttpRequestCmpEvmTx() (HttpRequestCmpEvmTx, error) {
	var body HttpRequestCmpEvmTx
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHttpRequestCmpEvmTx overwrites any union data inside the HttpRequestCmp as the provided HttpRequestCmpEvmTx
func (t *HttpRequestCmp) FromHttpRequestCmpEvmTx(v HttpRequestCmpEvmTx) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHttpRequestCmpEvmTx performs a merge with any union data inside the HttpRequestCmp, using the provided HttpRequestCmpEvmTx
func (t *HttpRequestCmp) MergeHttpRequestCmpEvmTx(v HttpRequestCmpEvmTx) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsHttpRequestCmpSolanaTx returns the union data inside the HttpRequestCmp as a HttpRequestCmpSolanaTx
func (t HttpRequestCmp) AsHttpRequestCmpSolanaTx() (HttpRequestCmpSolanaTx, error) {
	var body HttpRequestCmpSolanaTx
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHttpRequestCmpSolanaTx overwrites any union data inside the HttpRequestCmp as the provided HttpRequestCmpSolanaTx
func (t *HttpRequestCmp) FromHttpRequestCmpSolanaTx(v HttpRequestCmpSolanaTx) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHttpRequestCmpSolanaTx performs a merge with any union data inside the HttpRequestCmp, using the provided HttpRequestCmpSolanaTx
func (t *HttpRequestCmp) MergeHttpRequestCmpSolanaTx(v HttpRequestCmpSolanaTx) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t HttpRequestCmp) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *HttpRequestCmp) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsJsonKeyPackageRawSecret returns the union data inside the JsonKeyPackage as a JsonKeyPackageRawSecret
func (t JsonKeyPackage) AsJsonKeyPackageRawSecret() (JsonKeyPackageRawSecret, error) {
	var body JsonKeyPackageRawSecret
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJsonKeyPackageRawSecret overwrites any union data inside the JsonKeyPackage as the provided JsonKeyPackageRawSecret
func (t *JsonKeyPackage) FromJsonKeyPackageRawSecret(v JsonKeyPackageRawSecret) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJsonKeyPackageRawSecret performs a merge with any union data inside the JsonKeyPackage, using the provided JsonKeyPackageRawSecret
func (t *JsonKeyPackage) MergeJsonKeyPackageRawSecret(v JsonKeyPackageRawSecret) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJsonKeyPackageEnglishMnemonic returns the union data inside the JsonKeyPackage as a JsonKeyPackageEnglishMnemonic
func (t JsonKeyPackage) AsJsonKeyPackageEnglishMnemonic() (JsonKeyPackageEnglishMnemonic, error) {
	var body JsonKeyPackageEnglishMnemonic
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJsonKeyPackageEnglishMnemonic overwrites any union data inside the JsonKeyPackage as the provided JsonKeyPackageEnglishMnemonic
func (t *JsonKeyPackage) FromJsonKeyPackageEnglishMnemonic(v JsonKeyPackageEnglishMnemonic) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJsonKeyPackageEnglishMnemonic performs a merge with any union data inside the JsonKeyPackage, using the provided JsonKeyPackageEnglishMnemonic
func (t *JsonKeyPackage) MergeJsonKeyPackageEnglishMnemonic(v JsonKeyPackageEnglishMnemonic) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t JsonKeyPackage) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["key_type"], err = json.Marshal(t.KeyType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'key_type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *JsonKeyPackage) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["key_type"]; found {
		err = json.Unmarshal(raw, &t.KeyType)
		if err != nil {
			return fmt.Errorf("error reading 'key_type': %w", err)
		}
	}

	return err
}

// AsOrgMetricDiscriminants returns the union data inside the MetricName as a OrgMetricDiscriminants
func (t MetricName) AsOrgMetricDiscriminants() (OrgMetricDiscriminants, error) {
	var body OrgMetricDiscriminants
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrgMetricDiscriminants overwrites any union data inside the MetricName as the provided OrgMetricDiscriminants
func (t *MetricName) FromOrgMetricDiscriminants(v OrgMetricDiscriminants) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrgMetricDiscriminants performs a merge with any union data inside the MetricName, using the provided OrgMetricDiscriminants
func (t *MetricName) MergeOrgMetricDiscriminants(v OrgMetricDiscriminants) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTsQueryName returns the union data inside the MetricName as a TsQueryName
func (t MetricName) AsTsQueryName() (TsQueryName, error) {
	var body TsQueryName
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTsQueryName overwrites any union data inside the MetricName as the provided TsQueryName
func (t *MetricName) FromTsQueryName(v TsQueryName) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTsQueryName performs a merge with any union data inside the MetricName, using the provided TsQueryName
func (t *MetricName) MergeTsQueryName(v TsQueryName) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MetricName) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MetricName) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMfaTypeCubeSigner returns the union data inside the MfaType as a MfaTypeCubeSigner
func (t MfaType) AsMfaTypeCubeSigner() (MfaTypeCubeSigner, error) {
	var body MfaTypeCubeSigner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMfaTypeCubeSigner overwrites any union data inside the MfaType as the provided MfaTypeCubeSigner
func (t *MfaType) FromMfaTypeCubeSigner(v MfaTypeCubeSigner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMfaTypeCubeSigner performs a merge with any union data inside the MfaType, using the provided MfaTypeCubeSigner
func (t *MfaType) MergeMfaTypeCubeSigner(v MfaTypeCubeSigner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMfaTypeTotp returns the union data inside the MfaType as a MfaTypeTotp
func (t MfaType) AsMfaTypeTotp() (MfaTypeTotp, error) {
	var body MfaTypeTotp
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMfaTypeTotp overwrites any union data inside the MfaType as the provided MfaTypeTotp
func (t *MfaType) FromMfaTypeTotp(v MfaTypeTotp) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMfaTypeTotp performs a merge with any union data inside the MfaType, using the provided MfaTypeTotp
func (t *MfaType) MergeMfaTypeTotp(v MfaTypeTotp) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMfaTypeEmailOtp returns the union data inside the MfaType as a MfaTypeEmailOtp
func (t MfaType) AsMfaTypeEmailOtp() (MfaTypeEmailOtp, error) {
	var body MfaTypeEmailOtp
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMfaTypeEmailOtp overwrites any union data inside the MfaType as the provided MfaTypeEmailOtp
func (t *MfaType) FromMfaTypeEmailOtp(v MfaTypeEmailOtp) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMfaTypeEmailOtp performs a merge with any union data inside the MfaType, using the provided MfaTypeEmailOtp
func (t *MfaType) MergeMfaTypeEmailOtp(v MfaTypeEmailOtp) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMfaTypeFido returns the union data inside the MfaType as a MfaTypeFido
func (t MfaType) AsMfaTypeFido() (MfaTypeFido, error) {
	var body MfaTypeFido
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMfaTypeFido overwrites any union data inside the MfaType as the provided MfaTypeFido
func (t *MfaType) FromMfaTypeFido(v MfaTypeFido) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMfaTypeFido performs a merge with any union data inside the MfaType, using the provided MfaTypeFido
func (t *MfaType) MergeMfaTypeFido(v MfaTypeFido) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMfaTypeFidoKey returns the union data inside the MfaType as a MfaTypeFidoKey
func (t MfaType) AsMfaTypeFidoKey() (MfaTypeFidoKey, error) {
	var body MfaTypeFidoKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMfaTypeFidoKey overwrites any union data inside the MfaType as the provided MfaTypeFidoKey
func (t *MfaType) FromMfaTypeFidoKey(v MfaTypeFidoKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMfaTypeFidoKey performs a merge with any union data inside the MfaType, using the provided MfaTypeFidoKey
func (t *MfaType) MergeMfaTypeFidoKey(v MfaTypeFidoKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MfaType) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MfaType) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMsgStatusPending returns the union data inside the MsgStatus as a MsgStatusPending
func (t MsgStatus) AsMsgStatusPending() (MsgStatusPending, error) {
	var body MsgStatusPending
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMsgStatusPending overwrites any union data inside the MsgStatus as the provided MsgStatusPending
func (t *MsgStatus) FromMsgStatusPending(v MsgStatusPending) error {
	v.Status = "MsgStatusPending"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMsgStatusPending performs a merge with any union data inside the MsgStatus, using the provided MsgStatusPending
func (t *MsgStatus) MergeMsgStatusPending(v MsgStatusPending) error {
	v.Status = "MsgStatusPending"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMsgStatusSigned returns the union data inside the MsgStatus as a MsgStatusSigned
func (t MsgStatus) AsMsgStatusSigned() (MsgStatusSigned, error) {
	var body MsgStatusSigned
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMsgStatusSigned overwrites any union data inside the MsgStatus as the provided MsgStatusSigned
func (t *MsgStatus) FromMsgStatusSigned(v MsgStatusSigned) error {
	v.Status = "MsgStatusSigned"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMsgStatusSigned performs a merge with any union data inside the MsgStatus, using the provided MsgStatusSigned
func (t *MsgStatus) MergeMsgStatusSigned(v MsgStatusSigned) error {
	v.Status = "MsgStatusSigned"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMsgStatusRejected returns the union data inside the MsgStatus as a MsgStatusRejected
func (t MsgStatus) AsMsgStatusRejected() (MsgStatusRejected, error) {
	var body MsgStatusRejected
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMsgStatusRejected overwrites any union data inside the MsgStatus as the provided MsgStatusRejected
func (t *MsgStatus) FromMsgStatusRejected(v MsgStatusRejected) error {
	v.Status = "MsgStatusRejected"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMsgStatusRejected performs a merge with any union data inside the MsgStatus, using the provided MsgStatusRejected
func (t *MsgStatus) MergeMsgStatusRejected(v MsgStatusRejected) error {
	v.Status = "MsgStatusRejected"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MsgStatus) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"status"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t MsgStatus) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "MsgStatusPending":
		return t.AsMsgStatusPending()
	case "MsgStatusRejected":
		return t.AsMsgStatusRejected()
	case "MsgStatusSigned":
		return t.AsMsgStatusSigned()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t MsgStatus) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MsgStatus) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrgEventFilterAll returns the union data inside the OrgEventFilter as a OrgEventFilterAll
func (t OrgEventFilter) AsOrgEventFilterAll() (OrgEventFilterAll, error) {
	var body OrgEventFilterAll
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrgEventFilterAll overwrites any union data inside the OrgEventFilter as the provided OrgEventFilterAll
func (t *OrgEventFilter) FromOrgEventFilterAll(v OrgEventFilterAll) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrgEventFilterAll performs a merge with any union data inside the OrgEventFilter, using the provided OrgEventFilterAll
func (t *OrgEventFilter) MergeOrgEventFilterAll(v OrgEventFilterAll) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrgEventFilterAllExcept returns the union data inside the OrgEventFilter as a OrgEventFilterAllExcept
func (t OrgEventFilter) AsOrgEventFilterAllExcept() (OrgEventFilterAllExcept, error) {
	var body OrgEventFilterAllExcept
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrgEventFilterAllExcept overwrites any union data inside the OrgEventFilter as the provided OrgEventFilterAllExcept
func (t *OrgEventFilter) FromOrgEventFilterAllExcept(v OrgEventFilterAllExcept) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrgEventFilterAllExcept performs a merge with any union data inside the OrgEventFilter, using the provided OrgEventFilterAllExcept
func (t *OrgEventFilter) MergeOrgEventFilterAllExcept(v OrgEventFilterAllExcept) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrgEventFilterOneOf returns the union data inside the OrgEventFilter as a OrgEventFilterOneOf
func (t OrgEventFilter) AsOrgEventFilterOneOf() (OrgEventFilterOneOf, error) {
	var body OrgEventFilterOneOf
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrgEventFilterOneOf overwrites any union data inside the OrgEventFilter as the provided OrgEventFilterOneOf
func (t *OrgEventFilter) FromOrgEventFilterOneOf(v OrgEventFilterOneOf) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrgEventFilterOneOf performs a merge with any union data inside the OrgEventFilter, using the provided OrgEventFilterOneOf
func (t *OrgEventFilter) MergeOrgEventFilterOneOf(v OrgEventFilterOneOf) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrgEventFilter) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrgEventFilter) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrgMetricBillingEvent returns the union data inside the OrgMetric as a OrgMetricBillingEvent
func (t OrgMetric) AsOrgMetricBillingEvent() (OrgMetricBillingEvent, error) {
	var body OrgMetricBillingEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrgMetricBillingEvent overwrites any union data inside the OrgMetric as the provided OrgMetricBillingEvent
func (t *OrgMetric) FromOrgMetricBillingEvent(v OrgMetricBillingEvent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrgMetricBillingEvent performs a merge with any union data inside the OrgMetric, using the provided OrgMetricBillingEvent
func (t *OrgMetric) MergeOrgMetricBillingEvent(v OrgMetricBillingEvent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrgMetricOidcLoginEvent returns the union data inside the OrgMetric as a OrgMetricOidcLoginEvent
func (t OrgMetric) AsOrgMetricOidcLoginEvent() (OrgMetricOidcLoginEvent, error) {
	var body OrgMetricOidcLoginEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrgMetricOidcLoginEvent overwrites any union data inside the OrgMetric as the provided OrgMetricOidcLoginEvent
func (t *OrgMetric) FromOrgMetricOidcLoginEvent(v OrgMetricOidcLoginEvent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrgMetricOidcLoginEvent performs a merge with any union data inside the OrgMetric, using the provided OrgMetricOidcLoginEvent
func (t *OrgMetric) MergeOrgMetricOidcLoginEvent(v OrgMetricOidcLoginEvent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrgMetricSignEvent returns the union data inside the OrgMetric as a OrgMetricSignEvent
func (t OrgMetric) AsOrgMetricSignEvent() (OrgMetricSignEvent, error) {
	var body OrgMetricSignEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrgMetricSignEvent overwrites any union data inside the OrgMetric as the provided OrgMetricSignEvent
func (t *OrgMetric) FromOrgMetricSignEvent(v OrgMetricSignEvent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrgMetricSignEvent performs a merge with any union data inside the OrgMetric, using the provided OrgMetricSignEvent
func (t *OrgMetric) MergeOrgMetricSignEvent(v OrgMetricSignEvent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrgMetricUserCount returns the union data inside the OrgMetric as a OrgMetricUserCount
func (t OrgMetric) AsOrgMetricUserCount() (OrgMetricUserCount, error) {
	var body OrgMetricUserCount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrgMetricUserCount overwrites any union data inside the OrgMetric as the provided OrgMetricUserCount
func (t *OrgMetric) FromOrgMetricUserCount(v OrgMetricUserCount) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrgMetricUserCount performs a merge with any union data inside the OrgMetric, using the provided OrgMetricUserCount
func (t *OrgMetric) MergeOrgMetricUserCount(v OrgMetricUserCount) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrgMetricKeyCount returns the union data inside the OrgMetric as a OrgMetricKeyCount
func (t OrgMetric) AsOrgMetricKeyCount() (OrgMetricKeyCount, error) {
	var body OrgMetricKeyCount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrgMetricKeyCount overwrites any union data inside the OrgMetric as the provided OrgMetricKeyCount
func (t *OrgMetric) FromOrgMetricKeyCount(v OrgMetricKeyCount) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrgMetricKeyCount performs a merge with any union data inside the OrgMetric, using the provided OrgMetricKeyCount
func (t *OrgMetric) MergeOrgMetricKeyCount(v OrgMetricKeyCount) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrgMetric) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrgMetric) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPolicyAttachedToIdObject returns the union data inside the PolicyAttachedToId as a PolicyAttachedToIdObject
func (t PolicyAttachedToId) AsPolicyAttachedToIdObject() (PolicyAttachedToIdObject, error) {
	var body PolicyAttachedToIdObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPolicyAttachedToIdObject overwrites any union data inside the PolicyAttachedToId as the provided PolicyAttachedToIdObject
func (t *PolicyAttachedToId) FromPolicyAttachedToIdObject(v PolicyAttachedToIdObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePolicyAttachedToIdObject performs a merge with any union data inside the PolicyAttachedToId, using the provided PolicyAttachedToIdObject
func (t *PolicyAttachedToId) MergePolicyAttachedToIdObject(v PolicyAttachedToIdObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPolicyAttachedToIdkeyId returns the union data inside the PolicyAttachedToId as a PolicyAttachedToIdkeyId
func (t PolicyAttachedToId) AsPolicyAttachedToIdkeyId() (PolicyAttachedToIdkeyId, error) {
	var body PolicyAttachedToIdkeyId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPolicyAttachedToIdkeyId overwrites any union data inside the PolicyAttachedToId as the provided PolicyAttachedToIdkeyId
func (t *PolicyAttachedToId) FromPolicyAttachedToIdkeyId(v PolicyAttachedToIdkeyId) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePolicyAttachedToIdkeyId performs a merge with any union data inside the PolicyAttachedToId, using the provided PolicyAttachedToIdkeyId
func (t *PolicyAttachedToId) MergePolicyAttachedToIdkeyId(v PolicyAttachedToIdkeyId) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPolicyAttachedToIdroleId returns the union data inside the PolicyAttachedToId as a PolicyAttachedToIdroleId
func (t PolicyAttachedToId) AsPolicyAttachedToIdroleId() (PolicyAttachedToIdroleId, error) {
	var body PolicyAttachedToIdroleId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPolicyAttachedToIdroleId overwrites any union data inside the PolicyAttachedToId as the provided PolicyAttachedToIdroleId
func (t *PolicyAttachedToId) FromPolicyAttachedToIdroleId(v PolicyAttachedToIdroleId) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePolicyAttachedToIdroleId performs a merge with any union data inside the PolicyAttachedToId, using the provided PolicyAttachedToIdroleId
func (t *PolicyAttachedToId) MergePolicyAttachedToIdroleId(v PolicyAttachedToIdroleId) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PolicyAttachedToId) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PolicyAttachedToId) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPolicyErrorOwnCodes returns the union data inside the PolicyErrorCode as a PolicyErrorOwnCodes
func (t PolicyErrorCode) AsPolicyErrorOwnCodes() (PolicyErrorOwnCodes, error) {
	var body PolicyErrorOwnCodes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPolicyErrorOwnCodes overwrites any union data inside the PolicyErrorCode as the provided PolicyErrorOwnCodes
func (t *PolicyErrorCode) FromPolicyErrorOwnCodes(v PolicyErrorOwnCodes) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePolicyErrorOwnCodes performs a merge with any union data inside the PolicyErrorCode, using the provided PolicyErrorOwnCodes
func (t *PolicyErrorCode) MergePolicyErrorOwnCodes(v PolicyErrorOwnCodes) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmTxDepositErrorCode returns the union data inside the PolicyErrorCode as a EvmTxDepositErrorCode
func (t PolicyErrorCode) AsEvmTxDepositErrorCode() (EvmTxDepositErrorCode, error) {
	var body EvmTxDepositErrorCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmTxDepositErrorCode overwrites any union data inside the PolicyErrorCode as the provided EvmTxDepositErrorCode
func (t *PolicyErrorCode) FromEvmTxDepositErrorCode(v EvmTxDepositErrorCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmTxDepositErrorCode performs a merge with any union data inside the PolicyErrorCode, using the provided EvmTxDepositErrorCode
func (t *PolicyErrorCode) MergeEvmTxDepositErrorCode(v EvmTxDepositErrorCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PolicyErrorCode) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PolicyErrorCode) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPreconditionErrorOwnCodes returns the union data inside the PreconditionErrorCode as a PreconditionErrorOwnCodes
func (t PreconditionErrorCode) AsPreconditionErrorOwnCodes() (PreconditionErrorOwnCodes, error) {
	var body PreconditionErrorOwnCodes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreconditionErrorOwnCodes overwrites any union data inside the PreconditionErrorCode as the provided PreconditionErrorOwnCodes
func (t *PreconditionErrorCode) FromPreconditionErrorOwnCodes(v PreconditionErrorOwnCodes) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreconditionErrorOwnCodes performs a merge with any union data inside the PreconditionErrorCode, using the provided PreconditionErrorOwnCodes
func (t *PreconditionErrorCode) MergePreconditionErrorOwnCodes(v PreconditionErrorOwnCodes) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPolicyErrorCode returns the union data inside the PreconditionErrorCode as a PolicyErrorCode
func (t PreconditionErrorCode) AsPolicyErrorCode() (PolicyErrorCode, error) {
	var body PolicyErrorCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPolicyErrorCode overwrites any union data inside the PreconditionErrorCode as the provided PolicyErrorCode
func (t *PreconditionErrorCode) FromPolicyErrorCode(v PolicyErrorCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePolicyErrorCode performs a merge with any union data inside the PreconditionErrorCode, using the provided PolicyErrorCode
func (t *PreconditionErrorCode) MergePolicyErrorCode(v PolicyErrorCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PreconditionErrorCode) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PreconditionErrorCode) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPrevOutputsOne returns the union data inside the PrevOutputs as a PrevOutputsOne
func (t PrevOutputs) AsPrevOutputsOne() (PrevOutputsOne, error) {
	var body PrevOutputsOne
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPrevOutputsOne overwrites any union data inside the PrevOutputs as the provided PrevOutputsOne
func (t *PrevOutputs) FromPrevOutputsOne(v PrevOutputsOne) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePrevOutputsOne performs a merge with any union data inside the PrevOutputs, using the provided PrevOutputsOne
func (t *PrevOutputs) MergePrevOutputsOne(v PrevOutputsOne) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPrevOutputsAll returns the union data inside the PrevOutputs as a PrevOutputsAll
func (t PrevOutputs) AsPrevOutputsAll() (PrevOutputsAll, error) {
	var body PrevOutputsAll
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPrevOutputsAll overwrites any union data inside the PrevOutputs as the provided PrevOutputsAll
func (t *PrevOutputs) FromPrevOutputsAll(v PrevOutputsAll) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePrevOutputsAll performs a merge with any union data inside the PrevOutputs, using the provided PrevOutputsAll
func (t *PrevOutputs) MergePrevOutputsAll(v PrevOutputsAll) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PrevOutputs) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PrevOutputs) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAuthenticatorAttestationResponse returns the union data inside the PublicKeyCredential_Response as a AuthenticatorAttestationResponse
func (t PublicKeyCredential_Response) AsAuthenticatorAttestationResponse() (AuthenticatorAttestationResponse, error) {
	var body AuthenticatorAttestationResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAuthenticatorAttestationResponse overwrites any union data inside the PublicKeyCredential_Response as the provided AuthenticatorAttestationResponse
func (t *PublicKeyCredential_Response) FromAuthenticatorAttestationResponse(v AuthenticatorAttestationResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAuthenticatorAttestationResponse performs a merge with any union data inside the PublicKeyCredential_Response, using the provided AuthenticatorAttestationResponse
func (t *PublicKeyCredential_Response) MergeAuthenticatorAttestationResponse(v AuthenticatorAttestationResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAuthenticatorAssertionResponse returns the union data inside the PublicKeyCredential_Response as a AuthenticatorAssertionResponse
func (t PublicKeyCredential_Response) AsAuthenticatorAssertionResponse() (AuthenticatorAssertionResponse, error) {
	var body AuthenticatorAssertionResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAuthenticatorAssertionResponse overwrites any union data inside the PublicKeyCredential_Response as the provided AuthenticatorAssertionResponse
func (t *PublicKeyCredential_Response) FromAuthenticatorAssertionResponse(v AuthenticatorAssertionResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAuthenticatorAssertionResponse performs a merge with any union data inside the PublicKeyCredential_Response, using the provided AuthenticatorAssertionResponse
func (t *PublicKeyCredential_Response) MergeAuthenticatorAssertionResponse(v AuthenticatorAssertionResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PublicKeyCredential_Response) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PublicKeyCredential_Response) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsExplicitScopes returns the union data inside the Scope as a ExplicitScopes
func (t ScopeType) AsExplicitScopes() (ExplicitScopes, error) {
	var body ExplicitScopes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExplicitScopes overwrites any union data inside the Scope as the provided ExplicitScopes
func (t *ScopeType) FromExplicitScopes(v ExplicitScopes) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExplicitScopes performs a merge with any union data inside the Scope, using the provided ExplicitScopes
func (t *ScopeType) MergeExplicitScopes(v ExplicitScopes) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOtherScopes returns the union data inside the Scope as a OtherScopes
func (t ScopeType) AsOtherScopes() (OtherScopes, error) {
	var body OtherScopes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOtherScopes overwrites any union data inside the Scope as the provided OtherScopes
func (t *ScopeType) FromOtherScopes(v OtherScopes) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOtherScopes performs a merge with any union data inside the Scope, using the provided OtherScopes
func (t *ScopeType) MergeOtherScopes(v OtherScopes) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ScopeType) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ScopeType) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsScopeSetAll returns the union data inside the ScopeSet as a ScopeSetAll
func (t ScopeSet) AsScopeSetAll() (ScopeSetAll, error) {
	var body ScopeSetAll
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScopeSetAll overwrites any union data inside the ScopeSet as the provided ScopeSetAll
func (t *ScopeSet) FromScopeSetAll(v ScopeSetAll) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScopeSetAll performs a merge with any union data inside the ScopeSet, using the provided ScopeSetAll
func (t *ScopeSet) MergeScopeSetAll(v ScopeSetAll) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScopeSetAllExcept returns the union data inside the ScopeSet as a ScopeSetAllExcept
func (t ScopeSet) AsScopeSetAllExcept() (ScopeSetAllExcept, error) {
	var body ScopeSetAllExcept
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScopeSetAllExcept overwrites any union data inside the ScopeSet as the provided ScopeSetAllExcept
func (t *ScopeSet) FromScopeSetAllExcept(v ScopeSetAllExcept) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScopeSetAllExcept performs a merge with any union data inside the ScopeSet, using the provided ScopeSetAllExcept
func (t *ScopeSet) MergeScopeSetAllExcept(v ScopeSetAllExcept) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScopeSetAllOf returns the union data inside the ScopeSet as a ScopeSetAllOf
func (t ScopeSet) AsScopeSetAllOf() (ScopeSetAllOf, error) {
	var body ScopeSetAllOf
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScopeSetAllOf overwrites any union data inside the ScopeSet as the provided ScopeSetAllOf
func (t *ScopeSet) FromScopeSetAllOf(v ScopeSetAllOf) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScopeSetAllOf performs a merge with any union data inside the ScopeSet, using the provided ScopeSetAllOf
func (t *ScopeSet) MergeScopeSetAllOf(v ScopeSetAllOf) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ScopeSet) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ScopeSet) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSecretValueString returns the union data inside the SecretValue as a SecretValueString
func (t SecretValue) AsSecretValueString() (SecretValueString, error) {
	var body SecretValueString
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecretValueString overwrites any union data inside the SecretValue as the provided SecretValueString
func (t *SecretValue) FromSecretValueString(v SecretValueString) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecretValueString performs a merge with any union data inside the SecretValue, using the provided SecretValueString
func (t *SecretValue) MergeSecretValueString(v SecretValueString) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecretValueObject returns the union data inside the SecretValue as a SecretValueObject
func (t SecretValue) AsSecretValueObject() (SecretValueObject, error) {
	var body SecretValueObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecretValueObject overwrites any union data inside the SecretValue as the provided SecretValueObject
func (t *SecretValue) FromSecretValueObject(v SecretValueObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecretValueObject performs a merge with any union data inside the SecretValue, using the provided SecretValueObject
func (t *SecretValue) MergeSecretValueObject(v SecretValueObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SecretValue) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SecretValue) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSignerErrorOwnCodes returns the union data inside the SignerErrorCode as a SignerErrorOwnCodes
func (t SignerErrorCode) AsSignerErrorOwnCodes() (SignerErrorOwnCodes, error) {
	var body SignerErrorOwnCodes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSignerErrorOwnCodes overwrites any union data inside the SignerErrorCode as the provided SignerErrorOwnCodes
func (t *SignerErrorCode) FromSignerErrorOwnCodes(v SignerErrorOwnCodes) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSignerErrorOwnCodes performs a merge with any union data inside the SignerErrorCode, using the provided SignerErrorOwnCodes
func (t *SignerErrorCode) MergeSignerErrorOwnCodes(v SignerErrorOwnCodes) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAcceptedValueCode returns the union data inside the SignerErrorCode as a AcceptedValueCode
func (t SignerErrorCode) AsAcceptedValueCode() (AcceptedValueCode, error) {
	var body AcceptedValueCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAcceptedValueCode overwrites any union data inside the SignerErrorCode as the provided AcceptedValueCode
func (t *SignerErrorCode) FromAcceptedValueCode(v AcceptedValueCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAcceptedValueCode performs a merge with any union data inside the SignerErrorCode, using the provided AcceptedValueCode
func (t *SignerErrorCode) MergeAcceptedValueCode(v AcceptedValueCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBadRequestErrorCode returns the union data inside the SignerErrorCode as a BadRequestErrorCode
func (t SignerErrorCode) AsBadRequestErrorCode() (BadRequestErrorCode, error) {
	var body BadRequestErrorCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBadRequestErrorCode overwrites any union data inside the SignerErrorCode as the provided BadRequestErrorCode
func (t *SignerErrorCode) FromBadRequestErrorCode(v BadRequestErrorCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBadRequestErrorCode performs a merge with any union data inside the SignerErrorCode, using the provided BadRequestErrorCode
func (t *SignerErrorCode) MergeBadRequestErrorCode(v BadRequestErrorCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBadGatewayErrorCode returns the union data inside the SignerErrorCode as a BadGatewayErrorCode
func (t SignerErrorCode) AsBadGatewayErrorCode() (BadGatewayErrorCode, error) {
	var body BadGatewayErrorCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBadGatewayErrorCode overwrites any union data inside the SignerErrorCode as the provided BadGatewayErrorCode
func (t *SignerErrorCode) FromBadGatewayErrorCode(v BadGatewayErrorCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBadGatewayErrorCode performs a merge with any union data inside the SignerErrorCode, using the provided BadGatewayErrorCode
func (t *SignerErrorCode) MergeBadGatewayErrorCode(v BadGatewayErrorCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNotFoundErrorCode returns the union data inside the SignerErrorCode as a NotFoundErrorCode
func (t SignerErrorCode) AsNotFoundErrorCode() (NotFoundErrorCode, error) {
	var body NotFoundErrorCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNotFoundErrorCode overwrites any union data inside the SignerErrorCode as the provided NotFoundErrorCode
func (t *SignerErrorCode) FromNotFoundErrorCode(v NotFoundErrorCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNotFoundErrorCode performs a merge with any union data inside the SignerErrorCode, using the provided NotFoundErrorCode
func (t *SignerErrorCode) MergeNotFoundErrorCode(v NotFoundErrorCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenErrorCode returns the union data inside the SignerErrorCode as a ForbiddenErrorCode
func (t SignerErrorCode) AsForbiddenErrorCode() (ForbiddenErrorCode, error) {
	var body ForbiddenErrorCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenErrorCode overwrites any union data inside the SignerErrorCode as the provided ForbiddenErrorCode
func (t *SignerErrorCode) FromForbiddenErrorCode(v ForbiddenErrorCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenErrorCode performs a merge with any union data inside the SignerErrorCode, using the provided ForbiddenErrorCode
func (t *SignerErrorCode) MergeForbiddenErrorCode(v ForbiddenErrorCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedErrorCode returns the union data inside the SignerErrorCode as a UnauthorizedErrorCode
func (t SignerErrorCode) AsUnauthorizedErrorCode() (UnauthorizedErrorCode, error) {
	var body UnauthorizedErrorCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedErrorCode overwrites any union data inside the SignerErrorCode as the provided UnauthorizedErrorCode
func (t *SignerErrorCode) FromUnauthorizedErrorCode(v UnauthorizedErrorCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedErrorCode performs a merge with any union data inside the SignerErrorCode, using the provided UnauthorizedErrorCode
func (t *SignerErrorCode) MergeUnauthorizedErrorCode(v UnauthorizedErrorCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPreconditionErrorCode returns the union data inside the SignerErrorCode as a PreconditionErrorCode
func (t SignerErrorCode) AsPreconditionErrorCode() (PreconditionErrorCode, error) {
	var body PreconditionErrorCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreconditionErrorCode overwrites any union data inside the SignerErrorCode as the provided PreconditionErrorCode
func (t *SignerErrorCode) FromPreconditionErrorCode(v PreconditionErrorCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreconditionErrorCode performs a merge with any union data inside the SignerErrorCode, using the provided PreconditionErrorCode
func (t *SignerErrorCode) MergePreconditionErrorCode(v PreconditionErrorCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTimeoutErrorCode returns the union data inside the SignerErrorCode as a TimeoutErrorCode
func (t SignerErrorCode) AsTimeoutErrorCode() (TimeoutErrorCode, error) {
	var body TimeoutErrorCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTimeoutErrorCode overwrites any union data inside the SignerErrorCode as the provided TimeoutErrorCode
func (t *SignerErrorCode) FromTimeoutErrorCode(v TimeoutErrorCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTimeoutErrorCode performs a merge with any union data inside the SignerErrorCode, using the provided TimeoutErrorCode
func (t *SignerErrorCode) MergeTimeoutErrorCode(v TimeoutErrorCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConflictErrorCode returns the union data inside the SignerErrorCode as a ConflictErrorCode
func (t SignerErrorCode) AsConflictErrorCode() (ConflictErrorCode, error) {
	var body ConflictErrorCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConflictErrorCode overwrites any union data inside the SignerErrorCode as the provided ConflictErrorCode
func (t *SignerErrorCode) FromConflictErrorCode(v ConflictErrorCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConflictErrorCode performs a merge with any union data inside the SignerErrorCode, using the provided ConflictErrorCode
func (t *SignerErrorCode) MergeConflictErrorCode(v ConflictErrorCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInternalErrorCode returns the union data inside the SignerErrorCode as a InternalErrorCode
func (t SignerErrorCode) AsInternalErrorCode() (InternalErrorCode, error) {
	var body InternalErrorCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInternalErrorCode overwrites any union data inside the SignerErrorCode as the provided InternalErrorCode
func (t *SignerErrorCode) FromInternalErrorCode(v InternalErrorCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInternalErrorCode performs a merge with any union data inside the SignerErrorCode, using the provided InternalErrorCode
func (t *SignerErrorCode) MergeInternalErrorCode(v InternalErrorCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SignerErrorCode) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SignerErrorCode) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTransactionAndStatus0 returns the union data inside the TransactionAndStatus as a TransactionAndStatus0
func (t TransactionAndStatus) AsTransactionAndStatus0() (TransactionAndStatus0, error) {
	var body TransactionAndStatus0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTransactionAndStatus0 overwrites any union data inside the TransactionAndStatus as the provided TransactionAndStatus0
func (t *TransactionAndStatus) FromTransactionAndStatus0(v TransactionAndStatus0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTransactionAndStatus0 performs a merge with any union data inside the TransactionAndStatus, using the provided TransactionAndStatus0
func (t *TransactionAndStatus) MergeTransactionAndStatus0(v TransactionAndStatus0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTransactionAndStatus1 returns the union data inside the TransactionAndStatus as a TransactionAndStatus1
func (t TransactionAndStatus) AsTransactionAndStatus1() (TransactionAndStatus1, error) {
	var body TransactionAndStatus1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTransactionAndStatus1 overwrites any union data inside the TransactionAndStatus as the provided TransactionAndStatus1
func (t *TransactionAndStatus) FromTransactionAndStatus1(v TransactionAndStatus1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTransactionAndStatus1 performs a merge with any union data inside the TransactionAndStatus, using the provided TransactionAndStatus1
func (t *TransactionAndStatus) MergeTransactionAndStatus1(v TransactionAndStatus1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TransactionAndStatus) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Hash != nil {
		object["hash"], err = json.Marshal(t.Hash)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'hash': %w", err)
		}
	}

	object["id"], err = json.Marshal(t.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if t.Nonce != nil {
		object["nonce"], err = json.Marshal(t.Nonce)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nonce': %w", err)
		}
	}

	if t.SignedRawTransaction != nil {
		object["signedRawTransaction"], err = json.Marshal(t.SignedRawTransaction)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'signedRawTransaction': %w", err)
		}
	}

	object["status"], err = json.Marshal(t.Status)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'status': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *TransactionAndStatus) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["hash"]; found {
		err = json.Unmarshal(raw, &t.Hash)
		if err != nil {
			return fmt.Errorf("error reading 'hash': %w", err)
		}
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["nonce"]; found {
		err = json.Unmarshal(raw, &t.Nonce)
		if err != nil {
			return fmt.Errorf("error reading 'nonce': %w", err)
		}
	}

	if raw, found := object["signedRawTransaction"]; found {
		err = json.Unmarshal(raw, &t.SignedRawTransaction)
		if err != nil {
			return fmt.Errorf("error reading 'signedRawTransaction': %w", err)
		}
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &t.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
	}

	return err
}

// AsTxStatusPending returns the union data inside the TxStatus as a TxStatusPending
func (t TxStatus) AsTxStatusPending() (TxStatusPending, error) {
	var body TxStatusPending
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTxStatusPending overwrites any union data inside the TxStatus as the provided TxStatusPending
func (t *TxStatus) FromTxStatusPending(v TxStatusPending) error {
	v.Status = "TxStatusPending"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTxStatusPending performs a merge with any union data inside the TxStatus, using the provided TxStatusPending
func (t *TxStatus) MergeTxStatusPending(v TxStatusPending) error {
	v.Status = "TxStatusPending"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTxStatusSigned returns the union data inside the TxStatus as a TxStatusSigned
func (t TxStatus) AsTxStatusSigned() (TxStatusSigned, error) {
	var body TxStatusSigned
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTxStatusSigned overwrites any union data inside the TxStatus as the provided TxStatusSigned
func (t *TxStatus) FromTxStatusSigned(v TxStatusSigned) error {
	v.Status = "TxStatusSigned"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTxStatusSigned performs a merge with any union data inside the TxStatus, using the provided TxStatusSigned
func (t *TxStatus) MergeTxStatusSigned(v TxStatusSigned) error {
	v.Status = "TxStatusSigned"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTxStatusRejected returns the union data inside the TxStatus as a TxStatusRejected
func (t TxStatus) AsTxStatusRejected() (TxStatusRejected, error) {
	var body TxStatusRejected
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTxStatusRejected overwrites any union data inside the TxStatus as the provided TxStatusRejected
func (t *TxStatus) FromTxStatusRejected(v TxStatusRejected) error {
	v.Status = "TxStatusRejected"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTxStatusRejected performs a merge with any union data inside the TxStatus, using the provided TxStatusRejected
func (t *TxStatus) MergeTxStatusRejected(v TxStatusRejected) error {
	v.Status = "TxStatusRejected"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TxStatus) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"status"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t TxStatus) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "TxStatusPending":
		return t.AsTxStatusPending()
	case "TxStatusRejected":
		return t.AsTxStatusRejected()
	case "TxStatusSigned":
		return t.AsTxStatusSigned()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t TxStatus) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TxStatus) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTypedDataString returns the union data inside the TypedDataDomainSalt as a TypedDataString
func (t TypedDataDomainSalt) AsTypedDataString() (TypedDataString, error) {
	var body TypedDataString
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTypedDataString overwrites any union data inside the TypedDataDomainSalt as the provided TypedDataString
func (t *TypedDataDomainSalt) FromTypedDataString(v TypedDataString) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTypedDataString performs a merge with any union data inside the TypedDataDomainSalt, using the provided TypedDataString
func (t *TypedDataDomainSalt) MergeTypedDataString(v TypedDataString) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTypedDataArray returns the union data inside the TypedDataDomainSalt as a TypedDataArray
func (t TypedDataDomainSalt) AsTypedDataArray() (TypedDataArray, error) {
	var body TypedDataArray
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTypedDataArray overwrites any union data inside the TypedDataDomainSalt as the provided TypedDataArray
func (t *TypedDataDomainSalt) FromTypedDataArray(v TypedDataArray) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTypedDataArray performs a merge with any union data inside the TypedDataDomainSalt, using the provided TypedDataArray
func (t *TypedDataDomainSalt) MergeTypedDataArray(v TypedDataArray) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TypedDataDomainSalt) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TypedDataDomainSalt) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTypedTransactionLegacy returns the union data inside the TypedTransaction as a TypedTransactionLegacy
func (t TypedTransaction) AsTypedTransactionLegacy() (TypedTransactionLegacy, error) {
	var body TypedTransactionLegacy
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTypedTransactionLegacy overwrites any union data inside the TypedTransaction as the provided TypedTransactionLegacy
func (t *TypedTransaction) FromTypedTransactionLegacy(v TypedTransactionLegacy) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTypedTransactionLegacy performs a merge with any union data inside the TypedTransaction, using the provided TypedTransactionLegacy
func (t *TypedTransaction) MergeTypedTransactionLegacy(v TypedTransactionLegacy) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTypedTransactionEip1559 returns the union data inside the TypedTransaction as a TypedTransactionEip1559
func (t TypedTransaction) AsTypedTransactionEip1559() (TypedTransactionEip1559, error) {
	var body TypedTransactionEip1559
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTypedTransactionEip1559 overwrites any union data inside the TypedTransaction as the provided TypedTransactionEip1559
func (t *TypedTransaction) FromTypedTransactionEip1559(v TypedTransactionEip1559) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTypedTransactionEip1559 performs a merge with any union data inside the TypedTransaction, using the provided TypedTransactionEip1559
func (t *TypedTransaction) MergeTypedTransactionEip1559(v TypedTransactionEip1559) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TypedTransaction) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TypedTransaction) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsWasmPolicyResponseAllow returns the union data inside the WasmPolicyResponse as a WasmPolicyResponseAllow
func (t WasmPolicyResponse) AsWasmPolicyResponseAllow() (WasmPolicyResponseAllow, error) {
	var body WasmPolicyResponseAllow
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWasmPolicyResponseAllow overwrites any union data inside the WasmPolicyResponse as the provided WasmPolicyResponseAllow
func (t *WasmPolicyResponse) FromWasmPolicyResponseAllow(v WasmPolicyResponseAllow) error {
	v.Response = "WasmPolicyResponseAllow"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWasmPolicyResponseAllow performs a merge with any union data inside the WasmPolicyResponse, using the provided WasmPolicyResponseAllow
func (t *WasmPolicyResponse) MergeWasmPolicyResponseAllow(v WasmPolicyResponseAllow) error {
	v.Response = "WasmPolicyResponseAllow"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWasmPolicyResponseDeny returns the union data inside the WasmPolicyResponse as a WasmPolicyResponseDeny
func (t WasmPolicyResponse) AsWasmPolicyResponseDeny() (WasmPolicyResponseDeny, error) {
	var body WasmPolicyResponseDeny
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWasmPolicyResponseDeny overwrites any union data inside the WasmPolicyResponse as the provided WasmPolicyResponseDeny
func (t *WasmPolicyResponse) FromWasmPolicyResponseDeny(v WasmPolicyResponseDeny) error {
	v.Response = "WasmPolicyResponseDeny"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWasmPolicyResponseDeny performs a merge with any union data inside the WasmPolicyResponse, using the provided WasmPolicyResponseDeny
func (t *WasmPolicyResponse) MergeWasmPolicyResponseDeny(v WasmPolicyResponseDeny) error {
	v.Response = "WasmPolicyResponseDeny"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWasmPolicyResponseError returns the union data inside the WasmPolicyResponse as a WasmPolicyResponseError
func (t WasmPolicyResponse) AsWasmPolicyResponseError() (WasmPolicyResponseError, error) {
	var body WasmPolicyResponseError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWasmPolicyResponseError overwrites any union data inside the WasmPolicyResponse as the provided WasmPolicyResponseError
func (t *WasmPolicyResponse) FromWasmPolicyResponseError(v WasmPolicyResponseError) error {
	v.Response = "WasmPolicyResponseError"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWasmPolicyResponseError performs a merge with any union data inside the WasmPolicyResponse, using the provided WasmPolicyResponseError
func (t *WasmPolicyResponse) MergeWasmPolicyResponseError(v WasmPolicyResponseError) error {
	v.Response = "WasmPolicyResponseError"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t WasmPolicyResponse) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"response"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t WasmPolicyResponse) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "WasmPolicyResponseAllow":
		return t.AsWasmPolicyResponseAllow()
	case "WasmPolicyResponseDeny":
		return t.AsWasmPolicyResponseDeny()
	case "WasmPolicyResponseError":
		return t.AsWasmPolicyResponseError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t WasmPolicyResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *WasmPolicyResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
