// Package models provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package models

import (
	"encoding/json"
	"errors"
	"fmt"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	OidcScopes       = "Oidc.Scopes"
	SignerAuthScopes = "SignerAuth.Scopes"
)

// Defines values for AcceptedValueCode.
const (
	MfaRequired AcceptedValueCode = "MfaRequired"
)

// Defines values for AccessModel.
const (
	AccessModelOrg  AccessModel = "Org"
	AccessModelUser AccessModel = "User"
)

// Defines values for AlertKind.
const (
	AlertKindBabylonEotsConcurrentSigning AlertKind = "BabylonEotsConcurrentSigning"
	AlertKindEth2ConcurrentBlockSigning   AlertKind = "Eth2ConcurrentBlockSigning"
	AlertKindPolicyChanges                AlertKind = "PolicyChanges"
)

// Defines values for AttestationConveyancePreference.
const (
	AttestationConveyancePreferenceDirect     AttestationConveyancePreference = "direct"
	AttestationConveyancePreferenceEnterprise AttestationConveyancePreference = "enterprise"
	AttestationConveyancePreferenceIndirect   AttestationConveyancePreference = "indirect"
	AttestationConveyancePreferenceNone       AttestationConveyancePreference = "none"
)

// Defines values for AuthSourceKind.
const (
	Oidc     AuthSourceKind = "oidc"
	Password AuthSourceKind = "password"
)

// Defines values for AuthenticatorAttachment.
const (
	CrossPlatform AuthenticatorAttachment = "cross-platform"
	Platform      AuthenticatorAttachment = "platform"
)

// Defines values for AuthenticatorTransport.
const (
	Ble      AuthenticatorTransport = "ble"
	Internal AuthenticatorTransport = "internal"
	Nfc      AuthenticatorTransport = "nfc"
	Usb      AuthenticatorTransport = "usb"
)

// Defines values for BabylonNetworkId.
const (
	Bbn1 BabylonNetworkId = "bbn1"
	Bbt4 BabylonNetworkId = "bbt4"
	Bbt5 BabylonNetworkId = "bbt5"
)

// Defines values for BabylonStakingRequestDepositAction.
const (
	Deposit BabylonStakingRequestDepositAction = "deposit"
)

// Defines values for BabylonStakingRequestEarlyUnbondAction.
const (
	EarlyUnbond BabylonStakingRequestEarlyUnbondAction = "early_unbond"
)

// Defines values for BabylonStakingRequestSlashDepositAction.
const (
	SlashDeposit BabylonStakingRequestSlashDepositAction = "slash_deposit"
)

// Defines values for BabylonStakingRequestSlashEarlyUnbondAction.
const (
	SlashEarlyUnbond BabylonStakingRequestSlashEarlyUnbondAction = "slash_early_unbond"
)

// Defines values for BabylonStakingRequestWithdrawEarlyUnbondAction.
const (
	WithdrawEarlyUnbond BabylonStakingRequestWithdrawEarlyUnbondAction = "withdraw_early_unbond"
)

// Defines values for BabylonStakingRequestWithdrawSlashingAction.
const (
	WithdrawSlashing BabylonStakingRequestWithdrawSlashingAction = "withdraw_slashing"
)

// Defines values for BabylonStakingRequestWithdrawTimelockAction.
const (
	WithdrawTimelock BabylonStakingRequestWithdrawTimelockAction = "withdraw_timelock"
)

// Defines values for BadGatewayErrorCode.
const (
	CallWebhookError                 BadGatewayErrorCode = "CallWebhookError"
	EsploraApiError                  BadGatewayErrorCode = "EsploraApiError"
	OAuthProviderError               BadGatewayErrorCode = "OAuthProviderError"
	OidcDisoveryFailed               BadGatewayErrorCode = "OidcDisoveryFailed"
	OidcIssuerJwkEndpointUnavailable BadGatewayErrorCode = "OidcIssuerJwkEndpointUnavailable"
	SentryApiError                   BadGatewayErrorCode = "SentryApiError"
	SmtpServerUnavailable            BadGatewayErrorCode = "SmtpServerUnavailable"
)

// Defines values for BadRequestErrorCode.
const (
	BadRequestErrorCodeAddKeyToRoleCountTooHigh                        BadRequestErrorCode = "AddKeyToRoleCountTooHigh"
	BadRequestErrorCodeAlienOwnerInvalid                               BadRequestErrorCode = "AlienOwnerInvalid"
	BadRequestErrorCodeAvaSignError                                    BadRequestErrorCode = "AvaSignError"
	BadRequestErrorCodeAvaSignHashError                                BadRequestErrorCode = "AvaSignHashError"
	BadRequestErrorCodeBabylonCovSign                                  BadRequestErrorCode = "BabylonCovSign"
	BadRequestErrorCodeBabylonStaking                                  BadRequestErrorCode = "BabylonStaking"
	BadRequestErrorCodeBabylonStakingFeePlusDustOverflow               BadRequestErrorCode = "BabylonStakingFeePlusDustOverflow"
	BadRequestErrorCodeBabylonStakingIncorrectKey                      BadRequestErrorCode = "BabylonStakingIncorrectKey"
	BadRequestErrorCodeBabylonStakingRegistrationRequiresTaproot       BadRequestErrorCode = "BabylonStakingRegistrationRequiresTaproot"
	BadRequestErrorCodeBabylonStakingSegwitNonDeposit                  BadRequestErrorCode = "BabylonStakingSegwitNonDeposit"
	BadRequestErrorCodeBadBtcMessageSignP2shFlag                       BadRequestErrorCode = "BadBtcMessageSignP2shFlag"
	BadRequestErrorCodeBtcSegwitHashError                              BadRequestErrorCode = "BtcSegwitHashError"
	BadRequestErrorCodeBtcSignError                                    BadRequestErrorCode = "BtcSignError"
	BadRequestErrorCodeBtcTaprootHashError                             BadRequestErrorCode = "BtcTaprootHashError"
	BadRequestErrorCodeCannotDeletePendingSubscription                 BadRequestErrorCode = "CannotDeletePendingSubscription"
	BadRequestErrorCodeCannotResendUserInvitation                      BadRequestErrorCode = "CannotResendUserInvitation"
	BadRequestErrorCodeCognitoUserAlreadyOrgMember                     BadRequestErrorCode = "CognitoUserAlreadyOrgMember"
	BadRequestErrorCodeContactNameInvalid                              BadRequestErrorCode = "ContactNameInvalid"
	BadRequestErrorCodeCustomStakingAmountNotAllowedForWrapperContract BadRequestErrorCode = "CustomStakingAmountNotAllowedForWrapperContract"
	BadRequestErrorCodeDeleteOidcUserError                             BadRequestErrorCode = "DeleteOidcUserError"
	BadRequestErrorCodeDeleteUserError                                 BadRequestErrorCode = "DeleteUserError"
	BadRequestErrorCodeDuplicateFieldEntry                             BadRequestErrorCode = "DuplicateFieldEntry"
	BadRequestErrorCodeEip712SignError                                 BadRequestErrorCode = "Eip712SignError"
	BadRequestErrorCodeEmailOtpDelayTooShortForRegisterMfa             BadRequestErrorCode = "EmailOtpDelayTooShortForRegisterMfa"
	BadRequestErrorCodeEmailPasswordNotFound                           BadRequestErrorCode = "EmailPasswordNotFound"
	BadRequestErrorCodeEmptyAddress                                    BadRequestErrorCode = "EmptyAddress"
	BadRequestErrorCodeEmptyAllExceptOrgEventFilter                    BadRequestErrorCode = "EmptyAllExceptOrgEventFilter"
	BadRequestErrorCodeEmptyOneOfOrgEventFilter                        BadRequestErrorCode = "EmptyOneOfOrgEventFilter"
	BadRequestErrorCodeEmptyRuleError                                  BadRequestErrorCode = "EmptyRuleError"
	BadRequestErrorCodeEmptyScopes                                     BadRequestErrorCode = "EmptyScopes"
	BadRequestErrorCodeEmptyUpdateRequest                              BadRequestErrorCode = "EmptyUpdateRequest"
	BadRequestErrorCodeErc20ContractDisallowed                         BadRequestErrorCode = "Erc20ContractDisallowed"
	BadRequestErrorCodeEthersGetTransactionCountError                  BadRequestErrorCode = "EthersGetTransactionCountError"
	BadRequestErrorCodeEthersInvalidRpcUrl                             BadRequestErrorCode = "EthersInvalidRpcUrl"
	BadRequestErrorCodeExistingKeysViolateExclusiveKeyAccess           BadRequestErrorCode = "ExistingKeysViolateExclusiveKeyAccess"
	BadRequestErrorCodeExportDelayTooShort                             BadRequestErrorCode = "ExportDelayTooShort"
	BadRequestErrorCodeExportWindowTooLong                             BadRequestErrorCode = "ExportWindowTooLong"
	BadRequestErrorCodeFidoChallengeMfaMismatch                        BadRequestErrorCode = "FidoChallengeMfaMismatch"
	BadRequestErrorCodeFidoKeyAlreadyRegistered                        BadRequestErrorCode = "FidoKeyAlreadyRegistered"
	BadRequestErrorCodeFidoKeySignCountTooLow                          BadRequestErrorCode = "FidoKeySignCountTooLow"
	BadRequestErrorCodeFidoVerificationFailed                          BadRequestErrorCode = "FidoVerificationFailed"
	BadRequestErrorCodeGenericBadRequest                               BadRequestErrorCode = "GenericBadRequest"
	BadRequestErrorCodeIdpUserAlreadyExists                            BadRequestErrorCode = "IdpUserAlreadyExists"
	BadRequestErrorCodeImportKeyMissing                                BadRequestErrorCode = "ImportKeyMissing"
	BadRequestErrorCodeInvalidAbiMethods                               BadRequestErrorCode = "InvalidAbiMethods"
	BadRequestErrorCodeInvalidBabylonStakingPolicyParams               BadRequestErrorCode = "InvalidBabylonStakingPolicyParams"
	BadRequestErrorCodeInvalidBase32Value                              BadRequestErrorCode = "InvalidBase32Value"
	BadRequestErrorCodeInvalidBase58Value                              BadRequestErrorCode = "InvalidBase58Value"
	BadRequestErrorCodeInvalidBlobSignRequest                          BadRequestErrorCode = "InvalidBlobSignRequest"
	BadRequestErrorCodeInvalidBody                                     BadRequestErrorCode = "InvalidBody"
	BadRequestErrorCodeInvalidBtcAddressForChain                       BadRequestErrorCode = "InvalidBtcAddressForChain"
	BadRequestErrorCodeInvalidBtcTxReceiversEmptyAllowlist             BadRequestErrorCode = "InvalidBtcTxReceiversEmptyAllowlist"
	BadRequestErrorCodeInvalidCreateKeyCount                           BadRequestErrorCode = "InvalidCreateKeyCount"
	BadRequestErrorCodeInvalidCreateUserRequest                        BadRequestErrorCode = "InvalidCreateUserRequest"
	BadRequestErrorCodeInvalidDeriveKeyRequest                         BadRequestErrorCode = "InvalidDeriveKeyRequest"
	BadRequestErrorCodeInvalidDiffieHellmanCount                       BadRequestErrorCode = "InvalidDiffieHellmanCount"
	BadRequestErrorCodeInvalidDiffieHellmanRequest                     BadRequestErrorCode = "InvalidDiffieHellmanRequest"
	BadRequestErrorCodeInvalidEip191SignRequest                        BadRequestErrorCode = "InvalidEip191SignRequest"
	BadRequestErrorCodeInvalidEip712SignRequest                        BadRequestErrorCode = "InvalidEip712SignRequest"
	BadRequestErrorCodeInvalidEmail                                    BadRequestErrorCode = "InvalidEmail"
	BadRequestErrorCodeInvalidEmailTemplate                            BadRequestErrorCode = "InvalidEmailTemplate"
	BadRequestErrorCodeInvalidEth2SignRequest                          BadRequestErrorCode = "InvalidEth2SignRequest"
	BadRequestErrorCodeInvalidEth2SigningPolicyEpochRange              BadRequestErrorCode = "InvalidEth2SigningPolicyEpochRange"
	BadRequestErrorCodeInvalidEth2SigningPolicyOverlappingRule         BadRequestErrorCode = "InvalidEth2SigningPolicyOverlappingRule"
	BadRequestErrorCodeInvalidEth2SigningPolicySlotRange               BadRequestErrorCode = "InvalidEth2SigningPolicySlotRange"
	BadRequestErrorCodeInvalidEth2SigningPolicyTimestampRange          BadRequestErrorCode = "InvalidEth2SigningPolicyTimestampRange"
	BadRequestErrorCodeInvalidEthAddress                               BadRequestErrorCode = "InvalidEthAddress"
	BadRequestErrorCodeInvalidEvmSignRequest                           BadRequestErrorCode = "InvalidEvmSignRequest"
	BadRequestErrorCodeInvalidForkVersionLength                        BadRequestErrorCode = "InvalidForkVersionLength"
	BadRequestErrorCodeInvalidHexValue                                 BadRequestErrorCode = "InvalidHexValue"
	BadRequestErrorCodeInvalidIdentityProof                            BadRequestErrorCode = "InvalidIdentityProof"
	BadRequestErrorCodeInvalidJwt                                      BadRequestErrorCode = "InvalidJwt"
	BadRequestErrorCodeInvalidKeyId                                    BadRequestErrorCode = "InvalidKeyId"
	BadRequestErrorCodeInvalidKeyMaterial                              BadRequestErrorCode = "InvalidKeyMaterial"
	BadRequestErrorCodeInvalidKeyMaterialId                            BadRequestErrorCode = "InvalidKeyMaterialId"
	BadRequestErrorCodeInvalidKeyType                                  BadRequestErrorCode = "InvalidKeyType"
	BadRequestErrorCodeInvalidLength                                   BadRequestErrorCode = "InvalidLength"
	BadRequestErrorCodeInvalidLifetime                                 BadRequestErrorCode = "InvalidLifetime"
	BadRequestErrorCodeInvalidMemberRoleInRecipientAdd                 BadRequestErrorCode = "InvalidMemberRoleInRecipientAdd"
	BadRequestErrorCodeInvalidMemberRoleInUserAdd                      BadRequestErrorCode = "InvalidMemberRoleInUserAdd"
	BadRequestErrorCodeInvalidMessageType                              BadRequestErrorCode = "InvalidMessageType"
	BadRequestErrorCodeInvalidMetadataLength                           BadRequestErrorCode = "InvalidMetadataLength"
	BadRequestErrorCodeInvalidMfaPolicyCount                           BadRequestErrorCode = "InvalidMfaPolicyCount"
	BadRequestErrorCodeInvalidMfaPolicyGracePeriodTooLong              BadRequestErrorCode = "InvalidMfaPolicyGracePeriodTooLong"
	BadRequestErrorCodeInvalidMfaPolicyNumAllowedApprovers             BadRequestErrorCode = "InvalidMfaPolicyNumAllowedApprovers"
	BadRequestErrorCodeInvalidMfaPolicyNumAuthFactors                  BadRequestErrorCode = "InvalidMfaPolicyNumAuthFactors"
	BadRequestErrorCodeInvalidMfaReceipt                               BadRequestErrorCode = "InvalidMfaReceipt"
	BadRequestErrorCodeInvalidMfaReceiptInvalidOrgId                   BadRequestErrorCode = "InvalidMfaReceiptInvalidOrgId"
	BadRequestErrorCodeInvalidMfaReceiptOrgIdMissing                   BadRequestErrorCode = "InvalidMfaReceiptOrgIdMissing"
	BadRequestErrorCodeInvalidNotificationEndpointCount                BadRequestErrorCode = "InvalidNotificationEndpointCount"
	BadRequestErrorCodeInvalidNotificationUrlProtocol                  BadRequestErrorCode = "InvalidNotificationUrlProtocol"
	BadRequestErrorCodeInvalidOidcIdentity                             BadRequestErrorCode = "InvalidOidcIdentity"
	BadRequestErrorCodeInvalidOidcToken                                BadRequestErrorCode = "InvalidOidcToken"
	BadRequestErrorCodeInvalidOneTimeCode                              BadRequestErrorCode = "InvalidOneTimeCode"
	BadRequestErrorCodeInvalidOrgNameOrId                              BadRequestErrorCode = "InvalidOrgNameOrId"
	BadRequestErrorCodeInvalidOrgPolicyRepeatedRule                    BadRequestErrorCode = "InvalidOrgPolicyRepeatedRule"
	BadRequestErrorCodeInvalidOrgPolicyRule                            BadRequestErrorCode = "InvalidOrgPolicyRule"
	BadRequestErrorCodeInvalidPaginationToken                          BadRequestErrorCode = "InvalidPaginationToken"
	BadRequestErrorCodeInvalidPassword                                 BadRequestErrorCode = "InvalidPassword"
	BadRequestErrorCodeInvalidPolicyLogsRequest                        BadRequestErrorCode = "InvalidPolicyLogsRequest"
	BadRequestErrorCodeInvalidPolicyReference                          BadRequestErrorCode = "InvalidPolicyReference"
	BadRequestErrorCodeInvalidRange                                    BadRequestErrorCode = "InvalidRange"
	BadRequestErrorCodeInvalidRequireRoleSessionAllowlist              BadRequestErrorCode = "InvalidRequireRoleSessionAllowlist"
	BadRequestErrorCodeInvalidRestrictedScopes                         BadRequestErrorCode = "InvalidRestrictedScopes"
	BadRequestErrorCodeInvalidRoleNameOrId                             BadRequestErrorCode = "InvalidRoleNameOrId"
	BadRequestErrorCodeInvalidScopesForRoleSession                     BadRequestErrorCode = "InvalidScopesForRoleSession"
	BadRequestErrorCodeInvalidSolanaSignRequest                        BadRequestErrorCode = "InvalidSolanaSignRequest"
	BadRequestErrorCodeInvalidSs58Value                                BadRequestErrorCode = "InvalidSs58Value"
	BadRequestErrorCodeInvalidStakeDeposit                             BadRequestErrorCode = "InvalidStakeDeposit"
	BadRequestErrorCodeInvalidStakingAmount                            BadRequestErrorCode = "InvalidStakingAmount"
	BadRequestErrorCodeInvalidStellarAddress                           BadRequestErrorCode = "InvalidStellarAddress"
	BadRequestErrorCodeInvalidSuiTransaction                           BadRequestErrorCode = "InvalidSuiTransaction"
	BadRequestErrorCodeInvalidSuiTxReceiversEmptyAllowlist             BadRequestErrorCode = "InvalidSuiTxReceiversEmptyAllowlist"
	BadRequestErrorCodeInvalidTapNodeHash                              BadRequestErrorCode = "InvalidTapNodeHash"
	BadRequestErrorCodeInvalidTelegramData                             BadRequestErrorCode = "InvalidTelegramData"
	BadRequestErrorCodeInvalidTendermintRequest                        BadRequestErrorCode = "InvalidTendermintRequest"
	BadRequestErrorCodeInvalidTimeLockAlreadyInThePast                 BadRequestErrorCode = "InvalidTimeLockAlreadyInThePast"
	BadRequestErrorCodeInvalidTotpFailureLimit                         BadRequestErrorCode = "InvalidTotpFailureLimit"
	BadRequestErrorCodeInvalidUnstakeRequest                           BadRequestErrorCode = "InvalidUnstakeRequest"
	BadRequestErrorCodeInvalidUpdate                                   BadRequestErrorCode = "InvalidUpdate"
	BadRequestErrorCodeInvalidUpdateOrgRequestDisallowedMfaType        BadRequestErrorCode = "InvalidUpdateOrgRequestDisallowedMfaType"
	BadRequestErrorCodeInvalidUpdateOrgRequestEmptyAllowedMfaTypes     BadRequestErrorCode = "InvalidUpdateOrgRequestEmptyAllowedMfaTypes"
	BadRequestErrorCodeInvalidWasmPolicy                               BadRequestErrorCode = "InvalidWasmPolicy"
	BadRequestErrorCodeInvitationNoLongerValid                         BadRequestErrorCode = "InvitationNoLongerValid"
	BadRequestErrorCodeKeyNotFound                                     BadRequestErrorCode = "KeyNotFound"
	BadRequestErrorCodeLimitWindowTooLong                              BadRequestErrorCode = "LimitWindowTooLong"
	BadRequestErrorCodeMessageAlreadySigned                            BadRequestErrorCode = "MessageAlreadySigned"
	BadRequestErrorCodeMessageNotFound                                 BadRequestErrorCode = "MessageNotFound"
	BadRequestErrorCodeMessageRejected                                 BadRequestErrorCode = "MessageRejected"
	BadRequestErrorCodeMessageReplaced                                 BadRequestErrorCode = "MessageReplaced"
	BadRequestErrorCodeMfaRequestNotFound                              BadRequestErrorCode = "MfaRequestNotFound"
	BadRequestErrorCodeMmiChainIdMissing                               BadRequestErrorCode = "MmiChainIdMissing"
	BadRequestErrorCodeNameTaken                                       BadRequestErrorCode = "NameTaken"
	BadRequestErrorCodeNistP256PublicKeyInvalid                        BadRequestErrorCode = "NistP256PublicKeyInvalid"
	BadRequestErrorCodeNoOidcDataInProof                               BadRequestErrorCode = "NoOidcDataInProof"
	BadRequestErrorCodeNoSingleKeyForUser                              BadRequestErrorCode = "NoSingleKeyForUser"
	BadRequestErrorCodeOidcIdentityAlreadyExists                       BadRequestErrorCode = "OidcIdentityAlreadyExists"
	BadRequestErrorCodeOidcIssuerNoApplicableJwk                       BadRequestErrorCode = "OidcIssuerNoApplicableJwk"
	BadRequestErrorCodeOidcIssuerNotAllowed                            BadRequestErrorCode = "OidcIssuerNotAllowed"
	BadRequestErrorCodeOidcIssuerUnsupported                           BadRequestErrorCode = "OidcIssuerUnsupported"
	BadRequestErrorCodeOneTimeCodeExpired                              BadRequestErrorCode = "OneTimeCodeExpired"
	BadRequestErrorCodeOnlySpecifyOne                                  BadRequestErrorCode = "OnlySpecifyOne"
	BadRequestErrorCodeOptionalListEmpty                               BadRequestErrorCode = "OptionalListEmpty"
	BadRequestErrorCodeOrgInviteExistingUser                           BadRequestErrorCode = "OrgInviteExistingUser"
	BadRequestErrorCodeOrgIsNotOrgExport                               BadRequestErrorCode = "OrgIsNotOrgExport"
	BadRequestErrorCodeOrgNameTaken                                    BadRequestErrorCode = "OrgNameTaken"
	BadRequestErrorCodeOrgUserAlreadyExists                            BadRequestErrorCode = "OrgUserAlreadyExists"
	BadRequestErrorCodePaginationDataExpired                           BadRequestErrorCode = "PaginationDataExpired"
	BadRequestErrorCodePasswordAuthNotAllowedByInvitation              BadRequestErrorCode = "PasswordAuthNotAllowedByInvitation"
	BadRequestErrorCodePolicyDuplicateError                            BadRequestErrorCode = "PolicyDuplicateError"
	BadRequestErrorCodePolicyEngineDisabled                            BadRequestErrorCode = "PolicyEngineDisabled"
	BadRequestErrorCodePolicyKeyMismatch                               BadRequestErrorCode = "PolicyKeyMismatch"
	BadRequestErrorCodePolicyModified                                  BadRequestErrorCode = "PolicyModified"
	BadRequestErrorCodePolicyNameTaken                                 BadRequestErrorCode = "PolicyNameTaken"
	BadRequestErrorCodePolicyNotAttached                               BadRequestErrorCode = "PolicyNotAttached"
	BadRequestErrorCodePolicyNotFound                                  BadRequestErrorCode = "PolicyNotFound"
	BadRequestErrorCodePolicyRuleDisallowedByType                      BadRequestErrorCode = "PolicyRuleDisallowedByType"
	BadRequestErrorCodePolicyRuleKeyMismatch                           BadRequestErrorCode = "PolicyRuleKeyMismatch"
	BadRequestErrorCodePolicyStillAttached                             BadRequestErrorCode = "PolicyStillAttached"
	BadRequestErrorCodePolicyTypeDisallowed                            BadRequestErrorCode = "PolicyTypeDisallowed"
	BadRequestErrorCodePolicyVersionInvalid                            BadRequestErrorCode = "PolicyVersionInvalid"
	BadRequestErrorCodePolicyVersionMaxReached                         BadRequestErrorCode = "PolicyVersionMaxReached"
	BadRequestErrorCodePolicyVersionNotFound                           BadRequestErrorCode = "PolicyVersionNotFound"
	BadRequestErrorCodePsbtSigning                                     BadRequestErrorCode = "PsbtSigning"
	BadRequestErrorCodeQueryMetricsError                               BadRequestErrorCode = "QueryMetricsError"
	BadRequestErrorCodeQueryMetricsValidationError                     BadRequestErrorCode = "QueryMetricsValidationError"
	BadRequestErrorCodeRedundantDerivationPath                         BadRequestErrorCode = "RedundantDerivationPath"
	BadRequestErrorCodeReservedName                                    BadRequestErrorCode = "ReservedName"
	BadRequestErrorCodeRoleNameTaken                                   BadRequestErrorCode = "RoleNameTaken"
	BadRequestErrorCodeRoleNotFound                                    BadRequestErrorCode = "RoleNotFound"
	BadRequestErrorCodeRpcUrlMissing                                   BadRequestErrorCode = "RpcUrlMissing"
	BadRequestErrorCodeSessionRoleMismatch                             BadRequestErrorCode = "SessionRoleMismatch"
	BadRequestErrorCodeSiweChallengeNotFound                           BadRequestErrorCode = "SiweChallengeNotFound"
	BadRequestErrorCodeSiweInvalidRequest                              BadRequestErrorCode = "SiweInvalidRequest"
	BadRequestErrorCodeSourceIpAllowlistEmpty                          BadRequestErrorCode = "SourceIpAllowlistEmpty"
	BadRequestErrorCodeSuiSenderMismatch                               BadRequestErrorCode = "SuiSenderMismatch"
	BadRequestErrorCodeTaprootSignError                                BadRequestErrorCode = "TaprootSignError"
	BadRequestErrorCodeThirdPartyUserAlreadyExists                     BadRequestErrorCode = "ThirdPartyUserAlreadyExists"
	BadRequestErrorCodeThirdPartyUserNotFound                          BadRequestErrorCode = "ThirdPartyUserNotFound"
	BadRequestErrorCodeTokenRequestError                               BadRequestErrorCode = "TokenRequestError"
	BadRequestErrorCodeTooManyFailedLogins                             BadRequestErrorCode = "TooManyFailedLogins"
	BadRequestErrorCodeTooManyRequests                                 BadRequestErrorCode = "TooManyRequests"
	BadRequestErrorCodeTooManyResets                                   BadRequestErrorCode = "TooManyResets"
	BadRequestErrorCodeUnableToAccessSmtpRelay                         BadRequestErrorCode = "UnableToAccessSmtpRelay"
	BadRequestErrorCodeUnsupportedLegacyCognitoSession                 BadRequestErrorCode = "UnsupportedLegacyCognitoSession"
	BadRequestErrorCodeUserAlreadyExists                               BadRequestErrorCode = "UserAlreadyExists"
	BadRequestErrorCodeUserEmailNotConfigured                          BadRequestErrorCode = "UserEmailNotConfigured"
	BadRequestErrorCodeUserExportDerivedKey                            BadRequestErrorCode = "UserExportDerivedKey"
	BadRequestErrorCodeUserExportInProgress                            BadRequestErrorCode = "UserExportInProgress"
	BadRequestErrorCodeUserExportPublicKeyInvalid                      BadRequestErrorCode = "UserExportPublicKeyInvalid"
	BadRequestErrorCodeUserNotFound                                    BadRequestErrorCode = "UserNotFound"
	BadRequestErrorCodeUserProfileMigrationMultipleEntries             BadRequestErrorCode = "UserProfileMigrationMultipleEntries"
	BadRequestErrorCodeUserProfileMigrationTooManyItems                BadRequestErrorCode = "UserProfileMigrationTooManyItems"
	BadRequestErrorCodeUserWithEmailNotFound                           BadRequestErrorCode = "UserWithEmailNotFound"
	BadRequestErrorCodeWebhookPolicyDisallowedHeaders                  BadRequestErrorCode = "WebhookPolicyDisallowedHeaders"
	BadRequestErrorCodeWebhookPolicyDisallowedUrlHost                  BadRequestErrorCode = "WebhookPolicyDisallowedUrlHost"
	BadRequestErrorCodeWebhookPolicyDisallowedUrlScheme                BadRequestErrorCode = "WebhookPolicyDisallowedUrlScheme"
	BadRequestErrorCodeWebhookPolicyTimeoutOutOfBounds                 BadRequestErrorCode = "WebhookPolicyTimeoutOutOfBounds"
)

// Defines values for BillingEvent.
const (
	BillingEventAboutMe                     BillingEvent = "AboutMe"
	BillingEventAddKeysToRole               BillingEvent = "AddKeysToRole"
	BillingEventAddOidcIdentity             BillingEvent = "AddOidcIdentity"
	BillingEventAddUserToRole               BillingEvent = "AddUserToRole"
	BillingEventAuthMigrationIdentityAdd    BillingEvent = "AuthMigrationIdentityAdd"
	BillingEventAuthMigrationIdentityRemove BillingEvent = "AuthMigrationIdentityRemove"
	BillingEventAuthMigrationUserUpdate     BillingEvent = "AuthMigrationUserUpdate"
	BillingEventAvaSerializedTxSign         BillingEvent = "AvaSerializedTxSign"
	BillingEventAvaSign                     BillingEvent = "AvaSign"
	BillingEventBabylonCovSign              BillingEvent = "BabylonCovSign"
	BillingEventBabylonRegistration         BillingEvent = "BabylonRegistration"
	BillingEventBabylonStaking              BillingEvent = "BabylonStaking"
	BillingEventBlobSign                    BillingEvent = "BlobSign"
	BillingEventBtcMessageSign              BillingEvent = "BtcMessageSign"
	BillingEventBtcSign                     BillingEvent = "BtcSign"
	BillingEventCompleteResetMemberMfa      BillingEvent = "CompleteResetMemberMfa"
	BillingEventConfigureEmail              BillingEvent = "ConfigureEmail"
	BillingEventCounts                      BillingEvent = "Counts"
	BillingEventCreateContact               BillingEvent = "CreateContact"
	BillingEventCreateEotsNonces            BillingEvent = "CreateEotsNonces"
	BillingEventCreateKey                   BillingEvent = "CreateKey"
	BillingEventCreateKeyImportKey          BillingEvent = "CreateKeyImportKey"
	BillingEventCreateOidcUser              BillingEvent = "CreateOidcUser"
	BillingEventCreateOrg                   BillingEvent = "CreateOrg"
	BillingEventCreatePolicy                BillingEvent = "CreatePolicy"
	BillingEventCreatePolicyImportKey       BillingEvent = "CreatePolicyImportKey"
	BillingEventCreateProofCubeSigner       BillingEvent = "CreateProofCubeSigner"
	BillingEventCreateProofOidc             BillingEvent = "CreateProofOidc"
	BillingEventCreateRole                  BillingEvent = "CreateRole"
	BillingEventCreateSession               BillingEvent = "CreateSession"
	BillingEventCreateToken                 BillingEvent = "CreateToken"
	BillingEventCube3signerHeartbeat        BillingEvent = "Cube3signerHeartbeat"
	BillingEventDeleteContact               BillingEvent = "DeleteContact"
	BillingEventDeleteKey                   BillingEvent = "DeleteKey"
	BillingEventDeleteOidcUser              BillingEvent = "DeleteOidcUser"
	BillingEventDeletePolicy                BillingEvent = "DeletePolicy"
	BillingEventDeletePolicySecret          BillingEvent = "DeletePolicySecret"
	BillingEventDeleteRole                  BillingEvent = "DeleteRole"
	BillingEventDeleteUser                  BillingEvent = "DeleteUser"
	BillingEventDeriveKey                   BillingEvent = "DeriveKey"
	BillingEventDiffieHellmanExchange       BillingEvent = "DiffieHellmanExchange"
	BillingEventEip191Sign                  BillingEvent = "Eip191Sign"
	BillingEventEip712Sign                  BillingEvent = "Eip712Sign"
	BillingEventEmailOtpAuth                BillingEvent = "EmailOtpAuth"
	BillingEventEotsSign                    BillingEvent = "EotsSign"
	BillingEventEsploraApiCall              BillingEvent = "EsploraApiCall"
	BillingEventEth1Sign                    BillingEvent = "Eth1Sign"
	BillingEventEth2Sign                    BillingEvent = "Eth2Sign"
	BillingEventGetContact                  BillingEvent = "GetContact"
	BillingEventGetKey                      BillingEvent = "GetKey"
	BillingEventGetKeyByMaterialId          BillingEvent = "GetKeyByMaterialId"
	BillingEventGetOrg                      BillingEvent = "GetOrg"
	BillingEventGetOrgExport                BillingEvent = "GetOrgExport"
	BillingEventGetPolicy                   BillingEvent = "GetPolicy"
	BillingEventGetPolicyLogs               BillingEvent = "GetPolicyLogs"
	BillingEventGetPolicySecrets            BillingEvent = "GetPolicySecrets"
	BillingEventGetRole                     BillingEvent = "GetRole"
	BillingEventGetRoleKey                  BillingEvent = "GetRoleKey"
	BillingEventGetSession                  BillingEvent = "GetSession"
	BillingEventGetUser                     BillingEvent = "GetUser"
	BillingEventGetUserByEmail              BillingEvent = "GetUserByEmail"
	BillingEventGetUserByOidc               BillingEvent = "GetUserByOidc"
	BillingEventIdpAuthenticate             BillingEvent = "IdpAuthenticate"
	BillingEventIdpPasswordResetConfirm     BillingEvent = "IdpPasswordResetConfirm"
	BillingEventImportKey                   BillingEvent = "ImportKey"
	BillingEventInvitationAccept            BillingEvent = "InvitationAccept"
	BillingEventInvite                      BillingEvent = "Invite"
	BillingEventInvokePolicy                BillingEvent = "InvokePolicy"
	BillingEventKeyCreated                  BillingEvent = "KeyCreated"
	BillingEventKeyImported                 BillingEvent = "KeyImported"
	BillingEventListContacts                BillingEvent = "ListContacts"
	BillingEventListHistoricalKeyTx         BillingEvent = "ListHistoricalKeyTx"
	BillingEventListHistoricalRoleTx        BillingEvent = "ListHistoricalRoleTx"
	BillingEventListKeyRoles                BillingEvent = "ListKeyRoles"
	BillingEventListKeys                    BillingEvent = "ListKeys"
	BillingEventListOidcIdentities          BillingEvent = "ListOidcIdentities"
	BillingEventListPolicies                BillingEvent = "ListPolicies"
	BillingEventListRoleKeys                BillingEvent = "ListRoleKeys"
	BillingEventListRoleUsers               BillingEvent = "ListRoleUsers"
	BillingEventListRoles                   BillingEvent = "ListRoles"
	BillingEventListSessions                BillingEvent = "ListSessions"
	BillingEventListTokenKeys               BillingEvent = "ListTokenKeys"
	BillingEventListUsers                   BillingEvent = "ListUsers"
	BillingEventMfaApproveCs                BillingEvent = "MfaApproveCs"
	BillingEventMfaApproveFidoComplete      BillingEvent = "MfaApproveFidoComplete"
	BillingEventMfaApproveTotp              BillingEvent = "MfaApproveTotp"
	BillingEventMfaEmailComplete            BillingEvent = "MfaEmailComplete"
	BillingEventMfaEmailInit                BillingEvent = "MfaEmailInit"
	BillingEventMfaFidoInit                 BillingEvent = "MfaFidoInit"
	BillingEventMfaGet                      BillingEvent = "MfaGet"
	BillingEventMfaList                     BillingEvent = "MfaList"
	BillingEventMfaRejectCs                 BillingEvent = "MfaRejectCs"
	BillingEventMfaRejectFidoComplete       BillingEvent = "MfaRejectFidoComplete"
	BillingEventMfaRejectTotp               BillingEvent = "MfaRejectTotp"
	BillingEventMmi                         BillingEvent = "Mmi"
	BillingEventMmiMessageDelete            BillingEvent = "MmiMessageDelete"
	BillingEventMmiMessageGet               BillingEvent = "MmiMessageGet"
	BillingEventMmiMessageList              BillingEvent = "MmiMessageList"
	BillingEventMmiMessageReject            BillingEvent = "MmiMessageReject"
	BillingEventMmiMessageSign              BillingEvent = "MmiMessageSign"
	BillingEventOAuth2TokenRefresh          BillingEvent = "OAuth2TokenRefresh"
	BillingEventOauth2Twitter               BillingEvent = "Oauth2Twitter"
	BillingEventOidcAuth                    BillingEvent = "OidcAuth"
	BillingEventPasskeyAuthComplete         BillingEvent = "PasskeyAuthComplete"
	BillingEventPsbtLegacyInputSign         BillingEvent = "PsbtLegacyInputSign"
	BillingEventPsbtSegwitInputSign         BillingEvent = "PsbtSegwitInputSign"
	BillingEventPsbtSign                    BillingEvent = "PsbtSign"
	BillingEventPsbtTaprootInputSign        BillingEvent = "PsbtTaprootInputSign"
	BillingEventQueryMetrics                BillingEvent = "QueryMetrics"
	BillingEventRemoveKeyFromRole           BillingEvent = "RemoveKeyFromRole"
	BillingEventRemoveOidcIdentity          BillingEvent = "RemoveOidcIdentity"
	BillingEventRemoveUserFromRole          BillingEvent = "RemoveUserFromRole"
	BillingEventResetMemberMfa              BillingEvent = "ResetMemberMfa"
	BillingEventRevokeCurrentSession        BillingEvent = "RevokeCurrentSession"
	BillingEventRevokeSession               BillingEvent = "RevokeSession"
	BillingEventRevokeSessions              BillingEvent = "RevokeSessions"
	BillingEventSetPolicySecret             BillingEvent = "SetPolicySecret"
	BillingEventSignerSessionRefresh        BillingEvent = "SignerSessionRefresh"
	BillingEventSiweComplete                BillingEvent = "SiweComplete"
	BillingEventSiweInit                    BillingEvent = "SiweInit"
	BillingEventSolanaSign                  BillingEvent = "SolanaSign"
	BillingEventStake                       BillingEvent = "Stake"
	BillingEventSuiSign                     BillingEvent = "SuiSign"
	BillingEventTaprootSign                 BillingEvent = "TaprootSign"
	BillingEventTelegramAuth                BillingEvent = "TelegramAuth"
	BillingEventTendermintSign              BillingEvent = "TendermintSign"
	BillingEventUnstake                     BillingEvent = "Unstake"
	BillingEventUpdateContact               BillingEvent = "UpdateContact"
	BillingEventUpdateKey                   BillingEvent = "UpdateKey"
	BillingEventUpdateMembership            BillingEvent = "UpdateMembership"
	BillingEventUpdateOrg                   BillingEvent = "UpdateOrg"
	BillingEventUpdatePolicy                BillingEvent = "UpdatePolicy"
	BillingEventUpdatePolicySecrets         BillingEvent = "UpdatePolicySecrets"
	BillingEventUpdateRole                  BillingEvent = "UpdateRole"
	BillingEventUploadWasmPolicy            BillingEvent = "UploadWasmPolicy"
	BillingEventUserDeleteFido              BillingEvent = "UserDeleteFido"
	BillingEventUserDeleteTotp              BillingEvent = "UserDeleteTotp"
	BillingEventUserExportComplete          BillingEvent = "UserExportComplete"
	BillingEventUserExportDelete            BillingEvent = "UserExportDelete"
	BillingEventUserExportInit              BillingEvent = "UserExportInit"
	BillingEventUserExportList              BillingEvent = "UserExportList"
	BillingEventUserRegisterFidoComplete    BillingEvent = "UserRegisterFidoComplete"
	BillingEventUserRegisterFidoInit        BillingEvent = "UserRegisterFidoInit"
	BillingEventUserResetEmailComplete      BillingEvent = "UserResetEmailComplete"
	BillingEventUserResetEmailInit          BillingEvent = "UserResetEmailInit"
	BillingEventUserResetTotpComplete       BillingEvent = "UserResetTotpComplete"
	BillingEventUserResetTotpInit           BillingEvent = "UserResetTotpInit"
	BillingEventUserVerifyTotp              BillingEvent = "UserVerifyTotp"
	BillingEventVerifyProof                 BillingEvent = "VerifyProof"
)

// Defines values for BtcChain.
const (
	Btc       BtcChain = "btc"
	BtcSignet BtcChain = "btc_signet"
)

// Defines values for BtcSighashType.
const (
	BtcSighashTypeAll                    BtcSighashType = "All"
	BtcSighashTypeAllPlusAnyoneCanPay    BtcSighashType = "AllPlusAnyoneCanPay"
	BtcSighashTypeNone                   BtcSighashType = "None"
	BtcSighashTypeNonePlusAnyoneCanPay   BtcSighashType = "NonePlusAnyoneCanPay"
	BtcSighashTypeSingle                 BtcSighashType = "Single"
	BtcSighashTypeSinglePlusAnyoneCanPay BtcSighashType = "SinglePlusAnyoneCanPay"
)

// Defines values for ConfiguredMfaFidoType.
const (
	Fido ConfiguredMfaFidoType = "fido"
)

// Defines values for ConfiguredMfaTotpType.
const (
	Totp ConfiguredMfaTotpType = "totp"
)

// Defines values for ConflictErrorCode.
const (
	ConcurrentLockCreation      ConflictErrorCode = "ConcurrentLockCreation"
	ConcurrentRequestDisallowed ConflictErrorCode = "ConcurrentRequestDisallowed"
)

// Defines values for DepositType.
const (
	Canonical DepositType = "Canonical"
	Wrapper   DepositType = "Wrapper"
)

// Defines values for DiffieHellmanResponseEncryptedResponseType.
const (
	Encrypted DiffieHellmanResponseEncryptedResponseType = "encrypted"
)

// Defines values for DiffieHellmanResponseMaskedResponseType.
const (
	Masked DiffieHellmanResponseMaskedResponseType = "masked"
)

// Defines values for EsploraRequestNetwork.
const (
	EsploraRequestNetworkMainnet EsploraRequestNetwork = "mainnet"
	EsploraRequestNetworkSignet  EsploraRequestNetwork = "signet"
	EsploraRequestNetworkTestnet EsploraRequestNetwork = "testnet"
)

// Defines values for EvmChain.
const (
	Arbitrum        EvmChain = "arbitrum"
	Avalanche       EvmChain = "avalanche"
	AvalancheFuji   EvmChain = "avalanche_fuji"
	Base            EvmChain = "base"
	Berachain       EvmChain = "berachain"
	Blast           EvmChain = "blast"
	Bsc             EvmChain = "bsc"
	Celo            EvmChain = "celo"
	Eth             EvmChain = "eth"
	EthHolesky      EvmChain = "eth_holesky"
	EthSepolia      EvmChain = "eth_sepolia"
	Fantom          EvmChain = "fantom"
	Flare           EvmChain = "flare"
	Linea           EvmChain = "linea"
	Optimism        EvmChain = "optimism"
	OptimismSepolia EvmChain = "optimism_sepolia"
	Polygon         EvmChain = "polygon"
)

// Defines values for EvmTxDepositErrorCode.
const (
	EvmTxDepositEmptyChainId                    EvmTxDepositErrorCode = "EvmTxDepositEmptyChainId"
	EvmTxDepositEmptyData                       EvmTxDepositErrorCode = "EvmTxDepositEmptyData"
	EvmTxDepositEmptyReceiver                   EvmTxDepositErrorCode = "EvmTxDepositEmptyReceiver"
	EvmTxDepositInvalidDepositEncoding          EvmTxDepositErrorCode = "EvmTxDepositInvalidDepositEncoding"
	EvmTxDepositInvalidValidatorKey             EvmTxDepositErrorCode = "EvmTxDepositInvalidValidatorKey"
	EvmTxDepositMissingDepositArg               EvmTxDepositErrorCode = "EvmTxDepositMissingDepositArg"
	EvmTxDepositNoAbi                           EvmTxDepositErrorCode = "EvmTxDepositNoAbi"
	EvmTxDepositNoDepositFunction               EvmTxDepositErrorCode = "EvmTxDepositNoDepositFunction"
	EvmTxDepositReceiverMismatch                EvmTxDepositErrorCode = "EvmTxDepositReceiverMismatch"
	EvmTxDepositUnexpectedDataLength            EvmTxDepositErrorCode = "EvmTxDepositUnexpectedDataLength"
	EvmTxDepositUnexpectedFunctionName          EvmTxDepositErrorCode = "EvmTxDepositUnexpectedFunctionName"
	EvmTxDepositUnexpectedValidatorKey          EvmTxDepositErrorCode = "EvmTxDepositUnexpectedValidatorKey"
	EvmTxDepositUnexpectedValue                 EvmTxDepositErrorCode = "EvmTxDepositUnexpectedValue"
	EvmTxDepositUnexpectedWithdrawalCredentials EvmTxDepositErrorCode = "EvmTxDepositUnexpectedWithdrawalCredentials"
	EvmTxDepositUnresolvedRole                  EvmTxDepositErrorCode = "EvmTxDepositUnresolvedRole"
	EvmTxDepositValidatorKeyNotInRole           EvmTxDepositErrorCode = "EvmTxDepositValidatorKeyNotInRole"
	EvmTxDepositWrongDepositArgType             EvmTxDepositErrorCode = "EvmTxDepositWrongDepositArgType"
)

// Defines values for ExecutionSource.
const (
	SignRequest    ExecutionSource = "SignRequest"
	UserInvocation ExecutionSource = "UserInvocation"
)

// Defines values for ExplicitScopes.
const (
	Export                              ExplicitScopes = "export:*"
	ExportUser                          ExplicitScopes = "export:user:*"
	ExportUserComplete                  ExplicitScopes = "export:user:complete"
	ExportUserInit                      ExplicitScopes = "export:user:init"
	Manage                              ExplicitScopes = "manage:*"
	ManageAuthMigrationIdentityAdd      ExplicitScopes = "manage:authMigration:identity:add"
	ManageAuthMigrationIdentityRemove   ExplicitScopes = "manage:authMigration:identity:remove"
	ManageAuthMigrationUserUpdate       ExplicitScopes = "manage:authMigration:user:update"
	ManageContact                       ExplicitScopes = "manage:contact:*"
	ManageContactCreate                 ExplicitScopes = "manage:contact:create"
	ManageContactDelete                 ExplicitScopes = "manage:contact:delete"
	ManageContactGet                    ExplicitScopes = "manage:contact:get"
	ManageContactList                   ExplicitScopes = "manage:contact:list"
	ManageContactUpdate                 ExplicitScopes = "manage:contact:update:*"
	ManageContactUpdateAddresses        ExplicitScopes = "manage:contact:update:addresses"
	ManageContactUpdateEditPolicy       ExplicitScopes = "manage:contact:update:editPolicy"
	ManageContactUpdateMetadata         ExplicitScopes = "manage:contact:update:metadata"
	ManageContactUpdateName             ExplicitScopes = "manage:contact:update:name"
	ManageContactUpdateOwner            ExplicitScopes = "manage:contact:update:owner"
	ManageEmail                         ExplicitScopes = "manage:email"
	ManageExport                        ExplicitScopes = "manage:export:*"
	ManageExportOrg                     ExplicitScopes = "manage:export:org:*"
	ManageExportOrgGet                  ExplicitScopes = "manage:export:org:get"
	ManageExportUser                    ExplicitScopes = "manage:export:user:*"
	ManageExportUserDelete              ExplicitScopes = "manage:export:user:delete"
	ManageExportUserList                ExplicitScopes = "manage:export:user:list"
	ManageIdentity                      ExplicitScopes = "manage:identity:*"
	ManageIdentityAdd                   ExplicitScopes = "manage:identity:add"
	ManageIdentityList                  ExplicitScopes = "manage:identity:list"
	ManageIdentityRemove                ExplicitScopes = "manage:identity:remove"
	ManageIdentityVerify                ExplicitScopes = "manage:identity:verify"
	ManageKey                           ExplicitScopes = "manage:key:*"
	ManageKeyCreate                     ExplicitScopes = "manage:key:create"
	ManageKeyDelete                     ExplicitScopes = "manage:key:delete"
	ManageKeyGet                        ExplicitScopes = "manage:key:get"
	ManageKeyHistoryTxList              ExplicitScopes = "manage:key:history:tx:list"
	ManageKeyImport                     ExplicitScopes = "manage:key:import"
	ManageKeyList                       ExplicitScopes = "manage:key:list"
	ManageKeyListRoles                  ExplicitScopes = "manage:key:listRoles"
	ManageKeyReadonly                   ExplicitScopes = "manage:key:readonly"
	ManageKeyUpdate                     ExplicitScopes = "manage:key:update:*"
	ManageKeyUpdateEditPolicy           ExplicitScopes = "manage:key:update:editPolicy"
	ManageKeyUpdateEnabled              ExplicitScopes = "manage:key:update:enabled"
	ManageKeyUpdateMetadata             ExplicitScopes = "manage:key:update:metadata"
	ManageKeyUpdateOwner                ExplicitScopes = "manage:key:update:owner"
	ManageKeyUpdatePolicy               ExplicitScopes = "manage:key:update:policy"
	ManageMfa                           ExplicitScopes = "manage:mfa:*"
	ManageMfaList                       ExplicitScopes = "manage:mfa:list"
	ManageMfaReadonly                   ExplicitScopes = "manage:mfa:readonly"
	ManageMfaRegister                   ExplicitScopes = "manage:mfa:register:*"
	ManageMfaRegisterEmail              ExplicitScopes = "manage:mfa:register:email"
	ManageMfaRegisterFido               ExplicitScopes = "manage:mfa:register:fido"
	ManageMfaRegisterTotp               ExplicitScopes = "manage:mfa:register:totp"
	ManageMfaUnregister                 ExplicitScopes = "manage:mfa:unregister:*"
	ManageMfaUnregisterFido             ExplicitScopes = "manage:mfa:unregister:fido"
	ManageMfaUnregisterTotp             ExplicitScopes = "manage:mfa:unregister:totp"
	ManageMfaVerify                     ExplicitScopes = "manage:mfa:verify:*"
	ManageMfaVerifyTotp                 ExplicitScopes = "manage:mfa:verify:totp"
	ManageMfaVote                       ExplicitScopes = "manage:mfa:vote:*"
	ManageMfaVoteCs                     ExplicitScopes = "manage:mfa:vote:cs"
	ManageMfaVoteEmail                  ExplicitScopes = "manage:mfa:vote:email"
	ManageMfaVoteFido                   ExplicitScopes = "manage:mfa:vote:fido"
	ManageMfaVoteTotp                   ExplicitScopes = "manage:mfa:vote:totp"
	ManageMmi                           ExplicitScopes = "manage:mmi:*"
	ManageMmiDelete                     ExplicitScopes = "manage:mmi:delete"
	ManageMmiGet                        ExplicitScopes = "manage:mmi:get"
	ManageMmiList                       ExplicitScopes = "manage:mmi:list"
	ManageMmiReadonly                   ExplicitScopes = "manage:mmi:readonly"
	ManageMmiReject                     ExplicitScopes = "manage:mmi:reject"
	ManageOrg                           ExplicitScopes = "manage:org:*"
	ManageOrgAddUser                    ExplicitScopes = "manage:org:addUser"
	ManageOrgCreate                     ExplicitScopes = "manage:org:create"
	ManageOrgDeleteUser                 ExplicitScopes = "manage:org:deleteUser"
	ManageOrgGet                        ExplicitScopes = "manage:org:get"
	ManageOrgInviteAlien                ExplicitScopes = "manage:org:inviteAlien"
	ManageOrgInviteUser                 ExplicitScopes = "manage:org:inviteUser"
	ManageOrgListUsers                  ExplicitScopes = "manage:org:listUsers"
	ManageOrgMetricsQuery               ExplicitScopes = "manage:org:metrics:query"
	ManageOrgReadonly                   ExplicitScopes = "manage:org:readonly"
	ManageOrgUpdateMembership           ExplicitScopes = "manage:org:updateMembership"
	ManageOrgUserGet                    ExplicitScopes = "manage:org:user:get"
	ManageOrgUserResetMfa               ExplicitScopes = "manage:org:user:resetMfa"
	ManagePolicy                        ExplicitScopes = "manage:policy:*"
	ManagePolicyCreate                  ExplicitScopes = "manage:policy:create"
	ManagePolicyCreateImportKey         ExplicitScopes = "manage:policy:createImportKey"
	ManagePolicyDelete                  ExplicitScopes = "manage:policy:delete"
	ManagePolicyGet                     ExplicitScopes = "manage:policy:get"
	ManagePolicyInvoke                  ExplicitScopes = "manage:policy:invoke"
	ManagePolicyList                    ExplicitScopes = "manage:policy:list"
	ManagePolicySecrets                 ExplicitScopes = "manage:policy:secrets:*"
	ManagePolicySecretsGet              ExplicitScopes = "manage:policy:secrets:get"
	ManagePolicySecretsUpdate           ExplicitScopes = "manage:policy:secrets:update:*"
	ManagePolicySecretsUpdateEditPolicy ExplicitScopes = "manage:policy:secrets:update:editPolicy"
	ManagePolicySecretsUpdateValues     ExplicitScopes = "manage:policy:secrets:update:values"
	ManagePolicyUpdate                  ExplicitScopes = "manage:policy:update:*"
	ManagePolicyUpdateEditPolicy        ExplicitScopes = "manage:policy:update:editPolicy"
	ManagePolicyUpdateMetadata          ExplicitScopes = "manage:policy:update:metadata"
	ManagePolicyUpdateName              ExplicitScopes = "manage:policy:update:name"
	ManagePolicyUpdateOwner             ExplicitScopes = "manage:policy:update:owner"
	ManagePolicyUpdateRule              ExplicitScopes = "manage:policy:update:rule"
	ManagePolicyWasm                    ExplicitScopes = "manage:policy:wasm:*"
	ManagePolicyWasmUpload              ExplicitScopes = "manage:policy:wasm:upload"
	ManageReadonly                      ExplicitScopes = "manage:readonly"
	ManageRole                          ExplicitScopes = "manage:role:*"
	ManageRoleCreate                    ExplicitScopes = "manage:role:create"
	ManageRoleDelete                    ExplicitScopes = "manage:role:delete"
	ManageRoleGet                       ExplicitScopes = "manage:role:get:*"
	ManageRoleGetKeys                   ExplicitScopes = "manage:role:get:keys"
	ManageRoleGetKeysGet                ExplicitScopes = "manage:role:get:keys:get"
	ManageRoleGetKeysList               ExplicitScopes = "manage:role:get:keys:list"
	ManageRoleGetUsers                  ExplicitScopes = "manage:role:get:users"
	ManageRoleHistoryTxList             ExplicitScopes = "manage:role:history:tx:list"
	ManageRoleList                      ExplicitScopes = "manage:role:list"
	ManageRoleReadonly                  ExplicitScopes = "manage:role:readonly"
	ManageRoleUpdate                    ExplicitScopes = "manage:role:update:*"
	ManageRoleUpdateEditPolicy          ExplicitScopes = "manage:role:update:editPolicy"
	ManageRoleUpdateEnabled             ExplicitScopes = "manage:role:update:enabled"
	ManageRoleUpdateKey                 ExplicitScopes = "manage:role:update:key:*"
	ManageRoleUpdateKeyAdd              ExplicitScopes = "manage:role:update:key:add"
	ManageRoleUpdateKeyRemove           ExplicitScopes = "manage:role:update:key:remove"
	ManageRoleUpdatePolicy              ExplicitScopes = "manage:role:update:policy"
	ManageRoleUpdateUser                ExplicitScopes = "manage:role:update:user:*"
	ManageRoleUpdateUserAdd             ExplicitScopes = "manage:role:update:user:add"
	ManageRoleUpdateUserRemove          ExplicitScopes = "manage:role:update:user:remove"
	ManageSession                       ExplicitScopes = "manage:session:*"
	ManageSessionCreate                 ExplicitScopes = "manage:session:create"
	ManageSessionExtend                 ExplicitScopes = "manage:session:extend"
	ManageSessionGet                    ExplicitScopes = "manage:session:get"
	ManageSessionList                   ExplicitScopes = "manage:session:list"
	ManageSessionReadonly               ExplicitScopes = "manage:session:readonly"
	ManageSessionRevoke                 ExplicitScopes = "manage:session:revoke"
	Mmi                                 ExplicitScopes = "mmi:*"
	OrgAccess                           ExplicitScopes = "orgAccess:*"
	OrgAccessChild                      ExplicitScopes = "orgAccess:child:*"
	Sign                                ExplicitScopes = "sign:*"
	SignAva                             ExplicitScopes = "sign:ava"
	SignBabylon                         ExplicitScopes = "sign:babylon:*"
	SignBabylonCovenant                 ExplicitScopes = "sign:babylon:covenant"
	SignBabylonEots                     ExplicitScopes = "sign:babylon:eots:*"
	SignBabylonEotsNonces               ExplicitScopes = "sign:babylon:eots:nonces"
	SignBabylonEotsSign                 ExplicitScopes = "sign:babylon:eots:sign"
	SignBabylonRegistration             ExplicitScopes = "sign:babylon:registration"
	SignBabylonStaking                  ExplicitScopes = "sign:babylon:staking:*"
	SignBabylonStakingDeposit           ExplicitScopes = "sign:babylon:staking:deposit"
	SignBabylonStakingSlash             ExplicitScopes = "sign:babylon:staking:slash"
	SignBabylonStakingUnbond            ExplicitScopes = "sign:babylon:staking:unbond"
	SignBabylonStakingWithdraw          ExplicitScopes = "sign:babylon:staking:withdraw"
	SignBlob                            ExplicitScopes = "sign:blob"
	SignBtc                             ExplicitScopes = "sign:btc:*"
	SignBtcMessage                      ExplicitScopes = "sign:btc:message:*"
	SignBtcMessageLegacy                ExplicitScopes = "sign:btc:message:legacy"
	SignBtcMessageSegwit                ExplicitScopes = "sign:btc:message:segwit"
	SignBtcPsbt                         ExplicitScopes = "sign:btc:psbt:*"
	SignBtcPsbtDoge                     ExplicitScopes = "sign:btc:psbt:doge"
	SignBtcPsbtLegacy                   ExplicitScopes = "sign:btc:psbt:legacy"
	SignBtcPsbtLtcSegwit                ExplicitScopes = "sign:btc:psbt:ltcSegwit"
	SignBtcPsbtSegwit                   ExplicitScopes = "sign:btc:psbt:segwit"
	SignBtcPsbtTaproot                  ExplicitScopes = "sign:btc:psbt:taproot"
	SignBtcSegwit                       ExplicitScopes = "sign:btc:segwit"
	SignBtcTaproot                      ExplicitScopes = "sign:btc:taproot"
	SignDiffieHellman                   ExplicitScopes = "sign:diffieHellman"
	SignEth2                            ExplicitScopes = "sign:eth2:*"
	SignEth2Stake                       ExplicitScopes = "sign:eth2:stake"
	SignEth2Unstake                     ExplicitScopes = "sign:eth2:unstake"
	SignEth2Validate                    ExplicitScopes = "sign:eth2:validate"
	SignEvm                             ExplicitScopes = "sign:evm:*"
	SignEvmEip191                       ExplicitScopes = "sign:evm:eip191"
	SignEvmEip712                       ExplicitScopes = "sign:evm:eip712"
	SignEvmTx                           ExplicitScopes = "sign:evm:tx"
	SignMmi                             ExplicitScopes = "sign:mmi"
	SignSolana                          ExplicitScopes = "sign:solana"
	SignSui                             ExplicitScopes = "sign:sui"
	SignTendermint                      ExplicitScopes = "sign:tendermint"
)

// Defines values for FeeType.
const (
	Sats       FeeType = "sats"
	SatsPerKwu FeeType = "sats_per_kwu"
	SatsPerVb  FeeType = "sats_per_vb"
)

// Defines values for ForbiddenErrorCode.
const (
	AutoAddBlsKeyToProtectedRole        ForbiddenErrorCode = "AutoAddBlsKeyToProtectedRole"
	CannotAssumeIdentity                ForbiddenErrorCode = "CannotAssumeIdentity"
	CannotCreateOrg                     ForbiddenErrorCode = "CannotCreateOrg"
	ChainIdNotAllowed                   ForbiddenErrorCode = "ChainIdNotAllowed"
	ContactNotInOrg                     ForbiddenErrorCode = "ContactNotInOrg"
	DisabledRole                        ForbiddenErrorCode = "DisabledRole"
	EmailOtpNotConfigured               ForbiddenErrorCode = "EmailOtpNotConfigured"
	ExpectedUserSession                 ForbiddenErrorCode = "ExpectedUserSession"
	FidoRequiredToRemoveTotp            ForbiddenErrorCode = "FidoRequiredToRemoveTotp"
	FullSessionRequired                 ForbiddenErrorCode = "FullSessionRequired"
	ImproperSessionScope                ForbiddenErrorCode = "ImproperSessionScope"
	InvalidArn                          ForbiddenErrorCode = "InvalidArn"
	InvalidAuthHeader                   ForbiddenErrorCode = "InvalidAuthHeader"
	InvalidOrg                          ForbiddenErrorCode = "InvalidOrg"
	InvalidOrgMembershipRoleChange      ForbiddenErrorCode = "InvalidOrgMembershipRoleChange"
	InvalidRole                         ForbiddenErrorCode = "InvalidRole"
	KeyDisabled                         ForbiddenErrorCode = "KeyDisabled"
	KeyNotInRole                        ForbiddenErrorCode = "KeyNotInRole"
	LegacySessionCannotHaveScopeCeiling ForbiddenErrorCode = "LegacySessionCannotHaveScopeCeiling"
	MemberRoleForbidden                 ForbiddenErrorCode = "MemberRoleForbidden"
	MfaChallengeExpired                 ForbiddenErrorCode = "MfaChallengeExpired"
	MfaConfirmationCodeMismatch         ForbiddenErrorCode = "MfaConfirmationCodeMismatch"
	MfaDisallowedApprover               ForbiddenErrorCode = "MfaDisallowedApprover"
	MfaDisallowedIdentity               ForbiddenErrorCode = "MfaDisallowedIdentity"
	MfaHttpRequestMismatch              ForbiddenErrorCode = "MfaHttpRequestMismatch"
	MfaNotApprovedYet                   ForbiddenErrorCode = "MfaNotApprovedYet"
	MfaNotConfigured                    ForbiddenErrorCode = "MfaNotConfigured"
	MfaOrgRequirementNotMet             ForbiddenErrorCode = "MfaOrgRequirementNotMet"
	MfaRegistrationDisallowed           ForbiddenErrorCode = "MfaRegistrationDisallowed"
	MfaRemoveBelowMin                   ForbiddenErrorCode = "MfaRemoveBelowMin"
	MfaTotpBadCode                      ForbiddenErrorCode = "MfaTotpBadCode"
	MfaTotpBadConfiguration             ForbiddenErrorCode = "MfaTotpBadConfiguration"
	MfaTotpRateLimit                    ForbiddenErrorCode = "MfaTotpRateLimit"
	MfaTypeNotAllowed                   ForbiddenErrorCode = "MfaTypeNotAllowed"
	MustBeFullMember                    ForbiddenErrorCode = "MustBeFullMember"
	OidcIdentityLimitReached            ForbiddenErrorCode = "OidcIdentityLimitReached"
	OidcIssuerNotAllowedForMemberRole   ForbiddenErrorCode = "OidcIssuerNotAllowedForMemberRole"
	OidcNoMemberRolesAllowed            ForbiddenErrorCode = "OidcNoMemberRolesAllowed"
	OidcScopeCeilingMissing             ForbiddenErrorCode = "OidcScopeCeilingMissing"
	OidcUserNotFound                    ForbiddenErrorCode = "OidcUserNotFound"
	OperationNotAllowed                 ForbiddenErrorCode = "OperationNotAllowed"
	OrgDisabled                         ForbiddenErrorCode = "OrgDisabled"
	OrgExportRetrievalDisabled          ForbiddenErrorCode = "OrgExportRetrievalDisabled"
	OrgFlagNotSet                       ForbiddenErrorCode = "OrgFlagNotSet"
	OrgIdMismatch                       ForbiddenErrorCode = "OrgIdMismatch"
	OrgNotFound                         ForbiddenErrorCode = "OrgNotFound"
	OrgWithoutOwner                     ForbiddenErrorCode = "OrgWithoutOwner"
	OrphanedUser                        ForbiddenErrorCode = "OrphanedUser"
	PasskeyLoginDisabled                ForbiddenErrorCode = "PasskeyLoginDisabled"
	PasskeyNotRegistered                ForbiddenErrorCode = "PasskeyNotRegistered"
	RemoveKeyFromRoleUserNotAllowed     ForbiddenErrorCode = "RemoveKeyFromRoleUserNotAllowed"
	RemoveLastOidcIdentity              ForbiddenErrorCode = "RemoveLastOidcIdentity"
	RoleInParentOrgNotAllowed           ForbiddenErrorCode = "RoleInParentOrgNotAllowed"
	ScopedNameNotFound                  ForbiddenErrorCode = "ScopedNameNotFound"
	SelfDelete                          ForbiddenErrorCode = "SelfDelete"
	SelfDisable                         ForbiddenErrorCode = "SelfDisable"
	SentryDisallowed                    ForbiddenErrorCode = "SentryDisallowed"
	SessionAuthTokenExpired             ForbiddenErrorCode = "SessionAuthTokenExpired"
	SessionChanged                      ForbiddenErrorCode = "SessionChanged"
	SessionExpired                      ForbiddenErrorCode = "SessionExpired"
	SessionForWrongOrg                  ForbiddenErrorCode = "SessionForWrongOrg"
	SessionInvalidAuthToken             ForbiddenErrorCode = "SessionInvalidAuthToken"
	SessionInvalidEpochToken            ForbiddenErrorCode = "SessionInvalidEpochToken"
	SessionInvalidRefreshToken          ForbiddenErrorCode = "SessionInvalidRefreshToken"
	SessionNotFound                     ForbiddenErrorCode = "SessionNotFound"
	SessionPossiblyStolenToken          ForbiddenErrorCode = "SessionPossiblyStolenToken"
	SessionRefreshTokenExpired          ForbiddenErrorCode = "SessionRefreshTokenExpired"
	SessionRevoked                      ForbiddenErrorCode = "SessionRevoked"
	SessionRoleChanged                  ForbiddenErrorCode = "SessionRoleChanged"
	SessionWithoutAnyScopeUnder         ForbiddenErrorCode = "SessionWithoutAnyScopeUnder"
	SiweChallengeExpired                ForbiddenErrorCode = "SiweChallengeExpired"
	SiweMessageInvalidSignature         ForbiddenErrorCode = "SiweMessageInvalidSignature"
	SiweMessageNotValid                 ForbiddenErrorCode = "SiweMessageNotValid"
	TotpAlreadyConfigured               ForbiddenErrorCode = "TotpAlreadyConfigured"
	TotpConfigurationChanged            ForbiddenErrorCode = "TotpConfigurationChanged"
	UserDisabled                        ForbiddenErrorCode = "UserDisabled"
	UserExportDisabled                  ForbiddenErrorCode = "UserExportDisabled"
	UserExportRequestInvalid            ForbiddenErrorCode = "UserExportRequestInvalid"
	UserExportRequestNotInOrg           ForbiddenErrorCode = "UserExportRequestNotInOrg"
	UserNotContactOwner                 ForbiddenErrorCode = "UserNotContactOwner"
	UserNotInOrg                        ForbiddenErrorCode = "UserNotInOrg"
	UserNotInRole                       ForbiddenErrorCode = "UserNotInRole"
	UserNotKeyOwner                     ForbiddenErrorCode = "UserNotKeyOwner"
	UserNotOrgOwner                     ForbiddenErrorCode = "UserNotOrgOwner"
	UserNotOriginalKeyOwner             ForbiddenErrorCode = "UserNotOriginalKeyOwner"
	UserNotPolicyOwner                  ForbiddenErrorCode = "UserNotPolicyOwner"
	UserRoleUnprivileged                ForbiddenErrorCode = "UserRoleUnprivileged"
	WrongMfaEmailOtpJwt                 ForbiddenErrorCode = "WrongMfaEmailOtpJwt"
)

// Defines values for HttpRequestCmpEq.
const (
	Eq HttpRequestCmpEq = "Eq"
)

// Defines values for InternalErrorCode.
const (
	AvaSignCredsMissing                 InternalErrorCode = "AvaSignCredsMissing"
	AvaSignSignatureMissing             InternalErrorCode = "AvaSignSignatureMissing"
	BabylonCovSignError                 InternalErrorCode = "BabylonCovSignError"
	ClaimsParseError                    InternalErrorCode = "ClaimsParseError"
	CognitoDeleteUserError              InternalErrorCode = "CognitoDeleteUserError"
	CognitoGetUser                      InternalErrorCode = "CognitoGetUser"
	CognitoGetUserError                 InternalErrorCode = "CognitoGetUserError"
	CognitoListUsersError               InternalErrorCode = "CognitoListUsersError"
	CognitoResendUserInvitation         InternalErrorCode = "CognitoResendUserInvitation"
	CognitoSetUserPasswordError         InternalErrorCode = "CognitoSetUserPasswordError"
	CreateEotsNoncesError               InternalErrorCode = "CreateEotsNoncesError"
	CreateImportKeyError                InternalErrorCode = "CreateImportKeyError"
	CreateKeyError                      InternalErrorCode = "CreateKeyError"
	CreatePolicyImportKeyError          InternalErrorCode = "CreatePolicyImportKeyError"
	CubistSignerError                   InternalErrorCode = "CubistSignerError"
	CwListMetricsError                  InternalErrorCode = "CwListMetricsError"
	CwPutMetricDataError                InternalErrorCode = "CwPutMetricDataError"
	DbDeleteError                       InternalErrorCode = "DbDeleteError"
	DbGetError                          InternalErrorCode = "DbGetError"
	DbGetItemsError                     InternalErrorCode = "DbGetItemsError"
	DbPutError                          InternalErrorCode = "DbPutError"
	DbQueryError                        InternalErrorCode = "DbQueryError"
	DbUpdateError                       InternalErrorCode = "DbUpdateError"
	DbWriteError                        InternalErrorCode = "DbWriteError"
	DeserializeEncryptedExportKeyError  InternalErrorCode = "DeserializeEncryptedExportKeyError"
	EmailConstructionError              InternalErrorCode = "EmailConstructionError"
	EmailTemplateRender                 InternalErrorCode = "EmailTemplateRender"
	EmptyUpdateModifiedActions          InternalErrorCode = "EmptyUpdateModifiedActions"
	EmptyUpdateModifiedObject           InternalErrorCode = "EmptyUpdateModifiedObject"
	EotsSignError                       InternalErrorCode = "EotsSignError"
	ExpectedRoleSession                 InternalErrorCode = "ExpectedRoleSession"
	FidoKeyAssociatedWithMultipleUsers  InternalErrorCode = "FidoKeyAssociatedWithMultipleUsers"
	GenericInternalError                InternalErrorCode = "GenericInternalError"
	GetAwsSecretError                   InternalErrorCode = "GetAwsSecretError"
	HistoricalTxBodyMissing             InternalErrorCode = "HistoricalTxBodyMissing"
	InconsistentMultiValueTestAndSet    InternalErrorCode = "InconsistentMultiValueTestAndSet"
	InternalHeaderMissing               InternalErrorCode = "InternalHeaderMissing"
	InvalidAlias                        InternalErrorCode = "InvalidAlias"
	InvalidBtcAddress                   InternalErrorCode = "InvalidBtcAddress"
	InvalidEmailAddress                 InternalErrorCode = "InvalidEmailAddress"
	InvalidInternalHeaderValue          InternalErrorCode = "InvalidInternalHeaderValue"
	InvalidOperation                    InternalErrorCode = "InvalidOperation"
	InvalidPkForMaterialId              InternalErrorCode = "InvalidPkForMaterialId"
	InvalidThirdPartyIdentity           InternalErrorCode = "InvalidThirdPartyIdentity"
	InvalidThrottleId                   InternalErrorCode = "InvalidThrottleId"
	InvalidUploadObjectId               InternalErrorCode = "InvalidUploadObjectId"
	KmsDisableKeyError                  InternalErrorCode = "KmsDisableKeyError"
	KmsEnableKeyError                   InternalErrorCode = "KmsEnableKeyError"
	KmsGenerateRandomError              InternalErrorCode = "KmsGenerateRandomError"
	KmsGenerateRandomNoResponseError    InternalErrorCode = "KmsGenerateRandomNoResponseError"
	LambdaFailure                       InternalErrorCode = "LambdaFailure"
	LambdaInvokeError                   InternalErrorCode = "LambdaInvokeError"
	LambdaNoResponseError               InternalErrorCode = "LambdaNoResponseError"
	LambdaUnparsableResponse            InternalErrorCode = "LambdaUnparsableResponse"
	MalformedTotpBytes                  InternalErrorCode = "MalformedTotpBytes"
	ManagedStateMissing                 InternalErrorCode = "ManagedStateMissing"
	MaterialIdError                     InternalErrorCode = "MaterialIdError"
	MissingKeyMetadata                  InternalErrorCode = "MissingKeyMetadata"
	MissingUserEmail                    InternalErrorCode = "MissingUserEmail"
	NoMaterialId                        InternalErrorCode = "NoMaterialId"
	OidcAuthWithoutOrg                  InternalErrorCode = "OidcAuthWithoutOrg"
	OidcIdentityHeaderMissing           InternalErrorCode = "OidcIdentityHeaderMissing"
	OidcIdentityParseError              InternalErrorCode = "OidcIdentityParseError"
	OidcIssuerInvalidJwk                InternalErrorCode = "OidcIssuerInvalidJwk"
	OidcOrgMismatch                     InternalErrorCode = "OidcOrgMismatch"
	OrgParentLoop                       InternalErrorCode = "OrgParentLoop"
	ParentOrgNotFound                   InternalErrorCode = "ParentOrgNotFound"
	ParseDerivationPathError            InternalErrorCode = "ParseDerivationPathError"
	PasswordHashParseError              InternalErrorCode = "PasswordHashParseError"
	PolicyEngineError                   InternalErrorCode = "PolicyEngineError"
	PolicyEngineNotFound                InternalErrorCode = "PolicyEngineNotFound"
	PolicySecretsEncryptionError        InternalErrorCode = "PolicySecretsEncryptionError"
	ReEncryptUserExport                 InternalErrorCode = "ReEncryptUserExport"
	RequestLocalStateAlreadySet         InternalErrorCode = "RequestLocalStateAlreadySet"
	ReqwestError                        InternalErrorCode = "ReqwestError"
	ResolvedParentOrgWithNoScopeCeiling InternalErrorCode = "ResolvedParentOrgWithNoScopeCeiling"
	S3BuildError                        InternalErrorCode = "S3BuildError"
	S3CopyError                         InternalErrorCode = "S3CopyError"
	S3DeleteObjectsError                InternalErrorCode = "S3DeleteObjectsError"
	S3DownloadError                     InternalErrorCode = "S3DownloadError"
	S3ListObjectsError                  InternalErrorCode = "S3ListObjectsError"
	S3PresignedUrlError                 InternalErrorCode = "S3PresignedUrlError"
	S3UploadError                       InternalErrorCode = "S3UploadError"
	SecretNotFound                      InternalErrorCode = "SecretNotFound"
	SendMailError                       InternalErrorCode = "SendMailError"
	SerdeError                          InternalErrorCode = "SerdeError"
	SerializeEncryptedExportKeyError    InternalErrorCode = "SerializeEncryptedExportKeyError"
	SessionOrgIdMissing                 InternalErrorCode = "SessionOrgIdMissing"
	SnsGetSubscriptionAttributesError   InternalErrorCode = "SnsGetSubscriptionAttributesError"
	SnsPublishBatchError                InternalErrorCode = "SnsPublishBatchError"
	SnsSetSubscriptionAttributesError   InternalErrorCode = "SnsSetSubscriptionAttributesError"
	SnsSubscribeError                   InternalErrorCode = "SnsSubscribeError"
	SnsSubscriptionAttributesMissing    InternalErrorCode = "SnsSubscriptionAttributesMissing"
	SnsUnsubscribeError                 InternalErrorCode = "SnsUnsubscribeError"
	SplitSignerError                    InternalErrorCode = "SplitSignerError"
	SystemTimeError                     InternalErrorCode = "SystemTimeError"
	TestAndSetError                     InternalErrorCode = "TestAndSetError"
	TsQueryError                        InternalErrorCode = "TsQueryError"
	TsWriteError                        InternalErrorCode = "TsWriteError"
	UncheckedOrg                        InternalErrorCode = "UncheckedOrg"
)

// Defines values for InviteKind.
const (
	Cognito   InviteKind = "Cognito"
	IdpAndSso InviteKind = "IdpAndSso"
	Sso       InviteKind = "Sso"
)

// Defines values for JsonKeyPackageEnglishMnemonicMaterialType.
const (
	EnglishMnemonic JsonKeyPackageEnglishMnemonicMaterialType = "english_mnemonic"
)

// Defines values for JsonKeyPackageRawSecretMaterialType.
const (
	RawSecret JsonKeyPackageRawSecretMaterialType = "raw_secret"
)

// Defines values for KeyType.
const (
	BabyJubjub            KeyType = "BabyJubjub"
	BabylonCov            KeyType = "BabylonCov"
	BabylonEots           KeyType = "BabylonEots"
	BlsAvaIcm             KeyType = "BlsAvaIcm"
	BlsInactive           KeyType = "BlsInactive"
	BlsPub                KeyType = "BlsPub"
	Ed25519AptosAddr      KeyType = "Ed25519AptosAddr"
	Ed25519CardanoAddrVk  KeyType = "Ed25519CardanoAddrVk"
	Ed25519SolanaAddr     KeyType = "Ed25519SolanaAddr"
	Ed25519StellarAddr    KeyType = "Ed25519StellarAddr"
	Ed25519SubstrateAddr  KeyType = "Ed25519SubstrateAddr"
	Ed25519SuiAddr        KeyType = "Ed25519SuiAddr"
	Ed25519TendermintAddr KeyType = "Ed25519TendermintAddr"
	Ed25519TonAddr        KeyType = "Ed25519TonAddr"
	Ed25519XrpAddr        KeyType = "Ed25519XrpAddr"
	Mnemonic              KeyType = "Mnemonic"
	P256CosmosAddr        KeyType = "P256CosmosAddr"
	P256Neo3Addr          KeyType = "P256Neo3Addr"
	P256OntologyAddr      KeyType = "P256OntologyAddr"
	SchnorrKaspaAddr      KeyType = "SchnorrKaspaAddr"
	SchnorrKaspaTestAddr  KeyType = "SchnorrKaspaTestAddr"
	SecpAvaAddr           KeyType = "SecpAvaAddr"
	SecpAvaTestAddr       KeyType = "SecpAvaTestAddr"
	SecpBtc               KeyType = "SecpBtc"
	SecpBtcLegacy         KeyType = "SecpBtcLegacy"
	SecpBtcLegacyTest     KeyType = "SecpBtcLegacyTest"
	SecpBtcTest           KeyType = "SecpBtcTest"
	SecpCosmosAddr        KeyType = "SecpCosmosAddr"
	SecpDogeAddr          KeyType = "SecpDogeAddr"
	SecpDogeTestAddr      KeyType = "SecpDogeTestAddr"
	SecpEthAddr           KeyType = "SecpEthAddr"
	SecpKaspaAddr         KeyType = "SecpKaspaAddr"
	SecpKaspaTestAddr     KeyType = "SecpKaspaTestAddr"
	SecpLtc               KeyType = "SecpLtc"
	SecpLtcTest           KeyType = "SecpLtcTest"
	SecpTronAddr          KeyType = "SecpTronAddr"
	SecpXrpAddr           KeyType = "SecpXrpAddr"
	Stark                 KeyType = "Stark"
	TaprootBtc            KeyType = "TaprootBtc"
	TaprootBtcTest        KeyType = "TaprootBtcTest"
)

// Defines values for MemberRole.
const (
	Alien  MemberRole = "Alien"
	Member MemberRole = "Member"
	Owner  MemberRole = "Owner"
)

// Defines values for MembershipStatus.
const (
	Disabled MembershipStatus = "disabled"
	Enabled  MembershipStatus = "enabled"
)

// Defines values for MfaProtectedAction.
const (
	AddIdentity   MfaProtectedAction = "AddIdentity"
	Default       MfaProtectedAction = "Default"
	ExtendSession MfaProtectedAction = "ExtendSession"
	KeyExport     MfaProtectedAction = "KeyExport"
	Login         MfaProtectedAction = "Login"
	RegisterMfa   MfaProtectedAction = "RegisterMfa"
)

// Defines values for MfaRequestInfoProvenance.
const (
	MfaRequestInfoProvenanceEditPolicy MfaRequestInfoProvenance = "EditPolicy"
	MfaRequestInfoProvenanceKey        MfaRequestInfoProvenance = "Key"
	MfaRequestInfoProvenanceKeyInRole  MfaRequestInfoProvenance = "KeyInRole"
	MfaRequestInfoProvenanceRole       MfaRequestInfoProvenance = "Role"
	MfaRequestInfoProvenanceUser       MfaRequestInfoProvenance = "User"
)

// Defines values for MfaVote.
const (
	Approve MfaVote = "approve"
	Reject  MfaVote = "reject"
)

// Defines values for MsgStatusPendingStatus.
const (
	MsgStatusPendingStatusPending MsgStatusPendingStatus = "Pending"
)

// Defines values for MsgStatusRejectedStatus.
const (
	MsgStatusRejectedStatusRejected MsgStatusRejectedStatus = "Rejected"
)

// Defines values for MsgStatusSignedStatus.
const (
	MsgStatusSignedStatusSigned MsgStatusSignedStatus = "Signed"
)

// Defines values for Network.
const (
	NetworkHolesky Network = "holesky"
	NetworkHoodi   Network = "hoodi"
	NetworkMainnet Network = "mainnet"
)

// Defines values for NotFoundErrorCode.
const (
	FidoChallengeNotFound        NotFoundErrorCode = "FidoChallengeNotFound"
	FidoKeyNotFound              NotFoundErrorCode = "FidoKeyNotFound"
	OrgExportCiphertextNotFound  NotFoundErrorCode = "OrgExportCiphertextNotFound"
	PolicySecretNotFound         NotFoundErrorCode = "PolicySecretNotFound"
	TotpChallengeNotFound        NotFoundErrorCode = "TotpChallengeNotFound"
	TotpNotConfigured            NotFoundErrorCode = "TotpNotConfigured"
	UploadObjectNotFound         NotFoundErrorCode = "UploadObjectNotFound"
	UriSegmentInvalid            NotFoundErrorCode = "UriSegmentInvalid"
	UriSegmentMissing            NotFoundErrorCode = "UriSegmentMissing"
	UserExportCiphertextNotFound NotFoundErrorCode = "UserExportCiphertextNotFound"
	UserExportRequestNotFound    NotFoundErrorCode = "UserExportRequestNotFound"
)

// Defines values for OperationKind.
const (
	AvaChainTxSign      OperationKind = "AvaChainTxSign"
	AvaSign             OperationKind = "AvaSign"
	BabylonCovSign      OperationKind = "BabylonCovSign"
	BabylonRegistration OperationKind = "BabylonRegistration"
	BabylonStaking      OperationKind = "BabylonStaking"
	BlobSign            OperationKind = "BlobSign"
	BtcMessageSign      OperationKind = "BtcMessageSign"
	BtcSign             OperationKind = "BtcSign"
	DiffieHellman       OperationKind = "DiffieHellman"
	Eip191Sign          OperationKind = "Eip191Sign"
	Eip712Sign          OperationKind = "Eip712Sign"
	EotsNonces          OperationKind = "EotsNonces"
	EotsSign            OperationKind = "EotsSign"
	Eth1Sign            OperationKind = "Eth1Sign"
	Eth2Sign            OperationKind = "Eth2Sign"
	Eth2Stake           OperationKind = "Eth2Stake"
	Eth2Unstake         OperationKind = "Eth2Unstake"
	PsbtSign            OperationKind = "PsbtSign"
	RoleUpdate          OperationKind = "RoleUpdate"
	SolanaSign          OperationKind = "SolanaSign"
	SuiSign             OperationKind = "SuiSign"
	TaprootSign         OperationKind = "TaprootSign"
	TendermintSign      OperationKind = "TendermintSign"
)

// Defines values for OrgEventDiscriminants.
const (
	OrgEventDiscriminantsBabylonEotsConcurrentSigning            OrgEventDiscriminants = "BabylonEotsConcurrentSigning"
	OrgEventDiscriminantsBilling                                 OrgEventDiscriminants = "Billing"
	OrgEventDiscriminantsEth2ConcurrentAttestationSigning        OrgEventDiscriminants = "Eth2ConcurrentAttestationSigning"
	OrgEventDiscriminantsEth2ConcurrentBlockSigning              OrgEventDiscriminants = "Eth2ConcurrentBlockSigning"
	OrgEventDiscriminantsEth2ExceededMaxUnstake                  OrgEventDiscriminants = "Eth2ExceededMaxUnstake"
	OrgEventDiscriminantsEth2InvalidAttestationSourceEpochTooLow OrgEventDiscriminants = "Eth2InvalidAttestationSourceEpochTooLow"
	OrgEventDiscriminantsEth2InvalidAttestationTargetEpochTooLow OrgEventDiscriminants = "Eth2InvalidAttestationTargetEpochTooLow"
	OrgEventDiscriminantsEth2InvalidBlockProposerSlotTooLow      OrgEventDiscriminants = "Eth2InvalidBlockProposerSlotTooLow"
	OrgEventDiscriminantsEth2Unstake                             OrgEventDiscriminants = "Eth2Unstake"
	OrgEventDiscriminantsKeyCreated                              OrgEventDiscriminants = "KeyCreated"
	OrgEventDiscriminantsMfaRejected                             OrgEventDiscriminants = "MfaRejected"
	OrgEventDiscriminantsOidcAuth                                OrgEventDiscriminants = "OidcAuth"
	OrgEventDiscriminantsPolicyChanged                           OrgEventDiscriminants = "PolicyChanged"
	OrgEventDiscriminantsSigned                                  OrgEventDiscriminants = "Signed"
	OrgEventDiscriminantsTendermintConcurrentSigning             OrgEventDiscriminants = "TendermintConcurrentSigning"
	OrgEventDiscriminantsUserExportComplete                      OrgEventDiscriminants = "UserExportComplete"
	OrgEventDiscriminantsUserExportInit                          OrgEventDiscriminants = "UserExportInit"
	OrgEventDiscriminantsWasmPolicyExecuted                      OrgEventDiscriminants = "WasmPolicyExecuted"
)

// Defines values for OrgEventFilterAll.
const (
	AllEvents OrgEventFilterAll = "All"
)

// Defines values for OrgMetricDiscriminants.
const (
	OrgMetricDiscriminantsBillingEvent   OrgMetricDiscriminants = "BillingEvent"
	OrgMetricDiscriminantsKeyCount       OrgMetricDiscriminants = "KeyCount"
	OrgMetricDiscriminantsOidcLoginEvent OrgMetricDiscriminants = "OidcLoginEvent"
	OrgMetricDiscriminantsSignEvent      OrgMetricDiscriminants = "SignEvent"
	OrgMetricDiscriminantsUserCount      OrgMetricDiscriminants = "UserCount"
)

// Defines values for OrgMetricStat.
const (
	Average OrgMetricStat = "Average"
	Sum     OrgMetricStat = "Sum"
)

// Defines values for PendingMessageInfoMessageEip712Version.
const (
	PendingMessageInfoMessageEip712VersionV3 PendingMessageInfoMessageEip712Version = "v3"
	PendingMessageInfoMessageEip712VersionV4 PendingMessageInfoMessageEip712Version = "v4"
)

// Defines values for PendingMessageSignResponseMessageEip712Version.
const (
	PendingMessageSignResponseMessageEip712VersionV3 PendingMessageSignResponseMessageEip712Version = "v3"
	PendingMessageSignResponseMessageEip712VersionV4 PendingMessageSignResponseMessageEip712Version = "v4"
)

// Defines values for PolicyErrorOwnCodes.
const (
	AddKeyToRoleDisallowed                  PolicyErrorOwnCodes = "AddKeyToRoleDisallowed"
	BabylonStakingBbnAddress                PolicyErrorOwnCodes = "BabylonStakingBbnAddress"
	BabylonStakingChangeAddress             PolicyErrorOwnCodes = "BabylonStakingChangeAddress"
	BabylonStakingDisallowed                PolicyErrorOwnCodes = "BabylonStakingDisallowed"
	BabylonStakingExplicitParams            PolicyErrorOwnCodes = "BabylonStakingExplicitParams"
	BabylonStakingFee                       PolicyErrorOwnCodes = "BabylonStakingFee"
	BabylonStakingFinalityProviderPk        PolicyErrorOwnCodes = "BabylonStakingFinalityProviderPk"
	BabylonStakingLockTime                  PolicyErrorOwnCodes = "BabylonStakingLockTime"
	BabylonStakingNetwork                   PolicyErrorOwnCodes = "BabylonStakingNetwork"
	BabylonStakingParamsVersion             PolicyErrorOwnCodes = "BabylonStakingParamsVersion"
	BabylonStakingStakerPk                  PolicyErrorOwnCodes = "BabylonStakingStakerPk"
	BabylonStakingValue                     PolicyErrorOwnCodes = "BabylonStakingValue"
	BabylonStakingWithdrawalAddress         PolicyErrorOwnCodes = "BabylonStakingWithdrawalAddress"
	BtcMessageSigningNotAllowed             PolicyErrorOwnCodes = "BtcMessageSigningNotAllowed"
	BtcSighashTypeDisallowed                PolicyErrorOwnCodes = "BtcSighashTypeDisallowed"
	BtcSignatureExceededValue               PolicyErrorOwnCodes = "BtcSignatureExceededValue"
	BtcTxDisallowedOutputs                  PolicyErrorOwnCodes = "BtcTxDisallowedOutputs"
	BtcValueOverflow                        PolicyErrorOwnCodes = "BtcValueOverflow"
	DeniedByWebhook                         PolicyErrorOwnCodes = "DeniedByWebhook"
	DiffieHellmanExchangeNotAllowed         PolicyErrorOwnCodes = "DiffieHellmanExchangeNotAllowed"
	Eip191SigningNotAllowed                 PolicyErrorOwnCodes = "Eip191SigningNotAllowed"
	Eip712SigningNotAllowed                 PolicyErrorOwnCodes = "Eip712SigningNotAllowed"
	Erc20DataInvalid                        PolicyErrorOwnCodes = "Erc20DataInvalid"
	Erc20ExceededApproveLimit               PolicyErrorOwnCodes = "Erc20ExceededApproveLimit"
	Erc20ExceededTransferLimit              PolicyErrorOwnCodes = "Erc20ExceededTransferLimit"
	Erc20ReceiverMismatch                   PolicyErrorOwnCodes = "Erc20ReceiverMismatch"
	Erc20SpenderMismatch                    PolicyErrorOwnCodes = "Erc20SpenderMismatch"
	Eth2ConcurrentUnstaking                 PolicyErrorOwnCodes = "Eth2ConcurrentUnstaking"
	Eth2ExceededMaxUnstake                  PolicyErrorOwnCodes = "Eth2ExceededMaxUnstake"
	EvmContractAddressUndefined             PolicyErrorOwnCodes = "EvmContractAddressUndefined"
	EvmContractChainIdUndefined             PolicyErrorOwnCodes = "EvmContractChainIdUndefined"
	EvmContractNotInAllowlist               PolicyErrorOwnCodes = "EvmContractNotInAllowlist"
	EvmDataDisallowed                       PolicyErrorOwnCodes = "EvmDataDisallowed"
	EvmDataInvalid                          PolicyErrorOwnCodes = "EvmDataInvalid"
	EvmDataNotDefined                       PolicyErrorOwnCodes = "EvmDataNotDefined"
	EvmFunctionCallInvalid                  PolicyErrorOwnCodes = "EvmFunctionCallInvalid"
	EvmFunctionNotInAllowlist               PolicyErrorOwnCodes = "EvmFunctionNotInAllowlist"
	EvmTxExceededGasCost                    PolicyErrorOwnCodes = "EvmTxExceededGasCost"
	EvmTxExceededValue                      PolicyErrorOwnCodes = "EvmTxExceededValue"
	EvmTxGasCostUndefined                   PolicyErrorOwnCodes = "EvmTxGasCostUndefined"
	EvmTxReceiverMismatch                   PolicyErrorOwnCodes = "EvmTxReceiverMismatch"
	EvmTxSenderMismatch                     PolicyErrorOwnCodes = "EvmTxSenderMismatch"
	EvmTxValueUndefined                     PolicyErrorOwnCodes = "EvmTxValueUndefined"
	InvalidSourceIp                         PolicyErrorOwnCodes = "InvalidSourceIp"
	KeyAccessError                          PolicyErrorOwnCodes = "KeyAccessError"
	KeyInMultipleRoles                      PolicyErrorOwnCodes = "KeyInMultipleRoles"
	KeysAlreadyInRole                       PolicyErrorOwnCodes = "KeysAlreadyInRole"
	NoOidcAuthSourcesDefined                PolicyErrorOwnCodes = "NoOidcAuthSourcesDefined"
	NotInIpv4Allowlist                      PolicyErrorOwnCodes = "NotInIpv4Allowlist"
	NotInOriginAllowlist                    PolicyErrorOwnCodes = "NotInOriginAllowlist"
	OidcSourceNotAllowed                    PolicyErrorOwnCodes = "OidcSourceNotAllowed"
	PolicyDisjunctionError                  PolicyErrorOwnCodes = "PolicyDisjunctionError"
	PolicyNegationError                     PolicyErrorOwnCodes = "PolicyNegationError"
	PsbtSigningDisallowed                   PolicyErrorOwnCodes = "PsbtSigningDisallowed"
	RawSigningNotAllowed                    PolicyErrorOwnCodes = "RawSigningNotAllowed"
	RequireRoleSessionKeyAccessError        PolicyErrorOwnCodes = "RequireRoleSessionKeyAccessError"
	SegwitSigningDisallowed                 PolicyErrorOwnCodes = "SegwitSigningDisallowed"
	SolanaInstructionCountHigh              PolicyErrorOwnCodes = "SolanaInstructionCountHigh"
	SolanaInstructionCountLow               PolicyErrorOwnCodes = "SolanaInstructionCountLow"
	SolanaInstructionMismatch               PolicyErrorOwnCodes = "SolanaInstructionMismatch"
	SolanaNotInInstructionAllowlist         PolicyErrorOwnCodes = "SolanaNotInInstructionAllowlist"
	SuiTxReceiversDisallowedCommand         PolicyErrorOwnCodes = "SuiTxReceiversDisallowedCommand"
	SuiTxReceiversDisallowedTransactionKind PolicyErrorOwnCodes = "SuiTxReceiversDisallowedTransactionKind"
	SuiTxReceiversDisallowedTransferAddress PolicyErrorOwnCodes = "SuiTxReceiversDisallowedTransferAddress"
	TaprootSigningDisallowed                PolicyErrorOwnCodes = "TaprootSigningDisallowed"
	TimeLocked                              PolicyErrorOwnCodes = "TimeLocked"
	WasmPoliciesDisabled                    PolicyErrorOwnCodes = "WasmPoliciesDisabled"
	WasmPolicyDenied                        PolicyErrorOwnCodes = "WasmPolicyDenied"
	WasmPolicyFailed                        PolicyErrorOwnCodes = "WasmPolicyFailed"
	WebhookPoliciesDisabled                 PolicyErrorOwnCodes = "WebhookPoliciesDisabled"
)

// Defines values for PolicyType.
const (
	Key  PolicyType = "Key"
	Role PolicyType = "Role"
	Wasm PolicyType = "Wasm"
)

// Defines values for PreconditionErrorOwnCodes.
const (
	BabylonEotsConcurrentSigning                  PreconditionErrorOwnCodes = "BabylonEotsConcurrentSigning"
	ConcurrentSigningWhenTimeLimitPolicyIsDefined PreconditionErrorOwnCodes = "ConcurrentSigningWhenTimeLimitPolicyIsDefined"
	Eth2AttestationSourceEpochTooLow              PreconditionErrorOwnCodes = "Eth2AttestationSourceEpochTooLow"
	Eth2AttestationTargetEpochTooLow              PreconditionErrorOwnCodes = "Eth2AttestationTargetEpochTooLow"
	Eth2ConcurrentAttestationSigning              PreconditionErrorOwnCodes = "Eth2ConcurrentAttestationSigning"
	Eth2ConcurrentBlockSigning                    PreconditionErrorOwnCodes = "Eth2ConcurrentBlockSigning"
	Eth2MultiDepositToNonGeneratedKey             PreconditionErrorOwnCodes = "Eth2MultiDepositToNonGeneratedKey"
	Eth2MultiDepositUnknownInitialDeposit         PreconditionErrorOwnCodes = "Eth2MultiDepositUnknownInitialDeposit"
	Eth2MultiDepositWithdrawalAddressMismatch     PreconditionErrorOwnCodes = "Eth2MultiDepositWithdrawalAddressMismatch"
	Eth2ProposerSlotTooLow                        PreconditionErrorOwnCodes = "Eth2ProposerSlotTooLow"
	KeyRegionLocked                               PreconditionErrorOwnCodes = "KeyRegionLocked"
	MfaApprovalsNotYetValid                       PreconditionErrorOwnCodes = "MfaApprovalsNotYetValid"
	MfaRegionLocked                               PreconditionErrorOwnCodes = "MfaRegionLocked"
	TendermintConcurrentSigning                   PreconditionErrorOwnCodes = "TendermintConcurrentSigning"
	TendermintStateError                          PreconditionErrorOwnCodes = "TendermintStateError"
)

// Defines values for PublicKeyCredentialType.
const (
	PublicKey PublicKeyCredentialType = "public-key"
)

// Defines values for Purpose.
const (
	PurposeAlienInvite        Purpose = "alien_invite"
	PurposeAlienPasswordReset Purpose = "alien_password_reset"
	PurposeMfaReset           Purpose = "mfa_reset"
	PurposeOtp                Purpose = "otp"
	PurposeOtpMfa             Purpose = "otp_mfa"
)

// Defines values for RefreshGrantType.
const (
	RefreshToken RefreshGrantType = "refresh_token"
)

// Defines values for ResidentKeyRequirement.
const (
	ResidentKeyRequirementDiscouraged ResidentKeyRequirement = "discouraged"
	ResidentKeyRequirementPreferred   ResidentKeyRequirement = "preferred"
	ResidentKeyRequirementRequired    ResidentKeyRequirement = "required"
)

// Defines values for RoleAction.
const (
	CreateToken RoleAction = "CreateToken"
	GetKey      RoleAction = "GetKey"
)

// Defines values for ScopeSetAll.
const (
	AllScopes ScopeSetAll = "All"
)

// Defines values for SecondFactorRequirement.
const (
	SecondFactorRequirementIfRegistered SecondFactorRequirement = "if_registered"
	SecondFactorRequirementNone         SecondFactorRequirement = "none"
	SecondFactorRequirementRequired     SecondFactorRequirement = "required"
)

// Defines values for SignatureVersion.
const (
	Eip712V3     SignatureVersion = "eip_712_v3"
	Eip712V4     SignatureVersion = "eip_712_v4"
	PersonalSign SignatureVersion = "personal_sign"
)

// Defines values for SignerErrorOwnCodes.
const (
	EnclaveError          SignerErrorOwnCodes = "EnclaveError"
	JrpcError             SignerErrorOwnCodes = "JrpcError"
	PreComputed           SignerErrorOwnCodes = "PreComputed"
	ProxyStartError       SignerErrorOwnCodes = "ProxyStartError"
	StatusCodeWithMessage SignerErrorOwnCodes = "StatusCodeWithMessage"
	UnhandledError        SignerErrorOwnCodes = "UnhandledError"
)

// Defines values for SubscriptionStatus.
const (
	SubscriptionStatusConfirmed SubscriptionStatus = "Confirmed"
	SubscriptionStatusPending   SubscriptionStatus = "Pending"
)

// Defines values for SuiChain.
const (
	Sui        SuiChain = "sui"
	SuiDevnet  SuiChain = "sui_devnet"
	SuiTestnet SuiChain = "sui_testnet"
)

// Defines values for TelegramEnvironment.
const (
	Production TelegramEnvironment = "production"
	Test       TelegramEnvironment = "test"
)

// Defines values for TimeoutErrorCode.
const (
	PolicyEngineTimeout        TimeoutErrorCode = "PolicyEngineTimeout"
	WasmPolicyExecutionTimeout TimeoutErrorCode = "WasmPolicyExecutionTimeout"
)

// Defines values for TsQueryName.
const (
	TsQueryNameActiveKeys    TsQueryName = "ActiveKeys"
	TsQueryNameActiveUsers   TsQueryName = "ActiveUsers"
	TsQueryNameBillingEvents TsQueryName = "BillingEvents"
	TsQueryNameKeyCount      TsQueryName = "KeyCount"
	TsQueryNameOidcLogins    TsQueryName = "OidcLogins"
	TsQueryNameSignEvents    TsQueryName = "SignEvents"
	TsQueryNameUniqueSignIns TsQueryName = "UniqueSignIns"
	TsQueryNameUserCount     TsQueryName = "UserCount"
)

// Defines values for TxStatusPendingStatus.
const (
	Pending TxStatusPendingStatus = "Pending"
)

// Defines values for TxStatusRejectedStatus.
const (
	TxStatusRejectedStatusRejected TxStatusRejectedStatus = "Rejected"
)

// Defines values for TxStatusSignedStatus.
const (
	TxStatusSignedStatusSigned TxStatusSignedStatus = "Signed"
)

// Defines values for UnauthorizedErrorCode.
const (
	AuthorizationHeaderMissing  UnauthorizedErrorCode = "AuthorizationHeaderMissing"
	EndpointRequiresUserSession UnauthorizedErrorCode = "EndpointRequiresUserSession"
	RefreshTokenMissing         UnauthorizedErrorCode = "RefreshTokenMissing"
)

// Defines values for UserVerificationRequirement.
const (
	Discouraged UserVerificationRequirement = "discouraged"
	Preferred   UserVerificationRequirement = "preferred"
	Required    UserVerificationRequirement = "required"
)

// Defines values for WasmPolicyResponseAllowResponse.
const (
	Allow WasmPolicyResponseAllowResponse = "Allow"
)

// Defines values for WasmPolicyResponseDenyResponse.
const (
	Deny WasmPolicyResponseDenyResponse = "Deny"
)

// Defines values for WasmPolicyResponseErrorResponse.
const (
	Error WasmPolicyResponseErrorResponse = "Error"
)

// Defines values for WebhookMethod.
const (
	GET  WebhookMethod = "GET"
	POST WebhookMethod = "POST"
)

// Defines values for ConfigureEmailParamsPurpose.
const (
	ConfigureEmailParamsPurposeAlienInvite        ConfigureEmailParamsPurpose = "alien_invite"
	ConfigureEmailParamsPurposeAlienPasswordReset ConfigureEmailParamsPurpose = "alien_password_reset"
	ConfigureEmailParamsPurposeMfaReset           ConfigureEmailParamsPurpose = "mfa_reset"
	ConfigureEmailParamsPurposeOtp                ConfigureEmailParamsPurpose = "otp"
	ConfigureEmailParamsPurposeOtpMfa             ConfigureEmailParamsPurpose = "otp_mfa"
)

// AcceptedResponse defines model for AcceptedResponse.
type AcceptedResponse struct {
	Accepted  *AcceptedValue  `json:"accepted"`
	ErrorCode SignerErrorCode `json:"error_code"`

	// Message Error message
	Message string `json:"message"`

	// RequestId Optional request identifier
	RequestId *string `json:"request_id,omitempty"`
}

// AcceptedValue defines model for AcceptedValue.
type AcceptedValue struct {
	MfaRequired struct {
		// Id Always set to first MFA id from `Self::ids`
		Id string `json:"id"`

		// Ids Non-empty MFA request IDs
		Ids []string `json:"ids"`

		// OrgId Organization id
		OrgId   string              `json:"org_id"`
		Session *NewSessionResponse `json:"session"`
	} `json:"MfaRequired"`
}

// AcceptedValueCode defines model for AcceptedValueCode.
type AcceptedValueCode string

// AccessModel Determines who controls the keys within an org
type AccessModel string

// AddIdentityRequest Request to add OIDC identity to an existing user account
type AddIdentityRequest struct {
	OidcToken string `json:"oidc_token"`
}

// AddKeysToRoleRequest defines model for AddKeysToRoleRequest.
type AddKeysToRoleRequest struct {
	// KeyIds A list of keys to add to a role
	KeyIds []string `json:"key_ids"`

	// Policy Optional policies to apply for each key
	Policy *[]interface{} `json:"policy"`
}

// AddThirdPartyUserRequest defines model for AddThirdPartyUserRequest.
type AddThirdPartyUserRequest struct {
	// Email Optional user email
	Email    *string       `json:"email"`
	Identity *OidcIdentity `json:"identity"`

	// MfaPolicy Optional login MFA policy
	MfaPolicy *map[string]interface{} `json:"mfa_policy"`

	// Name Optional user full name
	Name  *string        `json:"name"`
	Proof *IdentityProof `json:"proof"`

	// Role Describes whether a user in an org is an Owner or just a regular member
	Role MemberRole `json:"role"`
}

// AddThirdPartyUserResponse defines model for AddThirdPartyUserResponse.
type AddThirdPartyUserResponse struct {
	UserId string `json:"user_id"`
}

// AddressMap A mapping of networks to their associated chains and addresses.
type AddressMap struct {
	// Btc BTC addresses. The keys are `BtcChain`s and the values are addresses.
	Btc *map[string]string `json:"btc,omitempty"`
	Evm *EvmOptions        `json:"evm"`

	// Sui SUI addresses. The keys are `SuiChain`s and the values are addresses.
	Sui *map[string]string `json:"sui,omitempty"`
}

// AlertKind defines model for AlertKind.
type AlertKind string

// AllowedMfaMap MFA types that are allowed to be used for individual implicitly security-sensitive
// operations (like logging in, adding an MFA factor, exporting keys, etc; see `MfaProtectedAction`).
type AllowedMfaMap map[string][]MfaType

// ApprovalInfo defines model for ApprovalInfo.
type ApprovalInfo struct {
	// Timestamp DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	Timestamp EpochDateTime `json:"timestamp"`
}

// AttestationConveyancePreference WebAuthn Relying Parties may use AttestationConveyancePreference to specify
// their preference regarding attestation conveyance during credential
// generation.
//
// https://www.w3.org/TR/webauthn-2/#enumdef-attestationconveyancepreference
type AttestationConveyancePreference string

// Aud Audience(s) that this ID Token is intended for. It MUST contain the
// OAuth 2.0 client_id of the Relying Party as an audience value. It MAY also contain
// identifiers for other audiences. In the general case, the aud value is an array of
// case-sensitive strings. In the common special case when there is one audience,
// the aud value MAY be a single case-sensitive string.
type Aud struct {
	union json.RawMessage
}

// AudArray defines model for AudArray.
type AudArray = []string

// AudString defines model for AudString.
type AudString = string

// AuthData Data required for both `authenticate` and `refresh`.
type AuthData struct {
	EpochNum int32 `json:"epoch_num"`

	// EpochToken Wrapper around a zeroizing 32-byte fixed-size array
	EpochToken B32    `json:"epoch_token"`
	OtherToken string `json:"other_token"`
}

// AuthSource At redemption time, the user must provide a credential they wish to use to authenticate.
// This enum represents the two possible sources of authentication.
type AuthSource struct {
	Credential string `json:"credential"`

	// Kind At redemption time, the user must provide a credential they wish to use to authenticate.
	// This enum represents the two possible sources of authentication.
	Kind AuthSourceKind `json:"kind"`
}

// AuthSourceKind At redemption time, the user must provide a credential they wish to use to authenticate.
// This enum represents the two possible sources of authentication.
type AuthSourceKind string

// AuthenticationRequest The request body for the idp authenticate endpoint
type AuthenticationRequest struct {
	// Email The email address of the user attempting to authenticate
	Email string `json:"email"`

	// Password The password for that user
	Password string `json:"password"`
}

// AuthenticationResponse The response to the idp authenticate endpoint
type AuthenticationResponse struct {
	// IdToken An OIDC token that can be used to authenticate with CubeSigner
	IdToken string `json:"id_token"`
}

// AuthenticatorAssertionResponse Represents the assertion response used by clients when attempting to log in with a known credential
// https://www.w3.org/TR/webauthn-2/#authenticatorassertionresponse
type AuthenticatorAssertionResponse struct {
	// AuthenticatorData Contains the standard CTAP2 authenticator data. Must be a valid [`AuthenticatorData`].
	// This contains information about how key was invoked.
	// https://www.w3.org/TR/webauthn-2/#dom-authenticatorassertionresponse-authenticatordata
	AuthenticatorData string `json:"authenticatorData"`

	// ClientDataJSON Contains UTF8 encoded JSON which must be a valid [`ClientData`]
	// This data is combined with `authenticator_data` to produce the signature
	// meaning the client attests to the correctness of this data.
	// https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson
	ClientDataJSON string `json:"clientDataJSON"`

	// Signature The signature of the concatenated `authenticatorData || hash` where
	// `hash` is the SHA256 hash of the `clientDataJSON` buffer:
	//
	// Field Definition: https://www.w3.org/TR/webauthn-2/#dom-authenticatorassertionresponse-signature
	// Step 11 of `getAssertion` specifies the concatenation: https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion
	// Requirement for SHA-256: https://www.w3.org/TR/webauthn-2/#collectedclientdata-hash-of-the-serialized-client-data
	Signature string `json:"signature"`

	// UserHandle Allows the authenticator to optionally declare the credential identifier they used.
	// https://www.w3.org/TR/webauthn-2/#dom-authenticatorassertionresponse-userhandle
	UserHandle *string `json:"userHandle"`
}

// AuthenticatorAttachment This enumerations values describe authenticators' attachment modalities.
// Relying Parties use this to express a preferred authenticator attachment
// modality when calling navigator.credentials.create() to create a credential.
//
// https://www.w3.org/TR/webauthn-2/#enumdef-authenticatorattachment
type AuthenticatorAttachment string

// AuthenticatorAttestationResponse The AuthenticatorAttestationResponse interface represents the authenticator's
// response to a clients request for the creation of a new public key
// credential. It contains information about the new credential that can be
// used to identify it for later use, and metadata that can be used by the
// WebAuthn Relying Party to assess the characteristics of the credential
// during registration.
//
// https://www.w3.org/TR/webauthn-2/#iface-authenticatorattestationresponse
type AuthenticatorAttestationResponse struct {
	// AttestationObject This attribute contains an attestation object, which is opaque to, and
	// cryptographically protected against tampering by, the client. The
	// attestation object contains both authenticator data and an attestation
	// statement. The former contains the AAGUID, a unique credential ID, and
	// the credential public key. The contents of the attestation statement are
	// determined by the attestation statement format used by the
	// authenticator. It also contains any additional information that the
	// Relying Party's server requires to validate the attestation statement,
	// as well as to decode and validate the authenticator data along with the
	// JSON-compatible serialization of client data. For more details, see
	//  6.5 Attestation,  6.5.4 Generating an Attestation Object, and Figure
	// 6.
	AttestationObject string `json:"attestationObject"`

	// ClientDataJSON This attribute, inherited from AuthenticatorResponse, contains the
	// JSON-compatible serialization of client data (see  6.5 Attestation)
	// passed to the authenticator by the client in order to generate this
	// credential. The exact JSON serialization MUST be preserved, as the hash
	// of the serialized client data has been computed over it.
	ClientDataJSON string `json:"clientDataJSON"`
}

// AuthenticatorSelectionCriteria WebAuthn Relying Parties may use the AuthenticatorSelectionCriteria
// dictionary to specify their requirements regarding authenticator
// attributes.
//
// https://www.w3.org/TR/webauthn-2/#dictdef-authenticatorselectioncriteria
type AuthenticatorSelectionCriteria struct {
	AuthenticatorAttachment *AuthenticatorAttachment `json:"authenticatorAttachment"`

	// RequireResidentKey This member is retained for backwards compatibility with WebAuthn Level
	// 1 and, for historical reasons, its naming retains the deprecated
	// resident terminology for discoverable credentials. Relying Parties
	// SHOULD set it to true if, and only if, residentKey is set to required.
	//
	// https://www.w3.org/TR/webauthn-2/#dom-authenticatorselectioncriteria-requireresidentkey
	RequireResidentKey *bool                   `json:"requireResidentKey,omitempty"`
	ResidentKey        *ResidentKeyRequirement `json:"residentKey"`

	// UserVerification A WebAuthn Relying Party may require user verification for some of its
	// operations but not for others, and may use this type to express its needs.
	//
	// https://www.w3.org/TR/webauthn-2/#enum-userVerificationRequirement
	UserVerification *UserVerificationRequirement `json:"userVerification,omitempty"`
}

// AuthenticatorTransport Authenticators may implement various transports for communicating with
// clients. This enumeration defines hints as to how clients might communicate
// with a particular authenticator in order to obtain an assertion for a
// specific credential. Note that these hints represent the WebAuthn Relying
// Party's best belief as to how an authenticator may be reached. A Relying
// Party will typically learn of the supported transports for a public key
// credential via getTransports().
//
// https://www.w3.org/TR/webauthn-2/#enumdef-authenticatortransport
type AuthenticatorTransport string

// AvaSerializedTxSignRequest defines model for AvaSerializedTxSignRequest.
type AvaSerializedTxSignRequest struct {
	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata interface{} `json:"metadata"`

	// Tx Serialized transaction to sign
	Tx string `json:"tx"`
}

// AvaSignRequest defines model for AvaSignRequest.
type AvaSignRequest struct {
	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata interface{} `json:"metadata"`

	// Tx Transaction to sign.
	//
	// Examples:
	// - {"P": { "AddPermissionlessValidator": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/platformvm/txs/add_permissionless_validator.rs#L14) }}
	// - {"P": { "AddSubnetValidator": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/platformvm/txs/add_subnet_validator.rs#L29) }}
	// - {"P": { "AddValidator": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/platformvm/txs/add_validator.rs#L12) }}
	// - {"P": { "CreateChain": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/platformvm/txs/create_chain.rs#L8) }}
	// - {"P": { "CreateSubnet": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/platformvm/txs/create_subnet.rs#L8) }}
	// - {"P": { "Export": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/platformvm/txs/export.rs#L12) }}
	// - {"P": { "Import": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/platformvm/txs/import.rs#L12) }}
	// - {"X": { "Base": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/avm/txs/mod.rs#L21) }}
	// - {"X": { "Export": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/avm/txs/export.rs#L16) }}
	// - {"X": { "Import": [TxJson](https://github.com/ava-labs/avalanche-rs/blob/avalanche-types-v0.1.3/crates/avalanche-types/src/avm/txs/import.rs#L14) }}
	Tx map[string]interface{} `json:"tx"`
}

// B32 Wrapper around a zeroizing 32-byte fixed-size array
type B32 = string

// BabylonCovSignRequest defines model for BabylonCovSignRequest.
type BabylonCovSignRequest struct {
	// FpEncKeys The keys for the finality providers to which this transaction is being staked.
	// Each key is a hex string containing a SEC1-encoded secp256k1 public key.
	FpEncKeys []string `json:"fp_enc_keys"`

	// SlashUnbondingTx The slash-unbonding transaction being approved by the covenant signer.
	// This is a Bitcoin consensus--encoded hex string.
	SlashUnbondingTx string `json:"slash_unbonding_tx"`

	// SlashingScript The slashing script in the staking transaction.
	// This is a Bitcoin consensus--encoded hex string.
	SlashingScript string `json:"slashing_script"`

	// SlashingTx The slashing transaction being approved by the covenant signer.
	// This is a Bitcoin consensus--encoded hex string.
	SlashingTx     string                           `json:"slashing_tx"`
	StakeExpansion *BabylonCovStakeExpansionRequest `json:"stake_expansion"`

	// StakingOutputIdx The output index of the Babylon staking scripts in the staking transaction.
	StakingOutputIdx int32 `json:"staking_output_idx"`

	// StakingTx The staking transaction being approved by the covenant signer.
	// This is a Bitcoin consensus--encoded hex string.
	StakingTx string `json:"staking_tx"`

	// UnbondingScript The unbonding script in the staking transaction.
	// This is a Bitcoin consensus--encoded hex string.
	UnbondingScript string `json:"unbonding_script"`

	// UnbondingSlashingScript The slashing script in the unbonding transaction.
	// This is a Bitcoin consensus--encoded hex string.
	UnbondingSlashingScript string `json:"unbonding_slashing_script"`

	// UnbondingTx The unbonding transaction being approved by the covenant signer.
	// This is a Bitcoin consensus--encoded hex string.
	UnbondingTx string `json:"unbonding_tx"`
}

// BabylonCovSignResponse defines model for BabylonCovSignResponse.
type BabylonCovSignResponse struct {
	// SlashUnbondingTransactionsSignatures The slash-unbonding transaction signatures as an array of hex strings with no 0x prefix
	SlashUnbondingTransactionsSignatures []string `json:"slash_unbonding_transactions_signatures"`

	// SlashingTransactionsSignatures The slashing transaction signatures as an array of hex strings with no 0x prefix
	SlashingTransactionsSignatures []string `json:"slashing_transactions_signatures"`

	// StakeExpansionTransactionSignature The signature that allows expanding a stake by spending the current active
	// stake transaction into a new staking transaction. A value is present iff the
	// corresponding request included a `stake_expansion` value.
	StakeExpansionTransactionSignature *string `json:"stake_expansion_transaction_signature"`

	// UnbondingTransactionSignature The unbonding transaction signature as hex string with no 0x prefix
	UnbondingTransactionSignature string `json:"unbonding_transaction_signature"`
}

// BabylonCovStakeExpansionRequest Request to expand an active stake with additional funds.
type BabylonCovStakeExpansionRequest struct {
	// OtherFundingOutput The transaction output that is being used to fund the stake expansion.
	// This is a Bitcoin consensus--encoded hex string.
	OtherFundingOutput string `json:"other_funding_output"`

	// PreviousActiveStakeTx The active staking transaction that is being expanded with this request.
	// This is a Bitcoin consensus--encoded hex string.
	PreviousActiveStakeTx string `json:"previous_active_stake_tx"`

	// PreviousActiveStakeUnbondingScript The unbonding script in the active staking transaction.
	// This is a Bitcoin consensus--encoded hex string.
	PreviousActiveStakeUnbondingScript string `json:"previous_active_stake_unbonding_script"`

	// PreviousStakingOutputIdx The index of the active stake output in the active staking transaction.
	PreviousStakingOutputIdx int32 `json:"previous_staking_output_idx"`
}

// BabylonNetworkId The network-id for Babylon staking
type BabylonNetworkId string

// BabylonRegistrationRequest defines model for BabylonRegistrationRequest.
type BabylonRegistrationRequest struct {
	// BbnAddr The Babylon address that will receive the staking rewards for this deposit.
	// Babylon requires this to be the same address that registers the deposit on
	// the Babylon chain.
	//
	// This must be a secp256k1 Cosmos address with either a `bbn` or a `cosmos`
	// human-readable part (i.e., `bbn1...` or `cosmos1...`). The latter lets you
	// specify the material-id of a SecpCosmos CubeSigner key.
	BbnAddr string `json:"bbn_addr"`

	// Change The change address, specified as a Bitcoin spend script
	Change         string                `json:"change"`
	ExplicitParams *BabylonStakingParams `json:"explicit_params"`

	// Fee The transaction fee value. The `fee_type` field determines whether this
	// is a fixed fee in sats or a rate in sats per (estimated) virtual byte of
	// transaction weight (i.e., sats per vb).
	Fee int64 `json:"fee"`

	// FeeType This type specifies the interpretation of the `fee` field in Babylon
	// staking requests. If `sats`, the field is intpreted as a fixed value
	// in sats. If `sats_pr_vb`, the field is interpreted as a rate and the
	// fee is computed by estimating the weight of the output transaction.
	FeeType FeeType `json:"fee_type"`

	// FinalityProviderPks The Schnorr public key (i.e., 32-byte X-coordinate) of the finality
	// provider to which the stake is delegated.
	FinalityProviderPks []string `json:"finality_provider_pks"`

	// IgnorePsbtOutputs By default, the PSBT in this request can only specify transaction inputs:
	// PSBTs that specify outputs will result in an error. When this flag is set,
	// existing outputs in the PSBT will instead be ignored (i.e., deleted from
	// the PSBT) when creating the deposit transaction.
	IgnorePsbtOutputs *bool `json:"ignore_psbt_outputs,omitempty"`

	// LockTime The lock time used for the withdrawal output in the staking deposit transaction
	LockTime int32 `json:"lock_time"`

	// Network The network-id for Babylon staking
	Network BabylonNetworkId `json:"network"`

	// Psbt A hex-serialized PSBT (version 0) containing the transaction inputs and
	// all necessary information for signing (e.g., taproot path and leaf
	// information). This PSBT must not have any transaction outputs; they
	// will be added to the returned PSBT.
	Psbt string `json:"psbt"`

	// StakerPk The Schnorr public key (i.e., 32-byte X-coordinate) of the staker. This
	// is the key that signs the slashing, withdrawal, and unbonding scripts.
	StakerPk string `json:"staker_pk"`

	// Value The value to be staked in sats
	Value int64 `json:"value"`

	// Version The parameter version to use. If `None`, uses the latest version.
	Version *int32 `json:"version"`
}

// BabylonRegistrationResponse defines model for BabylonRegistrationResponse.
type BabylonRegistrationResponse struct {
	// BbnAddr The Babylon address that will receive the staking rewards for this deposit.
	//
	// This value will correspond to the `bbn_addr` value specified in the request,
	// but it will always have a `bbn` human-readable part.
	BbnAddr string `json:"bbn_addr"`

	// Deposit The deposit transaction PSBT. This PSBT includes signatures on any
	// inputs controlled by the staker taproot key specified in the request.
	Deposit string `json:"deposit"`

	// DepositFee The deposit transaction fee in sats.
	DepositFee int64 `json:"deposit_fee"`

	// Pop The proof of possession, i.e., a BIP322 signature on the staker's
	// Babylon address signed by the staker taproot key. This is a Bitcoin
	// witness stack in Bitcoin consensus hex encoding.
	Pop string `json:"pop"`

	// SlashDeposit The slash-deposit transaction in Bitcoin consensus hex encoding.
	SlashDeposit string `json:"slash_deposit"`

	// SlashDepositSig The staker taproot key's signature on the slash-deposit transaction.
	// This is a BIP340 signature in hex format.
	SlashDepositSig string `json:"slash_deposit_sig"`

	// SlashUnbond The slash-unbond transaction in Bitcoin consensus hex encoding.
	SlashUnbond string `json:"slash_unbond"`

	// SlashUnbondSig The staker taproot key's signature on the slash-unbond transaction.
	// This is a BIP340 signature in hex format.
	SlashUnbondSig string `json:"slash_unbond_sig"`

	// Unbond The (unsigned) unbonding transaction in Bitcoin consensus hex encoding.
	Unbond string `json:"unbond"`
}

// BabylonScriptData Data needed to create the Babylon deposit scripts
type BabylonScriptData struct {
	ExplicitParams *BabylonStakingParams `json:"explicit_params"`

	// FinalityProviderPks The Schnorr public key (i.e., 32-byte X-coordinate) of the finality
	// provider to which the stake is delegated.
	FinalityProviderPks []string `json:"finality_provider_pks"`

	// LockTime The lock time used for the withdrawal output in the staking deposit transaction
	LockTime int32 `json:"lock_time"`

	// Network The network-id for Babylon staking
	Network BabylonNetworkId `json:"network"`

	// StakerPk The Schnorr public key (i.e., 32-byte X-coordinate) of the staker. This
	// is the key that signs the slashing, withdrawal, and unbonding scripts.
	StakerPk string `json:"staker_pk"`

	// Version The parameter version to use. If `None`, uses the latest version.
	Version *int32 `json:"version"`
}

// BabylonStakingDeposit defines model for BabylonStakingDeposit.
type BabylonStakingDeposit struct {
	// Change The change address, specified as a Bitcoin spend script
	Change         string                `json:"change"`
	ExplicitParams *BabylonStakingParams `json:"explicit_params"`

	// Fee The transaction fee value. The `fee_type` field determines whether this
	// is a fixed fee in sats or a rate in sats per (estimated) virtual byte of
	// transaction weight (i.e., sats per vb).
	Fee int64 `json:"fee"`

	// FeeType This type specifies the interpretation of the `fee` field in Babylon
	// staking requests. If `sats`, the field is intpreted as a fixed value
	// in sats. If `sats_pr_vb`, the field is interpreted as a rate and the
	// fee is computed by estimating the weight of the output transaction.
	FeeType FeeType `json:"fee_type"`

	// FinalityProviderPks The Schnorr public key (i.e., 32-byte X-coordinate) of the finality
	// provider to which the stake is delegated.
	FinalityProviderPks []string `json:"finality_provider_pks"`

	// IgnorePsbtOutputs By default, the PSBT in this request can only specify transaction inputs:
	// PSBTs that specify outputs will result in an error. When this flag is set,
	// existing outputs in the PSBT will instead be ignored (i.e., deleted from
	// the PSBT) when creating the deposit transaction.
	IgnorePsbtOutputs *bool `json:"ignore_psbt_outputs,omitempty"`

	// LockTime The lock time used for the withdrawal output in the staking deposit transaction
	LockTime int32 `json:"lock_time"`

	// Network The network-id for Babylon staking
	Network BabylonNetworkId `json:"network"`

	// Psbt A hex-serialized PSBT (version 0) containing the transaction inputs and
	// all necessary information for signing (e.g., taproot path and leaf
	// information). This PSBT must not have any transaction outputs; they
	// will be added to the returned PSBT.
	Psbt string `json:"psbt"`

	// StakerPk The Schnorr public key (i.e., 32-byte X-coordinate) of the staker. This
	// is the key that signs the slashing, withdrawal, and unbonding scripts.
	StakerPk string `json:"staker_pk"`

	// Value The value to be staked in sats
	Value int64 `json:"value"`

	// Version The parameter version to use. If `None`, uses the latest version.
	Version *int32 `json:"version"`
}

// BabylonStakingEarlyUnbond defines model for BabylonStakingEarlyUnbond.
type BabylonStakingEarlyUnbond struct {
	// AsBase64 If `true`, the resulting PSBT is encoded as a base64 string.
	// Otherwise, it is encoded as a hex string.
	AsBase64       *bool                 `json:"as_base64,omitempty"`
	ExplicitParams *BabylonStakingParams `json:"explicit_params"`

	// FinalityProviderPks The Schnorr public key (i.e., 32-byte X-coordinate) of the finality
	// provider to which the stake is delegated.
	FinalityProviderPks []string `json:"finality_provider_pks"`

	// LockTime The lock time used for the withdrawal output in the staking deposit transaction
	LockTime int32 `json:"lock_time"`

	// Network The network-id for Babylon staking
	Network BabylonNetworkId `json:"network"`

	// StakerPk The Schnorr public key (i.e., 32-byte X-coordinate) of the staker. This
	// is the key that signs the slashing, withdrawal, and unbonding scripts.
	StakerPk string `json:"staker_pk"`

	// Txid Transaction-id of the deposit transaction to unbond or slash.
	Txid string `json:"txid"`

	// Value The value in sats that was staked in the transaction to unbond or slash.
	Value int64 `json:"value"`

	// Version The parameter version to use. If `None`, uses the latest version.
	Version *int32 `json:"version"`

	// Vout Transaction output index of the staking transaction to unbond or slash.
	// For staking transactions generated by CubeSigner, this will always be zero.
	Vout int32 `json:"vout"`
}

// BabylonStakingParams Parameter set for Babylon staking. The latest parameter sets are
// available from <https://github.com/babylonchain/networks>
type BabylonStakingParams struct {
	// ActivationHeight Block height at which these params will enter use
	ActivationHeight int64 `json:"activation_height"`

	// CovenantPks Public keys of the covenant signers
	CovenantPks []string `json:"covenant_pks"`

	// CovenantQuorum Quorum for covenant signer
	CovenantQuorum int `json:"covenant_quorum"`

	// MaxStakingAmount Max amount that can be staked in a single txn
	MaxStakingAmount int64 `json:"max_staking_amount"`

	// MaxStakingTime Max timelock for staking
	MaxStakingTime int32 `json:"max_staking_time"`

	// MinStakingAmount Min amount that must be staked
	MinStakingAmount int64 `json:"min_staking_amount"`

	// MinStakingTime Min timelock for staking
	MinStakingTime int32 `json:"min_staking_time"`

	// SlashingFee Minimum fee (in sats) that must be paid as part of the slashing txn
	SlashingFee *int64 `json:"slashing_fee,omitempty"`

	// SlashingMargin An extra number of sats to slash in the slashing txn. This can be used
	// to ensure that the transaction meets the minimum slashing requirement
	// even if the covenant committee members use floats to compute the amount
	// that should be slashed. The default is 2; it should not be necessary to
	// go higher than this.
	SlashingMargin *int64 `json:"slashing_margin"`

	// SlashingPkScript The pk_script value for the 0th output index of a slashing transaction,
	// serialized as a hex byte string. This value must be present to create
	// slashing signatures.
	SlashingPkScript *string `json:"slashing_pk_script"`

	// SlashingRate The fraction of stake slashed if a double-sign is detected
	SlashingRate *string `json:"slashing_rate"`

	// Tag Bitcoin transaction tag for staking metadata. If present, an identifiable
	// staking output (i.e., one with an OP_RETURN) will be created.
	Tag *string `json:"tag"`

	// UnbondingFee Fee (in sats) that must be spent as part of the unbonding txn
	UnbondingFee int64 `json:"unbonding_fee"`

	// UnbondingTime Min timelock for an unbonding script
	UnbondingTime int32 `json:"unbonding_time"`

	// Version Parameter version
	Version int32 `json:"version"`
}

// BabylonStakingRequest The actions possible via the Babylon Staking endpoint
type BabylonStakingRequest struct {
	union json.RawMessage
}

// BabylonStakingRequestDeposit defines model for BabylonStakingRequestDeposit.
type BabylonStakingRequestDeposit struct {
	Action BabylonStakingRequestDepositAction `json:"action"`

	// Change The change address, specified as a Bitcoin spend script
	Change         string                `json:"change"`
	ExplicitParams *BabylonStakingParams `json:"explicit_params"`

	// Fee The transaction fee value. The `fee_type` field determines whether this
	// is a fixed fee in sats or a rate in sats per (estimated) virtual byte of
	// transaction weight (i.e., sats per vb).
	Fee int64 `json:"fee"`

	// FeeType This type specifies the interpretation of the `fee` field in Babylon
	// staking requests. If `sats`, the field is intpreted as a fixed value
	// in sats. If `sats_pr_vb`, the field is interpreted as a rate and the
	// fee is computed by estimating the weight of the output transaction.
	FeeType FeeType `json:"fee_type"`

	// FinalityProviderPks The Schnorr public key (i.e., 32-byte X-coordinate) of the finality
	// provider to which the stake is delegated.
	FinalityProviderPks []string `json:"finality_provider_pks"`

	// IgnorePsbtOutputs By default, the PSBT in this request can only specify transaction inputs:
	// PSBTs that specify outputs will result in an error. When this flag is set,
	// existing outputs in the PSBT will instead be ignored (i.e., deleted from
	// the PSBT) when creating the deposit transaction.
	IgnorePsbtOutputs *bool `json:"ignore_psbt_outputs,omitempty"`

	// LockTime The lock time used for the withdrawal output in the staking deposit transaction
	LockTime int32 `json:"lock_time"`

	// Network The network-id for Babylon staking
	Network BabylonNetworkId `json:"network"`

	// Psbt A hex-serialized PSBT (version 0) containing the transaction inputs and
	// all necessary information for signing (e.g., taproot path and leaf
	// information). This PSBT must not have any transaction outputs; they
	// will be added to the returned PSBT.
	Psbt string `json:"psbt"`

	// StakerPk The Schnorr public key (i.e., 32-byte X-coordinate) of the staker. This
	// is the key that signs the slashing, withdrawal, and unbonding scripts.
	StakerPk string `json:"staker_pk"`

	// Value The value to be staked in sats
	Value int64 `json:"value"`

	// Version The parameter version to use. If `None`, uses the latest version.
	Version *int32 `json:"version"`
}

// BabylonStakingRequestDepositAction defines model for BabylonStakingRequestDeposit.Action.
type BabylonStakingRequestDepositAction string

// BabylonStakingRequestEarlyUnbond defines model for BabylonStakingRequestEarlyUnbond.
type BabylonStakingRequestEarlyUnbond struct {
	Action BabylonStakingRequestEarlyUnbondAction `json:"action"`

	// AsBase64 If `true`, the resulting PSBT is encoded as a base64 string.
	// Otherwise, it is encoded as a hex string.
	AsBase64       *bool                 `json:"as_base64,omitempty"`
	ExplicitParams *BabylonStakingParams `json:"explicit_params"`

	// FinalityProviderPks The Schnorr public key (i.e., 32-byte X-coordinate) of the finality
	// provider to which the stake is delegated.
	FinalityProviderPks []string `json:"finality_provider_pks"`

	// LockTime The lock time used for the withdrawal output in the staking deposit transaction
	LockTime int32 `json:"lock_time"`

	// Network The network-id for Babylon staking
	Network BabylonNetworkId `json:"network"`

	// StakerPk The Schnorr public key (i.e., 32-byte X-coordinate) of the staker. This
	// is the key that signs the slashing, withdrawal, and unbonding scripts.
	StakerPk string `json:"staker_pk"`

	// Txid Transaction-id of the deposit transaction to unbond or slash.
	Txid string `json:"txid"`

	// Value The value in sats that was staked in the transaction to unbond or slash.
	Value int64 `json:"value"`

	// Version The parameter version to use. If `None`, uses the latest version.
	Version *int32 `json:"version"`

	// Vout Transaction output index of the staking transaction to unbond or slash.
	// For staking transactions generated by CubeSigner, this will always be zero.
	Vout int32 `json:"vout"`
}

// BabylonStakingRequestEarlyUnbondAction defines model for BabylonStakingRequestEarlyUnbond.Action.
type BabylonStakingRequestEarlyUnbondAction string

// BabylonStakingRequestSlashDeposit defines model for BabylonStakingRequestSlashDeposit.
type BabylonStakingRequestSlashDeposit struct {
	Action BabylonStakingRequestSlashDepositAction `json:"action"`

	// AsBase64 If `true`, the resulting PSBT is encoded as a base64 string.
	// Otherwise, it is encoded as a hex string.
	AsBase64       *bool                 `json:"as_base64,omitempty"`
	ExplicitParams *BabylonStakingParams `json:"explicit_params"`

	// FinalityProviderPks The Schnorr public key (i.e., 32-byte X-coordinate) of the finality
	// provider to which the stake is delegated.
	FinalityProviderPks []string `json:"finality_provider_pks"`

	// LockTime The lock time used for the withdrawal output in the staking deposit transaction
	LockTime int32 `json:"lock_time"`

	// Network The network-id for Babylon staking
	Network BabylonNetworkId `json:"network"`

	// StakerPk The Schnorr public key (i.e., 32-byte X-coordinate) of the staker. This
	// is the key that signs the slashing, withdrawal, and unbonding scripts.
	StakerPk string `json:"staker_pk"`

	// Txid Transaction-id of the deposit transaction to unbond or slash.
	Txid string `json:"txid"`

	// Value The value in sats that was staked in the transaction to unbond or slash.
	Value int64 `json:"value"`

	// Version The parameter version to use. If `None`, uses the latest version.
	Version *int32 `json:"version"`

	// Vout Transaction output index of the staking transaction to unbond or slash.
	// For staking transactions generated by CubeSigner, this will always be zero.
	Vout int32 `json:"vout"`
}

// BabylonStakingRequestSlashDepositAction defines model for BabylonStakingRequestSlashDeposit.Action.
type BabylonStakingRequestSlashDepositAction string

// BabylonStakingRequestSlashEarlyUnbond defines model for BabylonStakingRequestSlashEarlyUnbond.
type BabylonStakingRequestSlashEarlyUnbond struct {
	Action BabylonStakingRequestSlashEarlyUnbondAction `json:"action"`

	// AsBase64 If `true`, the resulting PSBT is encoded as a base64 string.
	// Otherwise, it is encoded as a hex string.
	AsBase64       *bool                 `json:"as_base64,omitempty"`
	ExplicitParams *BabylonStakingParams `json:"explicit_params"`

	// FinalityProviderPks The Schnorr public key (i.e., 32-byte X-coordinate) of the finality
	// provider to which the stake is delegated.
	FinalityProviderPks []string `json:"finality_provider_pks"`

	// LockTime The lock time used for the withdrawal output in the staking deposit transaction
	LockTime int32 `json:"lock_time"`

	// Network The network-id for Babylon staking
	Network BabylonNetworkId `json:"network"`

	// StakerPk The Schnorr public key (i.e., 32-byte X-coordinate) of the staker. This
	// is the key that signs the slashing, withdrawal, and unbonding scripts.
	StakerPk string `json:"staker_pk"`

	// Txid Transaction-id of the deposit transaction to unbond or slash.
	Txid string `json:"txid"`

	// Value The value in sats that was staked in the transaction to unbond or slash.
	Value int64 `json:"value"`

	// Version The parameter version to use. If `None`, uses the latest version.
	Version *int32 `json:"version"`

	// Vout Transaction output index of the staking transaction to unbond or slash.
	// For staking transactions generated by CubeSigner, this will always be zero.
	Vout int32 `json:"vout"`
}

// BabylonStakingRequestSlashEarlyUnbondAction defines model for BabylonStakingRequestSlashEarlyUnbond.Action.
type BabylonStakingRequestSlashEarlyUnbondAction string

// BabylonStakingRequestWithdrawEarlyUnbond defines model for BabylonStakingRequestWithdrawEarlyUnbond.
type BabylonStakingRequestWithdrawEarlyUnbond struct {
	Action BabylonStakingRequestWithdrawEarlyUnbondAction `json:"action"`

	// AsBase64 If `true`, the resulting PSBT is encoded as a base64 string.
	// Otherwise, it is encoded as a hex string.
	AsBase64       *bool                 `json:"as_base64,omitempty"`
	ExplicitParams *BabylonStakingParams `json:"explicit_params"`

	// Fee The transaction fee value. The `fee_type` field determines whether this
	// is a fixed fee in sats or a rate in sats per (estimated) virtual byte of
	// transaction weight (i.e., sats per vb).
	Fee int64 `json:"fee"`

	// FeeType This type specifies the interpretation of the `fee` field in Babylon
	// staking requests. If `sats`, the field is intpreted as a fixed value
	// in sats. If `sats_pr_vb`, the field is interpreted as a rate and the
	// fee is computed by estimating the weight of the output transaction.
	FeeType FeeType `json:"fee_type"`

	// FinalityProviderPks The Schnorr public key (i.e., 32-byte X-coordinate) of the finality
	// provider to which the stake is delegated.
	FinalityProviderPks []string `json:"finality_provider_pks"`

	// LockTime The lock time used for the withdrawal output in the staking deposit transaction
	LockTime int32 `json:"lock_time"`

	// Network The network-id for Babylon staking
	Network BabylonNetworkId `json:"network"`

	// Recipient The withdrawal recipient, specified as a Bitcoin spend script
	Recipient string `json:"recipient"`

	// StakerPk The Schnorr public key (i.e., 32-byte X-coordinate) of the staker. This
	// is the key that signs the slashing, withdrawal, and unbonding scripts.
	StakerPk string `json:"staker_pk"`

	// Txid Transaction-id of the deposit or early unbonding transaction to withdraw from
	Txid string `json:"txid"`

	// TxnLockHeight An optional lock height (in blocks) for this transaction. The resulting
	// transaction cannot be mined before the specified block height.
	TxnLockHeight *int32 `json:"txn_lock_height"`

	// Value The value in sats that is staked in the transaction being withdrawn
	Value int64 `json:"value"`

	// Version The parameter version to use. If `None`, uses the latest version.
	Version *int32 `json:"version"`

	// Vout Transaction output index of the staking transaction from which to withdraw.
	// For staking transactions generated by CubeSigner, this will always be 0.
	// For slashing transactions generated by CubeSigner, this will always be 1.
	Vout int32 `json:"vout"`
}

// BabylonStakingRequestWithdrawEarlyUnbondAction defines model for BabylonStakingRequestWithdrawEarlyUnbond.Action.
type BabylonStakingRequestWithdrawEarlyUnbondAction string

// BabylonStakingRequestWithdrawSlashing defines model for BabylonStakingRequestWithdrawSlashing.
type BabylonStakingRequestWithdrawSlashing struct {
	Action BabylonStakingRequestWithdrawSlashingAction `json:"action"`

	// AsBase64 If `true`, the resulting PSBT is encoded as a base64 string.
	// Otherwise, it is encoded as a hex string.
	AsBase64       *bool                 `json:"as_base64,omitempty"`
	ExplicitParams *BabylonStakingParams `json:"explicit_params"`

	// Fee The transaction fee value. The `fee_type` field determines whether this
	// is a fixed fee in sats or a rate in sats per (estimated) virtual byte of
	// transaction weight (i.e., sats per vb).
	Fee int64 `json:"fee"`

	// FeeType This type specifies the interpretation of the `fee` field in Babylon
	// staking requests. If `sats`, the field is intpreted as a fixed value
	// in sats. If `sats_pr_vb`, the field is interpreted as a rate and the
	// fee is computed by estimating the weight of the output transaction.
	FeeType FeeType `json:"fee_type"`

	// FinalityProviderPks The Schnorr public key (i.e., 32-byte X-coordinate) of the finality
	// provider to which the stake is delegated.
	FinalityProviderPks []string `json:"finality_provider_pks"`

	// LockTime The lock time used for the withdrawal output in the staking deposit transaction
	LockTime int32 `json:"lock_time"`

	// Network The network-id for Babylon staking
	Network BabylonNetworkId `json:"network"`

	// Recipient The withdrawal recipient, specified as a Bitcoin spend script
	Recipient string `json:"recipient"`

	// StakerPk The Schnorr public key (i.e., 32-byte X-coordinate) of the staker. This
	// is the key that signs the slashing, withdrawal, and unbonding scripts.
	StakerPk string `json:"staker_pk"`

	// Txid Transaction-id of the deposit or early unbonding transaction to withdraw from
	Txid string `json:"txid"`

	// TxnLockHeight An optional lock height (in blocks) for this transaction. The resulting
	// transaction cannot be mined before the specified block height.
	TxnLockHeight *int32 `json:"txn_lock_height"`

	// Value The value in sats that is staked in the transaction being withdrawn
	Value int64 `json:"value"`

	// Version The parameter version to use. If `None`, uses the latest version.
	Version *int32 `json:"version"`

	// Vout Transaction output index of the staking transaction from which to withdraw.
	// For staking transactions generated by CubeSigner, this will always be 0.
	// For slashing transactions generated by CubeSigner, this will always be 1.
	Vout int32 `json:"vout"`
}

// BabylonStakingRequestWithdrawSlashingAction defines model for BabylonStakingRequestWithdrawSlashing.Action.
type BabylonStakingRequestWithdrawSlashingAction string

// BabylonStakingRequestWithdrawTimelock defines model for BabylonStakingRequestWithdrawTimelock.
type BabylonStakingRequestWithdrawTimelock struct {
	Action BabylonStakingRequestWithdrawTimelockAction `json:"action"`

	// AsBase64 If `true`, the resulting PSBT is encoded as a base64 string.
	// Otherwise, it is encoded as a hex string.
	AsBase64       *bool                 `json:"as_base64,omitempty"`
	ExplicitParams *BabylonStakingParams `json:"explicit_params"`

	// Fee The transaction fee value. The `fee_type` field determines whether this
	// is a fixed fee in sats or a rate in sats per (estimated) virtual byte of
	// transaction weight (i.e., sats per vb).
	Fee int64 `json:"fee"`

	// FeeType This type specifies the interpretation of the `fee` field in Babylon
	// staking requests. If `sats`, the field is intpreted as a fixed value
	// in sats. If `sats_pr_vb`, the field is interpreted as a rate and the
	// fee is computed by estimating the weight of the output transaction.
	FeeType FeeType `json:"fee_type"`

	// FinalityProviderPks The Schnorr public key (i.e., 32-byte X-coordinate) of the finality
	// provider to which the stake is delegated.
	FinalityProviderPks []string `json:"finality_provider_pks"`

	// LockTime The lock time used for the withdrawal output in the staking deposit transaction
	LockTime int32 `json:"lock_time"`

	// Network The network-id for Babylon staking
	Network BabylonNetworkId `json:"network"`

	// Recipient The withdrawal recipient, specified as a Bitcoin spend script
	Recipient string `json:"recipient"`

	// StakerPk The Schnorr public key (i.e., 32-byte X-coordinate) of the staker. This
	// is the key that signs the slashing, withdrawal, and unbonding scripts.
	StakerPk string `json:"staker_pk"`

	// Txid Transaction-id of the deposit or early unbonding transaction to withdraw from
	Txid string `json:"txid"`

	// TxnLockHeight An optional lock height (in blocks) for this transaction. The resulting
	// transaction cannot be mined before the specified block height.
	TxnLockHeight *int32 `json:"txn_lock_height"`

	// Value The value in sats that is staked in the transaction being withdrawn
	Value int64 `json:"value"`

	// Version The parameter version to use. If `None`, uses the latest version.
	Version *int32 `json:"version"`

	// Vout Transaction output index of the staking transaction from which to withdraw.
	// For staking transactions generated by CubeSigner, this will always be 0.
	// For slashing transactions generated by CubeSigner, this will always be 1.
	Vout int32 `json:"vout"`
}

// BabylonStakingRequestWithdrawTimelockAction defines model for BabylonStakingRequestWithdrawTimelock.Action.
type BabylonStakingRequestWithdrawTimelockAction string

// BabylonStakingResponse defines model for BabylonStakingResponse.
type BabylonStakingResponse struct {
	// Fee The transaction fee in sats
	Fee int64 `json:"fee"`

	// Psbt The PSBT in either hex or base64 serialization
	Psbt string `json:"psbt"`
}

// BabylonStakingWithdrawal defines model for BabylonStakingWithdrawal.
type BabylonStakingWithdrawal struct {
	// AsBase64 If `true`, the resulting PSBT is encoded as a base64 string.
	// Otherwise, it is encoded as a hex string.
	AsBase64       *bool                 `json:"as_base64,omitempty"`
	ExplicitParams *BabylonStakingParams `json:"explicit_params"`

	// Fee The transaction fee value. The `fee_type` field determines whether this
	// is a fixed fee in sats or a rate in sats per (estimated) virtual byte of
	// transaction weight (i.e., sats per vb).
	Fee int64 `json:"fee"`

	// FeeType This type specifies the interpretation of the `fee` field in Babylon
	// staking requests. If `sats`, the field is intpreted as a fixed value
	// in sats. If `sats_pr_vb`, the field is interpreted as a rate and the
	// fee is computed by estimating the weight of the output transaction.
	FeeType FeeType `json:"fee_type"`

	// FinalityProviderPks The Schnorr public key (i.e., 32-byte X-coordinate) of the finality
	// provider to which the stake is delegated.
	FinalityProviderPks []string `json:"finality_provider_pks"`

	// LockTime The lock time used for the withdrawal output in the staking deposit transaction
	LockTime int32 `json:"lock_time"`

	// Network The network-id for Babylon staking
	Network BabylonNetworkId `json:"network"`

	// Recipient The withdrawal recipient, specified as a Bitcoin spend script
	Recipient string `json:"recipient"`

	// StakerPk The Schnorr public key (i.e., 32-byte X-coordinate) of the staker. This
	// is the key that signs the slashing, withdrawal, and unbonding scripts.
	StakerPk string `json:"staker_pk"`

	// Txid Transaction-id of the deposit or early unbonding transaction to withdraw from
	Txid string `json:"txid"`

	// TxnLockHeight An optional lock height (in blocks) for this transaction. The resulting
	// transaction cannot be mined before the specified block height.
	TxnLockHeight *int32 `json:"txn_lock_height"`

	// Value The value in sats that is staked in the transaction being withdrawn
	Value int64 `json:"value"`

	// Version The parameter version to use. If `None`, uses the latest version.
	Version *int32 `json:"version"`

	// Vout Transaction output index of the staking transaction from which to withdraw.
	// For staking transactions generated by CubeSigner, this will always be 0.
	// For slashing transactions generated by CubeSigner, this will always be 1.
	Vout int32 `json:"vout"`
}

// BadGatewayErrorCode defines model for BadGatewayErrorCode.
type BadGatewayErrorCode string

// BadRequestErrorCode defines model for BadRequestErrorCode.
type BadRequestErrorCode string

// BillingDimensions defines model for BillingDimensions.
type BillingDimensions struct {
	// Kind Billing event types.
	Kind BillingEvent `json:"kind"`

	// OrgId All metrics must include 'org_id' as a dimension.
	OrgId string `json:"org_id"`
}

// BillingEvent Billing event types.
type BillingEvent string

// BlobSignRequest defines model for BlobSignRequest.
type BlobSignRequest struct {
	// AdaptorPk An optional base64 string comprising a SEC1-encoded secp256k1 public key.
	// This field can be used *only* with Schnorr keys.
	//
	// If this field is present, the response will be a Schnorr adaptor signature
	// in the format specified by Blockstream for use in libsecp256k1-zkp. See
	// <https://github.com/ZhePang/Python_Specification_for_Schnorr_Adaptor/>
	// for more information.
	AdaptorPk *string `json:"adaptor_pk"`

	// BlsDst An optional domain separation tag for use *only* with BLS signing requests.
	// This field must not be supplied for requests involving non-BLS key types.
	//
	// If this field is not present or null, the domain separation tag specified in
	// the IETF BLS Signatures draft versions 4 and 5, section 4.2.3 (minimal pubkey
	// size variant) is used.
	//
	// Otherwise, this field must contain a base-64 string encoding a non-empty byte
	// vector. When using a custom tag, RFC9380 (Section 3.1) recommends a length of
	// at least 16 bytes.
	BlsDst *string `json:"bls_dst"`

	// MessageBase64 The blob to sign, encoded as a base64 string.
	//
	// Note that certain signing keys impose additional requirements on the contents of
	// the message. For example, Secp256k1 keys require that the message is 32 bytes long.
	MessageBase64 string `json:"message_base64"`

	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata interface{} `json:"metadata"`

	// SegwitTweak An optional tweak value for use *only* with Segwit (i.e., SecpBtc and SecpBtcTest)
	// keys. This field must not be supplied for requests involving any other key type.
	//
	// If this field is not present or null, no tweak is applied. Otherwise, this field
	// must contain a base-64 string encoding a vector of exactly 32 bytes. See the
	// CubeSigner documentation for more information on the Segwit tweaking procedure.
	SegwitTweak *string `json:"segwit_tweak"`

	// TaprootTweak An optional tweak value for use *only* with Taproot keys. This field must not
	// be supplied for requests involving any other key type.
	//
	// If this field is not present or null, no tweak is applied. If the field is an
	// empty string, the key is tweaked with an unspendable script path per BIP0341.
	// Otherwise, this field must contain a 32-byte, base-64 string representing the
	// Merkle root with which to tweak the key before signing.
	TaprootTweak *string `json:"taproot_tweak"`
}

// BtcChain Supported BTC chains.
type BtcChain string

// BtcLeafHashCodeSeparator Leaf hash and code, as per BIP341 and https://github.com/rust-bitcoin/rust-bitcoin/blob/464202109d2b2c96e9b4867461bffe420dbd8177/bitcoin/src/crypto/sighash.rs#L691
type BtcLeafHashCodeSeparator struct {
	// CodeSeparator Code separator
	CodeSeparator int32 `json:"code_separator"`

	// LeafHash Taproot-tagged hash with tag "TapLeaf".
	LeafHash string `json:"leaf_hash"`
}

// BtcMessageSignRequest defines model for BtcMessageSignRequest.
type BtcMessageSignRequest struct {
	// Data Message to sign as a hex-encoded byte string.
	Data string `json:"data"`

	// IsP2sh For segwit, sign the message as p2sh-p2wpkh instead of p2wpkh
	IsP2sh *bool `json:"is_p2sh,omitempty"`

	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata interface{} `json:"metadata"`
}

// BtcMessageSignResponse BTC message signing response
type BtcMessageSignResponse struct {
	// Sig The base64-encoded signature in BIP137 format.
	Sig string `json:"sig"`
}

// BtcSighashType defines model for BtcSighashType.
type BtcSighashType string

// BtcSignRequest defines model for BtcSignRequest.
type BtcSignRequest struct {
	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata interface{}      `json:"metadata"`
	SigKind  BtcSignatureKind `json:"sig_kind"`
	Tx       BtcTx            `json:"tx"`
}

// BtcSignatureKind defines model for BtcSignatureKind.
type BtcSignatureKind struct {
	// Segwit Segregated Witness
	Segwit struct {
		// InputIndex Transaction input index
		InputIndex int `json:"input_index"`

		// ScriptCode Script
		ScriptCode  string         `json:"script_code"`
		SighashType BtcSighashType `json:"sighash_type"`

		// Tweak Optional tweak to apply to the key before signing.
		//
		// When supplied, this field must contain a base-64 string encoding a vector of
		// exactly 32 bytes, which are used to compute the tweaked public key. See the
		// CubeSigner documentation for more information on the Segwit tweaking procedure.
		Tweak *string `json:"tweak"`

		// Value The total amount of the input (in satoshis).
		Value int64 `json:"value"`
	} `json:"Segwit"`
}

// BtcTx defines model for BtcTx.
type BtcTx = map[string]interface{}

// BtcTxOut defines model for BtcTxOut.
type BtcTxOut struct {
	// ScriptPubkey The script which must be satisfied for the output to be spent.
	ScriptPubkey string `json:"script_pubkey"`

	// Value The value of the output, in satoshis.
	Value int64 `json:"value"`
}

// ChallengePieces Describes how to derive a WebAuthn challenge value.
type ChallengePieces struct {
	// Preimage A base64url encoding of UTF8 JSON. The data in that JSON is endpoint specific, and describes what this FIDO challenge will be used for.
	//
	// Clients can use `preimage` along with `random_seed` to reconstruct the challenge like so:
	//
	// `challenge = HMAC-SHA256(key=random_seed, message=preimage)`
	Preimage string `json:"preimage"`

	// RandomSeed A random seed that prevents replay attacks
	RandomSeed string `json:"random_seed"`
}

// ClientProfile Client information representing the nature of front-end in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`].
type ClientProfile struct {
	// Agent Agent/Product name
	Agent *string `json:"agent"`

	// Engine Name of the engine
	Engine *string `json:"engine"`

	// Version Agent/product version
	Version *string `json:"version"`
}

// ClientSessionInfo Session information sent to the client.
// This struct works in tandem with its server-side counterpart [`SessionData`].
type ClientSessionInfo struct {
	// AuthToken Token to use for authorization.
	AuthToken string `json:"auth_token"`

	// AuthTokenExp DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	AuthTokenExp EpochDateTime `json:"auth_token_exp"`

	// Epoch Epoch at which the token was last refreshed
	Epoch int32 `json:"epoch"`

	// EpochToken Wrapper around a zeroizing 32-byte fixed-size array
	EpochToken B32 `json:"epoch_token"`

	// RefreshToken Token to use for refreshing the `(auth, refresh)` token pair
	RefreshToken string `json:"refresh_token"`

	// RefreshTokenExp DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	RefreshTokenExp EpochDateTime `json:"refresh_token_exp"`

	// SessionId Session ID
	SessionId string `json:"session_id"`
}

// ClientSessionMetadata Attributes that are expected to be provided by the client
type ClientSessionMetadata struct {
	// Client Client information representing the nature of front-end in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`].
	Client *ClientProfile `json:"client,omitempty"`

	// OsInfo OS information set in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`]
	OsInfo *OsInfo `json:"os_info,omitempty"`
}

// CommonFields Fields that are common to different types of resources such as keys
type CommonFields struct {
	Created *EpochDateTime `json:"created"`

	// EditPolicy A policy which governs when and who is allowed to update the entity this policy is
	// attached to (e.g., a role or a key).
	//
	// When attached to a role, by default, this policy applies to role deletion and all
	// role updates (including adding/removing keys and users); in terms of scopes,
	// it applies to `manage:role:update:*` and `manage:role:delete`.
	//
	// When attached to a key, by default, this policy applies to key deletion, all
	// key updates, and adding/removing that key to/from a role; in terms of scopes,
	// it applies to `manage:key:update:*`, `manage:key:delete`, `manage:role:update:key:*`.
	//
	// This default can be changed by setting the `applies_to_scopes` property.
	EditPolicy   *EditPolicy    `json:"edit_policy,omitempty"`
	LastModified *EpochDateTime `json:"last_modified"`

	// Metadata User-defined metadata. When rendering (e.g., in the browser) you should treat
	// it as untrusted user data (and avoid injecting metadata into HTML directly) if
	// untrusted users can create/update keys (or their metadata).
	Metadata interface{} `json:"metadata,omitempty"`

	// Version Version of this object
	Version *int64 `json:"version,omitempty"`
}

// CompleteMfaResetRequest defines model for CompleteMfaResetRequest.
type CompleteMfaResetRequest struct {
	// Token The reset token emailed to the user
	Token string `json:"token"`
}

// ComputeCountsResponse The number of users and keys in an org, organized by user role and key type
type ComputeCountsResponse struct {
	// Keys A map of a `KeyType` to the amount of keys with that type in the org.
	Keys map[string]int `json:"keys"`

	// Users A map of a `MemberRole` to the amount of number of users with that role in the org.
	Users map[string]int `json:"users"`
}

// ConfigureEmailRequest defines model for ConfigureEmailRequest.
type ConfigureEmailRequest struct {
	Auth struct {
		Smtp string `json:"smtp"`
	} `json:"auth"`

	// Sender The email address that emails will be sent from
	Sender   string `json:"sender"`
	Template *struct {
		// BodyTemplate An HTML template to use for the body.
		BodyTemplate string `json:"body_template"`

		// SubjectTemplate The subject line template
		SubjectTemplate string `json:"subject_template"`
	} `json:"template"`
}

// ConfiguredMfa defines model for ConfiguredMfa.
type ConfiguredMfa struct {
	union json.RawMessage
}

// ConfiguredMfaFido Named FIDO device (multiple can be configured per user)
type ConfiguredMfaFido struct {
	// Aaguid UUID of the device type
	Aaguid string `json:"aaguid"`

	// CreatedAt Creation date
	CreatedAt int64 `json:"created_at"`

	// Discoverable Whether this key was requested to be discoverable.
	Discoverable bool `json:"discoverable"`

	// Id A unique credential id
	Id string `json:"id"`

	// LastUsedAt Last used date
	LastUsedAt int64 `json:"last_used_at"`

	// Name A human-readable name given to the key
	Name string                `json:"name"`
	Type ConfiguredMfaFidoType `json:"type"`
}

// ConfiguredMfaFidoType defines model for ConfiguredMfaFido.Type.
type ConfiguredMfaFidoType string

// ConfiguredMfaTotp defines model for ConfiguredMfaTotp.
type ConfiguredMfaTotp struct {
	Type ConfiguredMfaTotpType `json:"type"`
}

// ConfiguredMfaTotpType defines model for ConfiguredMfaTotp.Type.
type ConfiguredMfaTotpType string

// ConflictErrorCode defines model for ConflictErrorCode.
type ConflictErrorCode string

// Contact defines model for Contact.
type Contact struct {
	// Addresses A mapping of networks to their associated chains and addresses.
	Addresses AddressMap     `json:"addresses"`
	Created   *EpochDateTime `json:"created"`

	// EditPolicy A policy which governs when and who is allowed to update the entity this policy is
	// attached to (e.g., a role or a key).
	//
	// When attached to a role, by default, this policy applies to role deletion and all
	// role updates (including adding/removing keys and users); in terms of scopes,
	// it applies to `manage:role:update:*` and `manage:role:delete`.
	//
	// When attached to a key, by default, this policy applies to key deletion, all
	// key updates, and adding/removing that key to/from a role; in terms of scopes,
	// it applies to `manage:key:update:*`, `manage:key:delete`, `manage:role:update:key:*`.
	//
	// This default can be changed by setting the `applies_to_scopes` property.
	EditPolicy   *EditPolicy    `json:"edit_policy,omitempty"`
	LastModified *EpochDateTime `json:"last_modified"`

	// Metadata User-defined metadata. When rendering (e.g., in the browser) you should treat
	// it as untrusted user data (and avoid injecting metadata into HTML directly) if
	// untrusted users can create/update keys (or their metadata).
	Metadata interface{} `json:"metadata,omitempty"`

	// Name The name of the contact.
	Name  string `json:"name"`
	Owner Id     `json:"owner"`

	// Version Version of this object
	Version *int64 `json:"version,omitempty"`
}

// ContactInfo defines model for ContactInfo.
type ContactInfo struct {
	// Addresses A mapping of networks to their associated chains and addresses.
	Addresses AddressMap     `json:"addresses"`
	Created   *EpochDateTime `json:"created"`

	// EditPolicy A policy which governs when and who is allowed to update the entity this policy is
	// attached to (e.g., a role or a key).
	//
	// When attached to a role, by default, this policy applies to role deletion and all
	// role updates (including adding/removing keys and users); in terms of scopes,
	// it applies to `manage:role:update:*` and `manage:role:delete`.
	//
	// When attached to a key, by default, this policy applies to key deletion, all
	// key updates, and adding/removing that key to/from a role; in terms of scopes,
	// it applies to `manage:key:update:*`, `manage:key:delete`, `manage:role:update:key:*`.
	//
	// This default can be changed by setting the `applies_to_scopes` property.
	EditPolicy   *EditPolicy    `json:"edit_policy,omitempty"`
	Id           Id             `json:"id"`
	LastModified *EpochDateTime `json:"last_modified"`

	// Metadata User-defined metadata. When rendering (e.g., in the browser) you should treat
	// it as untrusted user data (and avoid injecting metadata into HTML directly) if
	// untrusted users can create/update keys (or their metadata).
	Metadata interface{} `json:"metadata,omitempty"`

	// Name The name of the contact.
	Name  string `json:"name"`
	Owner Id     `json:"owner"`

	// Version Version of this object
	Version *int64 `json:"version,omitempty"`
}

// CreateAndUpdateKeyProperties defines model for CreateAndUpdateKeyProperties.
type CreateAndUpdateKeyProperties struct {
	EditPolicy *EditPolicy `json:"edit_policy"`

	// Metadata Set this key's metadata. If this value is `null`, the metadata is erased. If the field is
	// missing, the metadata remains unchanged.
	Metadata interface{} `json:"metadata,omitempty"`

	// Owner Specify a user other than themselves to be the (potentially new) owner of the key.
	// The specified owner must be an existing user who is a member of the same org.
	Owner *string `json:"owner"`

	// Policy Set this key's policies. For an existing key, this overwrites all its policies.
	Policy *[]interface{} `json:"policy"`
}

// CreateContactRequest The information needed to create a Contact.
type CreateContactRequest struct {
	// Addresses A mapping of networks to their associated chains and addresses.
	Addresses  AddressMap  `json:"addresses"`
	EditPolicy *EditPolicy `json:"edit_policy"`

	// Metadata Optional user-defined metadata about the contact.
	Metadata interface{} `json:"metadata"`

	// Name The name for the contact. Must be unique among contacts in the
	// org. Duplicate contact names will be rejected. Name must consist of
	// alphanumeric characters, spaces, `.` and `-`, and cannot be longer than
	// 50 characters.
	Name string `json:"name"`
}

// CreateKeyImportKeyResponse defines model for CreateKeyImportKeyResponse.
type CreateKeyImportKeyResponse struct {
	// DkEnc Base64-encoded, encrypted data key.
	DkEnc string `json:"dk_enc"`

	// EnclaveAttestation An attestation document from a secure enclave, including an
	// RSA signing key used to sign the contents of this message.
	EnclaveAttestation string `json:"enclave_attestation"`

	// EnclaveSignature An RSA-PSS-SHA256 signature on the public key and encrypted
	// secrets attesting to their generation inside a secure enclave.
	EnclaveSignature string `json:"enclave_signature"`

	// Expires Expiration timestamp expressed as seconds since the UNIX epoch.
	Expires int64 `json:"expires"`

	// PublicKey The ephemeral public key to which an imported key should be encrypted.
	// This is a P384 public key in base64-encoded uncompressed SECG format.
	PublicKey string `json:"public_key"`

	// SkEnc Base64-encoded, encrypted secret key.
	SkEnc string `json:"sk_enc"`
}

// CreateKeyRequest defines model for CreateKeyRequest.
type CreateKeyRequest struct {
	// ChainId Chain id for which the key is allowed to sign messages
	ChainId *int64 `json:"chain_id"`

	// Count Number of keys to create
	Count      int32       `json:"count"`
	EditPolicy *EditPolicy `json:"edit_policy"`
	KeyType    KeyType     `json:"key_type"`

	// Metadata Set this key's metadata. If this value is `null`, the metadata is erased. If the field is
	// missing, the metadata remains unchanged.
	Metadata interface{} `json:"metadata,omitempty"`

	// Owner Specify a user other than themselves to be the (potentially new) owner of the key.
	// The specified owner must be an existing user who is a member of the same org.
	Owner *string `json:"owner"`

	// Policy Set this key's policies. For an existing key, this overwrites all its policies.
	Policy *[]interface{} `json:"policy"`
}

// CreateKeyResponse defines model for CreateKeyResponse.
type CreateKeyResponse struct {
	// Keys The info about the created keys
	Keys []KeyInfo `json:"keys"`
}

// CreateOrgRequest defines model for CreateOrgRequest.
type CreateOrgRequest struct {
	// MetricsEnabled Whether to enable metrics for the new organization
	MetricsEnabled *bool `json:"metrics_enabled,omitempty"`

	// Name The human readable name of the new organization
	Name string `json:"name"`
}

// CreatePolicyImportKeyResponse defines model for CreatePolicyImportKeyResponse.
type CreatePolicyImportKeyResponse struct {
	// DkEnc Base64-encoded, encrypted data key.
	DkEnc string `json:"dk_enc"`

	// EnclaveAttestation An attestation document from a secure enclave, including an
	// RSA signing key used to sign the contents of this message.
	EnclaveAttestation string `json:"enclave_attestation"`

	// EnclaveSignature An RSA-PSS-SHA256 signature on the public key and encrypted
	// secrets attesting to their generation inside a secure enclave.
	EnclaveSignature string `json:"enclave_signature"`

	// Expires Expiration timestamp expressed as seconds since the UNIX epoch.
	Expires int64 `json:"expires"`

	// PublicKey The ephemeral public key to which an imported key should be encrypted.
	// This is a P384 public key in base64-encoded uncompressed SECG format.
	PublicKey string `json:"public_key"`

	// SkEnc Base64-encoded, encrypted secret key.
	SkEnc string `json:"sk_enc"`
}

// CreatePolicyRequest Request for creating a named policy
type CreatePolicyRequest struct {
	EditPolicy *EditPolicy `json:"edit_policy"`

	// Metadata Optional metadata.
	Metadata interface{} `json:"metadata"`

	// Name The policy name.
	// Must be unique among the named policies in this org. Duplicate policy names
	// will be rejected.
	Name string `json:"name"`

	// PolicyType The type of a [NamedPolicy].
	//
	// The type of a policy is set at creation time, and is used to offer guarantees
	// about the current and all future versions of a [NamedPolicy].
	PolicyType PolicyType `json:"policy_type"`

	// Rules The policy rules.
	Rules []interface{} `json:"rules"`
}

// CreateRoleRequest Optional create role request body
type CreateRoleRequest struct {
	// Name A human-readable name for the role.
	Name string `json:"name"`
}

// CreateRoleResponse The newly created role information
type CreateRoleResponse struct {
	// Name A human-readable name for the role.
	Name *string `json:"name"`

	// RoleId The id of the newly created role
	RoleId string `json:"role_id"`
}

// CreateSessionRequest defines model for CreateSessionRequest.
type CreateSessionRequest struct {
	// AuthLifetime The lifetime (in seconds) of auth tokens for this session.
	// Auth tokens can be refreshed (renewed) using a valid (unexpired)
	// refresh token, but not beyond the session lifetime.
	AuthLifetime *int64 `json:"auth_lifetime,omitempty"`

	// Client Client information representing the nature of front-end in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`].
	Client *ClientProfile `json:"client,omitempty"`

	// ExtendLifetimes By default, the requested session and auth lifetimes are truncated to be at most requestor's
	// session and auth lifetime, respectively. To extend the requested lifetimes past the
	// requestor's, set this property to `true` (in which case MFA will be required).
	ExtendLifetimes *bool `json:"extend_lifetimes,omitempty"`

	// GraceLifetime The amount of time (in seconds) that an auth token for this session remains
	// valid after it has been refreshed and a new auth token has been issued. This
	// helps to address concurrency hazards, for example, if one thread makes requests
	// with auth token while another refreshes it.
	GraceLifetime *int64 `json:"grace_lifetime,omitempty"`

	// OsInfo OS information set in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`]
	OsInfo *OsInfo `json:"os_info,omitempty"`

	// Purpose A human readable description of the session's purpose
	Purpose string `json:"purpose"`

	// RefreshLifetime The lifetime (in seconds) of refresh tokens for this session.
	// If this value is shorter than the session lifetime, inactive sessions
	// will become invalid once the auth and refresh tokens have both expired.
	RefreshLifetime *int64 `json:"refresh_lifetime,omitempty"`

	// Scopes Controls what capabilities this session will have.
	Scopes []Scope `json:"scopes"`

	// SessionLifetime The lifetime (in seconds) of the session.
	// The session cannot be extended beyond its original lifetime.
	SessionLifetime *int64 `json:"session_lifetime,omitempty"`
}

// CreateTokenRequest defines model for CreateTokenRequest.
type CreateTokenRequest struct {
	// AuthLifetime The lifetime (in seconds) of auth tokens for this session.
	// Auth tokens can be refreshed (renewed) using a valid (unexpired)
	// refresh token, but not beyond the session lifetime.
	AuthLifetime *int64 `json:"auth_lifetime,omitempty"`

	// Client Client information representing the nature of front-end in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`].
	Client *ClientProfile `json:"client,omitempty"`

	// GraceLifetime The amount of time (in seconds) that an auth token for this session remains
	// valid after it has been refreshed and a new auth token has been issued. This
	// helps to address concurrency hazards, for example, if one thread makes requests
	// with auth token while another refreshes it.
	GraceLifetime *int64 `json:"grace_lifetime,omitempty"`

	// OsInfo OS information set in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`]
	OsInfo *OsInfo `json:"os_info,omitempty"`

	// Purpose A human readable description of the purpose of the key
	Purpose string `json:"purpose"`

	// RefreshLifetime The lifetime (in seconds) of refresh tokens for this session.
	// If this value is shorter than the session lifetime, inactive sessions
	// will become invalid once the auth and refresh tokens have both expired.
	RefreshLifetime *int64 `json:"refresh_lifetime,omitempty"`

	// Scopes Controls what capabilities this session will have. By default, it has all
	// signing capabilities, i.e., just the 'sign:*' scope.
	Scopes *[]Scope `json:"scopes"`

	// SessionLifetime The lifetime (in seconds) of the session.
	// The session cannot be extended beyond its original lifetime.
	SessionLifetime *int64 `json:"session_lifetime,omitempty"`
}

// CreationOptionsWithHash defines model for CreationOptionsWithHash.
type CreationOptionsWithHash struct {
	// Options Defines the parameters for the creation of a new public key credential
	//
	// https://www.w3.org/TR/webauthn-2/#dictdef-publickeycredentialcreationoptions
	Options PublicKeyCredentialCreationOptions `json:"options"`

	// Preimage A base64url encoding of UTF8 JSON. The data in that JSON is endpoint specific, and describes what this FIDO challenge will be used for.
	//
	// Clients can use `preimage` along with `random_seed` to reconstruct the challenge like so:
	//
	// `challenge = HMAC-SHA256(key=random_seed, message=preimage)`
	Preimage string `json:"preimage"`

	// RandomSeed A random seed that prevents replay attacks
	RandomSeed string `json:"random_seed"`
}

// CubeSignerUserInfo defines model for CubeSignerUserInfo.
type CubeSignerUserInfo struct {
	// ConfiguredMfa All multi-factor authentication methods configured for this user
	ConfiguredMfa []ConfiguredMfa `json:"configured_mfa"`

	// Initialized Set once the user successfully logs into CubeSigner
	Initialized bool `json:"initialized"`

	// Name Optional human name for the user
	Name *string `json:"name"`

	// UserId CubeSigner's user identifier
	UserId string `json:"user_id"`
}

// DepositTxn Information produced by a successful deposit
type DepositTxn struct {
	// ChainId Chain ID for which the deposit transaction was created
	ChainId int64 `json:"chain_id"`

	// DepositTxn The deposit transaction. Includes only `to`, `value`, and `data` fields.
	DepositTxn map[string]interface{} `json:"deposit_txn"`

	// NewValidatorPk The hex-encoded compressed form of the new validator BLS public key
	NewValidatorPk string `json:"new_validator_pk"`
}

// DepositType The type of deposit to perform
type DepositType string

// DeriveKeyRequest defines model for DeriveKeyRequest.
type DeriveKeyRequest struct {
	// DerivationPath List of derivation paths for which to derive.
	DerivationPath []string    `json:"derivation_path"`
	EditPolicy     *EditPolicy `json:"edit_policy"`

	// Idempotent When false (the default), nothing is returned when a derived key already
	// exists. When true, returns the KeyInfo struct for keys that already exist
	// if caller is allowed to list that key.
	Idempotent *bool   `json:"idempotent,omitempty"`
	KeyType    KeyType `json:"key_type"`

	// Metadata Set this key's metadata. If this value is `null`, the metadata is erased. If the field is
	// missing, the metadata remains unchanged.
	Metadata interface{} `json:"metadata,omitempty"`

	// MnemonicId Material-id of the mnemonic to use for derivation.
	MnemonicId string `json:"mnemonic_id"`

	// Owner Specify a user other than themselves to be the (potentially new) owner of the key.
	// The specified owner must be an existing user who is a member of the same org.
	Owner *string `json:"owner"`

	// Policy Set this key's policies. For an existing key, this overwrites all its policies.
	Policy *[]interface{} `json:"policy"`
}

// DeriveKeysRequest defines model for DeriveKeysRequest.
type DeriveKeysRequest struct {
	EditPolicy *EditPolicy `json:"edit_policy"`

	// Idempotent When false (the default), nothing is returned when a derived key already
	// exists. When true, returns the KeyInfo struct for keys that already exist
	// if caller is allowed to list that key.
	Idempotent *bool `json:"idempotent,omitempty"`

	// KeyTypesAndDerivationPaths Key types and corresponding paths for derivation, plus optional
	// policies to include for specific keys. It is an error to specify
	// a policy that does not apply to the corresponding key type.
	KeyTypesAndDerivationPaths []KeyTypeAndDerivationPath `json:"key_types_and_derivation_paths"`

	// Metadata Set this key's metadata. If this value is `null`, the metadata is erased. If the field is
	// missing, the metadata remains unchanged.
	Metadata interface{} `json:"metadata,omitempty"`

	// MnemonicId Material-id of the mnemonic to use for derivation. If unspecified,
	// a new mnemonic is first created.
	MnemonicId *string `json:"mnemonic_id"`

	// Owner Specify a user other than themselves to be the (potentially new) owner of the key.
	// The specified owner must be an existing user who is a member of the same org.
	Owner *string `json:"owner"`

	// Policy Set this key's policies. For an existing key, this overwrites all its policies.
	Policy *[]interface{} `json:"policy"`
}

// DiffieHellmanRequest defines model for DiffieHellmanRequest.
type DiffieHellmanRequest struct {
	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata interface{} `json:"metadata"`

	// Points The set of serialized elliptic curve points from which to compute shared secrets.
	// The serialization format of these points depends on the key type; see the CubeSigner
	// documentation for more information.
	Points []string `json:"points"`

	// PublicKey An optional NIST P-256 public key (base64-encoded SEC1 with or without compression).
	//
	// If provided, the response will be encrypted to this public key using RFC9180
	// HPKE-DHKEM(P-256, HKDF-SHA256) with AES-256-GCM as the symmetric cipher.
	//
	// If no public key is specified, the results will be returned unencrypted. In this
	// case, the input points should be masked with a random scalar to avoid leaking the
	// shared secret in the response; the results can be unmasked via point multiplication
	// with the inverse of the masking scalar.
	PublicKey *string `json:"public_key"`
}

// DiffieHellmanResponse The result of a Diffie Hellman key exchange
type DiffieHellmanResponse struct {
	union json.RawMessage
}

// DiffieHellmanResponseEncrypted defines model for DiffieHellmanResponseEncrypted.
type DiffieHellmanResponseEncrypted struct {
	// EncryptedSharedSecrets A ciphertext containing the resulting points. The enclosed plaintext is a sequence
	// of base64-encoded byte strings in a key-type--dependent format.
	EncryptedSharedSecrets string `json:"encrypted_shared_secrets"`

	// EphemeralPublicKey The ephemeral public key used for HPKE key derivation in base64-encoded
	// uncompressed SEC1 serialization.
	EphemeralPublicKey string                                     `json:"ephemeral_public_key"`
	ResponseType       DiffieHellmanResponseEncryptedResponseType `json:"response_type"`
}

// DiffieHellmanResponseEncryptedResponseType defines model for DiffieHellmanResponseEncrypted.ResponseType.
type DiffieHellmanResponseEncryptedResponseType string

// DiffieHellmanResponseMasked defines model for DiffieHellmanResponseMasked.
type DiffieHellmanResponseMasked struct {
	// Points The resulting points as base64-encoded byte strings in a key-type--dependent format.
	Points       []string                                `json:"points"`
	ResponseType DiffieHellmanResponseMaskedResponseType `json:"response_type"`
}

// DiffieHellmanResponseMaskedResponseType defines model for DiffieHellmanResponseMasked.ResponseType.
type DiffieHellmanResponseMaskedResponseType string

// EditPolicy A policy which governs when and who is allowed to update the entity this policy is
// attached to (e.g., a role or a key).
//
// When attached to a role, by default, this policy applies to role deletion and all
// role updates (including adding/removing keys and users); in terms of scopes,
// it applies to `manage:role:update:*` and `manage:role:delete`.
//
// When attached to a key, by default, this policy applies to key deletion, all
// key updates, and adding/removing that key to/from a role; in terms of scopes,
// it applies to `manage:key:update:*`, `manage:key:delete`, `manage:role:update:key:*`.
//
// This default can be changed by setting the `applies_to_scopes` property.
type EditPolicy struct {
	// AppliesToScopes A set of scopes.
	AppliesToScopes *ScopeSet      `json:"applies_to_scopes,omitempty"`
	Mfa             *MfaPolicy     `json:"mfa"`
	TimeLockUntil   *EpochDateTime `json:"time_lock_until"`
}

// Eip191SignRequest defines model for Eip191SignRequest.
type Eip191SignRequest struct {
	// Data EIP-191 data to sign as hex-encoded bytes.
	Data string `json:"data"`

	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata interface{} `json:"metadata"`
}

// Eip712SignRequest defines model for Eip712SignRequest.
type Eip712SignRequest struct {
	// ChainId The chain-id to which this typed data will be sent
	ChainId int64 `json:"chain_id"`

	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata interface{} `json:"metadata"`

	// TypedData Represents the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) typed data object.
	//
	// Typed data is a JSON object containing type information, domain separator parameters and the
	// message object.
	TypedData TypedData `json:"typed_data"`
}

// Email defines model for Email.
type Email = string

// EmailOtpAnswer An answer to the challenge returned by the `mfa_email_init` endpoint.
type EmailOtpAnswer struct {
	// Token Full JWT token, constructed by concatenating the "partial token"
	// (i.e., `{header}.{payload}.`) returned by the `mail_email_init` endpoint
	// and the signature sent to the user's email.
	Token string `json:"token"`
}

// EmailOtpRequest The request users send to initiate email OTP
type EmailOtpRequest struct {
	// Email The email which will receive the OTP
	Email string `json:"email"`
}

// EmailOtpResponse The HTTP response to an email OTP request.
//
// This response contains an OIDC token without a signature.
// The signature is sent to the end-user in an email.
// The token can be reconstructed by concatenating the `partial_token` with the signature.
type EmailOtpResponse struct {
	// PartialToken The OIDC token without the signature.
	// (The signature, which is actually a MAC, is sent to the end-user in an email)
	PartialToken string `json:"partial_token"`
}

// EmailPreferences defines model for EmailPreferences.
type EmailPreferences struct {
	// AlertRecipients Recipient users for org-level alerts
	AlertRecipients *[]Id `json:"alert_recipients"`

	// LoginNotifications If true, send notifications on every login
	LoginNotifications *bool `json:"login_notifications"`

	// NewDevice If true, send notifications when logging in from a new device.
	// new_device takes precedence over login_notifications. E.g., email for
	// new_device is sent instead of a general login notification email when a
	// new device is detected
	NewDevice *bool `json:"new_device"`

	// PendingApprovals If true, send email notifications for mfa approvals
	PendingApprovals *bool `json:"pending_approvals"`

	// SubscribedAlerts Org-level alerts to send emails for
	SubscribedAlerts *[]AlertKind `json:"subscribed_alerts"`
}

// EmailResetRequest Request to reset verified email.
type EmailResetRequest struct {
	// AllowOtpLogin Whether this email should be usable for email OTP login. The request
	// will fail if this field is set to `true`, and the org does not have
	// email OTP enabled. Default: `false`
	AllowOtpLogin *bool `json:"allow_otp_login"`

	// Email The email to register
	Email string `json:"email"`
}

// Empty defines model for Empty.
type Empty = interface{}

// EmptyImpl defines model for EmptyImpl.
type EmptyImpl struct {
	Status string `json:"status"`
}

// EotsCreateNonceRequest defines model for EotsCreateNonceRequest.
type EotsCreateNonceRequest struct {
	// ChainId The chain id for which the nonces will be used, as a hex string
	ChainId string `json:"chain_id"`

	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata interface{} `json:"metadata"`

	// Num The number of nonces to generate
	Num int32 `json:"num"`

	// StartHeight The starting block height of the generated nonces (quoted decimal u64)
	StartHeight string `json:"start_height"`
}

// EotsCreateNonceResponse Response generated when creating EOTS nonces
type EotsCreateNonceResponse struct {
	// Nonces The generated nonces as an array of 0x-prefixed hex strings
	Nonces []string `json:"nonces"`
}

// EotsSignRequest defines model for EotsSignRequest.
type EotsSignRequest struct {
	// BlockHeight The block height for the signature (quoted decimal u64)
	BlockHeight string `json:"block_height"`

	// ChainId The chain id for the signature
	ChainId string `json:"chain_id"`

	// Message The message to sign
	Message string `json:"message"`

	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata interface{} `json:"metadata"`
}

// Epoch Epoch is a quoted `uint64`.
type Epoch = string

// EpochDateTime DateTime measured in seconds since unix epoch.
// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
type EpochDateTime = int64

// ErrorObj defines model for ErrorObj.
type ErrorObj struct {
	// Code Code
	Code int32 `json:"code"`

	// Data Optional data
	Data interface{} `json:"data"`

	// Message Message
	Message string `json:"message"`
}

// ErrorResponse The structure of ErrorResponse must match the response template that AWS uses
type ErrorResponse struct {
	Accepted  *AcceptedValue  `json:"accepted"`
	ErrorCode SignerErrorCode `json:"error_code"`

	// Message Error message
	Message string `json:"message"`

	// RequestId Optional request identifier
	RequestId *string `json:"request_id,omitempty"`
}

// EsploraRequest Esplora request
type EsploraRequest struct {
	// Body HTTP body
	Body *string `json:"body"`

	// Method HTTP method
	Method  string                `json:"method"`
	Network EsploraRequestNetwork `json:"network"`

	// Path HTTP relative path (which comes after '/{network}/api/')
	Path string `json:"path"`
}

// EsploraRequestNetwork defines model for EsploraRequest.Network.
type EsploraRequestNetwork string

// EsploraResponse defines model for EsploraResponse.
type EsploraResponse = interface{}

// Eth1SignRequest defines model for Eth1SignRequest.
type Eth1SignRequest struct {
	// ChainId The chain id to set in the given transaction.
	ChainId int64 `json:"chain_id"`

	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata interface{} `json:"metadata"`

	// Tx EIP-2718 typed transaction, including EIP-1559 transactions (`{ "type": "0x02" ... }`), and legacy transactions (`{ "type": "0x00" ... }`). All values in the transaction are expected to be (0x-prefixed or not) hex strings or byte arrays.
	Tx Transaction `json:"tx"`
}

// Eth1SignResponse defines model for Eth1SignResponse.
type Eth1SignResponse struct {
	// RlpSignedTx Hex-encoded RLP encoding of the transaction and its signature
	RlpSignedTx string `json:"rlp_signed_tx"`
}

// Eth2SignRequest defines model for Eth2SignRequest.
type Eth2SignRequest struct {
	// Eth2SignRequest Subset of the Web3Signer Eth2 BLS signing request whose schema is defined
	// [here](https://consensys.github.io/web3signer/web3signer-eth2.html#tag/Signing/operation/ETH2_SIGN).
	// We handle deposits and voluntary exits separately.
	Eth2SignRequest map[string]interface{} `json:"eth2_sign_request"`

	// Network Network name ('mainnet', 'holesky')
	Network Network `json:"network"`
}

// Eth2SignResponse defines model for Eth2SignResponse.
type Eth2SignResponse struct {
	// Signature Hex encoded signature prefixed with 0x e.g. "0x0000..."
	Signature string `json:"signature"`
}

// EvmChain Supported EVM chains.
type EvmChain string

// EvmOptions EVM addresses. You may set a global address for every EVM chain,
// or a set of addresses for specific chains.
type EvmOptions struct {
	union json.RawMessage
}

// EvmOptionsObject EVM addresses associated with specific chains. The keys are
// `EvmChain`s and the values are addresses.
type EvmOptionsObject map[string]string

// EvmOptionsString An EVM address that is permitted for use on any EVM chain.
type EvmOptionsString = string

// EvmTxCmp defines model for EvmTxCmp.
type EvmTxCmp struct {
	// Grace To prevent replay attacks, any given MFA receipt is normally allowed to be used only once.
	//
	// In this case, however, because EVM transactions already have a replay prevention mechanism
	// (namely the 'nonce' property), we allow the user to specify a grace period (in seconds) to
	// indicate how long an MFA receipt should remain valid after its first use.
	//
	// Note that we allow both 'grace' and 'ignore_nonce' to be set because once an MFA request
	// enters its grace period we unconditionally set its 'ignore_nonce' property to 'false' to
	// ensure that any subsequent requests that claim the same receipt must sign for the same
	// nonce as the request we signed originally with that receipt.
	//
	// Also note that the grace period cannot extend the lifetime of an MFA request beyond its
	// original expiration date.
	//
	// The grace period must not be greater than 30 days.
	Grace *int64 `json:"grace"`

	// IgnoreGas Whether the 'gas' property of the EVM transaction is allowed to be different.
	IgnoreGas *bool `json:"ignore_gas,omitempty"`

	// IgnoreNonce Whether the 'nonce' property of the EVM transaction is allowed to be different.
	IgnoreNonce *bool `json:"ignore_nonce,omitempty"`
}

// EvmTxDepositErrorCode defines model for EvmTxDepositErrorCode.
type EvmTxDepositErrorCode string

// ExecutionSource The source of a policy execution, i.e. the reason it was executed.
type ExecutionSource string

// ExplicitScopes Explicitly named scopes for accessing CubeSigner APIs
type ExplicitScopes string

// FeeType This type specifies the interpretation of the `fee` field in Babylon
// staking requests. If `sats`, the field is intpreted as a fixed value
// in sats. If `sats_pr_vb`, the field is interpreted as a rate and the
// fee is computed by estimating the weight of the output transaction.
type FeeType string

// FidoAssertAnswer Sent from the client to the server to answer a fido challenge
type FidoAssertAnswer struct {
	// ChallengeId The ID of the challenge that was returned from the POST endpoint
	ChallengeId string `json:"challenge_id"`

	// Credential This type represents a wire-encodable form of the PublicKeyCredential interface
	// Clients may need to manually encode into this format to communicate with the server
	//
	// The PublicKeyCredential interface inherits from Credential
	// [CREDENTIAL-MANAGEMENT-1], and contains the attributes that are returned to
	// the caller when a new credential is created, or a new assertion is
	// requested.
	//
	// https://www.w3.org/TR/webauthn-2/#iface-pkcredential
	Credential PublicKeyCredential `json:"credential"`
}

// FidoAssertChallenge defines model for FidoAssertChallenge.
type FidoAssertChallenge struct {
	// ChallengeId The id of the challenge. Must be supplied when answering the challenge.
	ChallengeId string `json:"challenge_id"`

	// Options The `PublicKeyCredentialRequestOptions` dictionary supplies get() with the
	// data it needs to generate an assertion. Its challenge member MUST be
	// present, while its other members are OPTIONAL.
	//
	// This struct is also used as part of the verification procedure for assertions
	Options PublicKeyCredentialRequestOptions `json:"options"`

	// Preimage A base64url encoding of UTF8 JSON. The data in that JSON is endpoint specific, and describes what this FIDO challenge will be used for.
	//
	// Clients can use `preimage` along with `random_seed` to reconstruct the challenge like so:
	//
	// `challenge = HMAC-SHA256(key=random_seed, message=preimage)`
	Preimage string `json:"preimage"`

	// RandomSeed A random seed that prevents replay attacks
	RandomSeed string `json:"random_seed"`
}

// FidoCreateChallengeAnswer Sent from the client to the server to answer a fido challenge
type FidoCreateChallengeAnswer struct {
	// ChallengeId The ID of the challenge that was returned from the POST endpoint
	ChallengeId string `json:"challenge_id"`

	// Credential This type represents a wire-encodable form of the PublicKeyCredential interface
	// Clients may need to manually encode into this format to communicate with the server
	//
	// The PublicKeyCredential interface inherits from Credential
	// [CREDENTIAL-MANAGEMENT-1], and contains the attributes that are returned to
	// the caller when a new credential is created, or a new assertion is
	// requested.
	//
	// https://www.w3.org/TR/webauthn-2/#iface-pkcredential
	Credential PublicKeyCredential `json:"credential"`
}

// FidoCreateChallengeResponse defines model for FidoCreateChallengeResponse.
type FidoCreateChallengeResponse struct {
	// ChallengeId The id of the challenge. Must be supplied when answering the challenge.
	ChallengeId string `json:"challenge_id"`

	// Options Defines the parameters for the creation of a new public key credential
	//
	// https://www.w3.org/TR/webauthn-2/#dictdef-publickeycredentialcreationoptions
	Options PublicKeyCredentialCreationOptions `json:"options"`

	// Preimage A base64url encoding of UTF8 JSON. The data in that JSON is endpoint specific, and describes what this FIDO challenge will be used for.
	//
	// Clients can use `preimage` along with `random_seed` to reconstruct the challenge like so:
	//
	// `challenge = HMAC-SHA256(key=random_seed, message=preimage)`
	Preimage string `json:"preimage"`

	// RandomSeed A random seed that prevents replay attacks
	RandomSeed string `json:"random_seed"`
}

// FidoCreateRequest Declares intent to register a new FIDO key
type FidoCreateRequest struct {
	// Discoverable Whether this key can be used for passwordless login
	Discoverable *bool `json:"discoverable,omitempty"`

	// Name A human-readable name for the new fido credential
	Name string `json:"name"`

	// RequestDeviceIdentifier Whether to request the unique authenticator device manufacturer identifier.
	// This information can be used to render the manufacturer name (e.g., "YubiKey",
	// or "Google Password Manager", or "1Password", etc.). When requested, some user
	// agents (e.g., Firefox) will ask the user to agree or disagree, whereas some
	// (e.g., Chrome) will silently agree.
	RequestDeviceIdentifier *bool `json:"request_device_identifier,omitempty"`
}

// ForbiddenErrorCode defines model for ForbiddenErrorCode.
type ForbiddenErrorCode string

// Fork Specifies a fork of the `BeaconChain`, to prevent replay attacks.
// The schema of `Fork` is defined in the [Beacon chain
// spec](https://github.com/ethereum/consensus-specs/blob/v1.0.1/specs/phase0/beacon-chain.md#fork).
type Fork struct {
	// CurrentVersion Current fork version.
	CurrentVersion string `json:"current_version"`

	// Epoch Epoch is a quoted `uint64`.
	Epoch Epoch `json:"epoch"`

	// PreviousVersion Previous fork version.
	PreviousVersion string `json:"previous_version"`
}

// GenesisData Genesis data as defined in the [Beacon API
// spec](https://ethereum.github.io/beacon-APIs/#/Beacon/getGenesis).
// You can get the genesis data from the Beacon node's `/eth/v1/beacon/genesis` end-point.
// This struct definition is originally from lighthouse's eth2.
type GenesisData struct {
	// GenesisForkVersion Genesis fork version.
	GenesisForkVersion string `json:"genesis_fork_version"`

	// GenesisTime Genesis time
	GenesisTime string `json:"genesis_time"`

	// GenesisValidatorsRoot Genesis validators root.
	GenesisValidatorsRoot string `json:"genesis_validators_root"`
}

// GetKeysInOrgRequest defines model for GetKeysInOrgRequest.
type GetKeysInOrgRequest struct {
	KeyType *KeyType `json:"key_type"`
}

// GetUserByEmailResponse defines model for GetUserByEmailResponse.
type GetUserByEmailResponse struct {
	// Users Typically, this array is either empty (if no user with a given email was found)
	// or contains a single element, i.e., the user with a given email.
	Users []UserInOrgInfoWithIdentity `json:"users"`
}

// GetUserByOidcResponse defines model for GetUserByOidcResponse.
type GetUserByOidcResponse struct {
	User *UserInOrgInfoWithIdentity `json:"user"`
}

// HeartbeatRequest Stats pertaining the the sender `cube3signer` instance
type HeartbeatRequest struct {
	// CurrentNumRequestsActive Number of requests currently active (received but not necessarily being processed yet)
	CurrentNumRequestsActive int64 `json:"current_num_requests_active"`

	// CurrentNumRequestsProcessing Number of requests currently being processed by cube3signer
	CurrentNumRequestsProcessing int64 `json:"current_num_requests_processing"`

	// Ignore Do not record metric data from this heartbeat
	Ignore *bool `json:"ignore,omitempty"`

	// NumRequests Number of new requests during this heartbeat period
	NumRequests int64 `json:"num_requests"`

	// NumRequestsFailed Number of requests that failed during this heartbeat period
	NumRequestsFailed int64 `json:"num_requests_failed"`

	// NumRequestsRetried Number of requests were retried during this heartbeat period
	NumRequestsRetried int64 `json:"num_requests_retried"`

	// NumRetries Number of retries during this heartbeat period
	NumRetries int64 `json:"num_retries"`

	// NumTokenRefreshes Number of times auth token was refreshed during this heartbeat period
	NumTokenRefreshes *int64 `json:"num_token_refreshes,omitempty"`

	// NumTokenRefreshesFailed Number of times auth token refresh failed during this heartbeat period
	NumTokenRefreshesFailed *int64 `json:"num_token_refreshes_failed,omitempty"`

	// ProxyVersion Version of the proxy sending the heart beat request
	//
	// TODO: Make non-optional once we do not support proxies without version information
	ProxyVersion *string `json:"proxy_version"`
}

// HistoricalDataConfiguration Configuration governing whether and how to save historical data.
type HistoricalDataConfiguration struct {
	// Tx Configuration governing whether and how to save historical transactions.
	Tx HistoricalTxConfiguration `json:"tx"`
}

// HistoricalTx A recently signed transaction that we store in the DB.
type HistoricalTx struct {
	// Date DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	Date EpochDateTime `json:"date"`

	// ExpEpoch DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	ExpEpoch          EpochDateTime `json:"exp_epoch"`
	HistoricalTxOrgId Id            `json:"historical_tx_org_id"`
	KeyId             Id            `json:"key_id"`
	MfaStatus         *Status       `json:"mfa_status"`

	// Operation All different kinds of sensitive operations
	Operation OperationKind `json:"operation"`

	// Request Information about the request.
	//
	// Captures all the relevant info (including the request body) about requests that require MFA.
	// We use this to verify that when a request is resumed (after obtaining necessary MFA approvals)
	// it is exactly the same as it originally was.
	Request HttpRequest `json:"request"`

	// RequestId Original request id
	RequestId *string `json:"request_id"`

	// Result Operation-specific result
	Result interface{} `json:"result"`
	RoleId *Id         `json:"role_id"`
	UserId *Id         `json:"user_id"`
}

// HistoricalTxConfiguration Configuration governing whether and how to save historical transactions.
type HistoricalTxConfiguration struct {
	Lifetime *Seconds `json:"lifetime"`
}

// HttpRequest Information about the request.
//
// Captures all the relevant info (including the request body) about requests that require MFA.
// We use this to verify that when a request is resumed (after obtaining necessary MFA approvals)
// it is exactly the same as it originally was.
type HttpRequest struct {
	// Body HTTP request body
	Body *map[string]interface{} `json:"body"`

	// Method HTTP method of the request
	Method string `json:"method"`

	// Path HTTP path of the request, excluding the host
	Path string `json:"path"`
}

// HttpRequestCmp How to compare HTTP requests when verifying MFA receipt (see [MfaRequest::verify_request])
type HttpRequestCmp struct {
	union json.RawMessage
}

// HttpRequestCmpEq The requests must match exactly. Any given MFA receipt can be used at most once.
type HttpRequestCmpEq string

// HttpRequestCmpEvmTx defines model for HttpRequestCmpEvmTx.
type HttpRequestCmpEvmTx struct {
	EvmTx EvmTxCmp `json:"EvmTx"`
}

// HttpRequestCmpSolanaTx defines model for HttpRequestCmpSolanaTx.
type HttpRequestCmpSolanaTx struct {
	SolanaTx SolanaTxCmp `json:"SolanaTx"`
}

// Id defines model for Id.
type Id = string

// IdentityInfo defines model for IdentityInfo.
type IdentityInfo struct {
	// Email The email associated with the user
	Email *string `json:"email"`

	// Iss The root-level issuer who administrates this user. From the OIDC spec:
	// Issuer Identifier for the Issuer of the response. The iss
	// value is a case sensitive URL using the https scheme that contains
	// scheme, host, and optionally, port number and path components and
	// no query or fragment components.
	Iss string `json:"iss"`

	// PreferredUsername The user name (if any) associated with the user
	PreferredUsername *string `json:"preferred_username"`

	// Sub From the OIDC spec:
	//
	// A locally unique and never reassigned identifier within the Issuer for
	// the End-User, which is intended to be consumed by the Client, e.g.,
	// 24400320 or AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4. It MUST NOT exceed
	// 255 ASCII characters in length. The sub value is a case sensitive
	// string.
	Sub string `json:"sub"`
}

// IdentityProof defines model for IdentityProof.
type IdentityProof struct {
	Aud *Aud `json:"aud"`

	// Email The email associated with the user
	Email *string `json:"email"`

	// ExpEpoch DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	ExpEpoch EpochDateTime `json:"exp_epoch"`

	// Id An opaque identifier for the proof
	Id       string        `json:"id"`
	Identity *OidcIdentity `json:"identity"`

	// PreferredUsername The username (if any) associated with the user
	PreferredUsername *string             `json:"preferred_username"`
	UserInfo          *CubeSignerUserInfo `json:"user_info"`
}

// IdpConfig IDP configuration
type IdpConfig struct {
	Throttle *ThrottleConfig `json:"throttle"`

	// Users Enable for certain user roles
	Users *[]MemberRole `json:"users"`
}

// ImportKeyRequest defines model for ImportKeyRequest.
type ImportKeyRequest struct {
	// DkEnc Base64-encoded, encrypted data key.
	DkEnc      string      `json:"dk_enc"`
	EditPolicy *EditPolicy `json:"edit_policy"`

	// Expires Expiration timestamp expressed as seconds since the UNIX epoch.
	Expires int64 `json:"expires"`

	// Idempotent When false (the default), nothing is returned when an imported key already
	// exists. When true, returns the KeyInfo struct for keys that already exist
	// if caller is allowed to list that key.
	Idempotent *bool `json:"idempotent,omitempty"`

	// KeyMaterial A set of encrypted keys to be imported
	KeyMaterial []ImportKeyRequestMaterial `json:"key_material"`
	KeyType     KeyType                    `json:"key_type"`

	// Metadata Set this key's metadata. If this value is `null`, the metadata is erased. If the field is
	// missing, the metadata remains unchanged.
	Metadata interface{} `json:"metadata,omitempty"`

	// Owner Specify a user other than themselves to be the (potentially new) owner of the key.
	// The specified owner must be an existing user who is a member of the same org.
	Owner *string `json:"owner"`

	// Policy Set this key's policies. For an existing key, this overwrites all its policies.
	Policy *[]interface{} `json:"policy"`

	// PublicKey The ephemeral public key to which an imported key should be encrypted.
	// This is a P384 public key in base64-encoded uncompressed SECG format.
	PublicKey string `json:"public_key"`

	// SkEnc Base64-encoded, encrypted secret key.
	SkEnc string `json:"sk_enc"`
}

// ImportKeyRequestMaterial defines model for ImportKeyRequestMaterial.
type ImportKeyRequestMaterial struct {
	// ClientPublicKey The client's ephemeral public key used to derive a shared key.
	// This is a base64-encoded, SEC1-encoded P384 public key.
	ClientPublicKey string `json:"client_public_key"`

	// IkmEnc The encrypted keying material to be imported.
	// This is a base64-encoded ciphertext.
	IkmEnc string `json:"ikm_enc"`

	// Salt A salt value used to derive a shared key.
	// This is a base64-encoded byte string.
	Salt string `json:"salt"`
}

// ImportableSecrets Helper type for enforcing validation before having access to the configs and import key.
type ImportableSecrets struct {
	ImportKey *KeyImportKey `json:"import_key"`

	// Secrets The policy secrets.
	Secrets *map[string]SecretValue `json:"secrets"`
}

// InternalErrorCode defines model for InternalErrorCode.
type InternalErrorCode string

// InvitationAcceptRequest defines model for InvitationAcceptRequest.
type InvitationAcceptRequest struct {
	// Auth At redemption time, the user must provide a credential they wish to use to authenticate.
	// This enum represents the two possible sources of authentication.
	Auth AuthSource `json:"auth"`

	// Token Invitation token
	Token string `json:"token"`
}

// InviteKind Indicates the auth sources allowed to an invited user
type InviteKind string

// InviteRequest defines model for InviteRequest.
type InviteRequest struct {
	// Email The user's email address
	Email      string      `json:"email"`
	InviteKind *InviteKind `json:"invite_kind"`

	// MfaPolicy Optional login MFA policy
	MfaPolicy *map[string]interface{} `json:"mfa_policy"`

	// Name The user's full name
	Name string      `json:"name"`
	Role *MemberRole `json:"role"`

	// SkipEmail Skip sending an invitation email to this user if true.
	//
	// NOTE: this field is for internal testing use ONLY. If you do not
	// send an invitation email (and the invite kind is not SSO), the user will never be able to log in.
	SkipEmail *bool `json:"skip_email,omitempty"`
}

// InvokePolicyRequest A request containing the data that a Wasm policy should be invoked with.
type InvokePolicyRequest struct {
	// KeyId The Key ID that should be sent to the policy.
	KeyId string `json:"key_id"`

	// Request The "request body" that should be sent to the policy.
	Request interface{} `json:"request"`

	// RoleId An optional Role ID. If `None`, the policy will be invoked from the current user session.
	RoleId *string `json:"role_id"`
}

// InvokePolicyResponse The result of invoking a Wasm policy.
type InvokePolicyResponse struct {
	// Response The response from invoking a Wasm policy.
	Response WasmPolicyResponse `json:"response"`

	// Stderr The bytes written to `stderr`, encoded as a hex-string.
	// In most cases, these bytes correspond to a UTF-8-encoded `String`.
	Stderr string `json:"stderr"`

	// Stdout The bytes written to `stdout`, encoded as a hex-string.
	// In most cases, these bytes correspond to a UTF-8-encoded `String`.
	Stdout string `json:"stdout"`
}

// JrpcResponse defines model for JrpcResponse.
type JrpcResponse struct {
	Error *ErrorObj `json:"error"`

	// Id ID from the corresponding request
	Id interface{} `json:"id"`

	// Jsonrpc Constant "2.0"
	Jsonrpc string `json:"jsonrpc"`

	// Result Result, if success
	Result *map[string]interface{} `json:"result"`
}

// JsonKeyPackage defines model for JsonKeyPackage.
type JsonKeyPackage struct {
	// KeyType The type of key this package represents
	KeyType string `json:"key_type"`
	union   json.RawMessage
}

// JsonKeyPackageEnglishMnemonic A key derived from a mnemonic
type JsonKeyPackageEnglishMnemonic struct {
	// DerivationPath The derivation path
	DerivationPath string                                    `json:"derivation_path"`
	MaterialType   JsonKeyPackageEnglishMnemonicMaterialType `json:"material_type"`

	// Mnemonic The mnemonic
	Mnemonic string `json:"mnemonic"`

	// Password The password (which may be empty)
	Password string `json:"password"`
}

// JsonKeyPackageEnglishMnemonicMaterialType defines model for JsonKeyPackageEnglishMnemonic.MaterialType.
type JsonKeyPackageEnglishMnemonicMaterialType string

// JsonKeyPackageRawSecret A raw key
type JsonKeyPackageRawSecret struct {
	MaterialType JsonKeyPackageRawSecretMaterialType `json:"material_type"`

	// Secret The value of the raw secret
	Secret string `json:"secret"`
}

// JsonKeyPackageRawSecretMaterialType defines model for JsonKeyPackageRawSecret.MaterialType.
type JsonKeyPackageRawSecretMaterialType string

// JwkSetResponse defines model for JwkSetResponse.
type JwkSetResponse = map[string]interface{}

// KeyCountDimensions defines model for KeyCountDimensions.
type KeyCountDimensions struct {
	// KeyType The key type
	KeyType string `json:"key_type"`

	// OrgId All metrics must include 'org_id' as a dimension.
	OrgId string `json:"org_id"`
}

// KeyDerivationInfo Derivation-related metadata for keys derived from a long-lived mnemonic
type KeyDerivationInfo struct {
	// DerivationPath The derivation path used to derive this key
	DerivationPath string `json:"derivation_path"`

	// MnemonicId The mnemonic-id of the key's parent mnemonic
	MnemonicId string `json:"mnemonic_id"`
}

// KeyImportKey A wrapped key-import key
type KeyImportKey struct {
	// DkEnc Base64-encoded, encrypted data key.
	DkEnc string `json:"dk_enc"`

	// Expires Expiration timestamp expressed as seconds since the UNIX epoch.
	Expires int64 `json:"expires"`

	// PublicKey The ephemeral public key to which an imported key should be encrypted.
	// This is a P384 public key in base64-encoded uncompressed SECG format.
	PublicKey string `json:"public_key"`

	// SkEnc Base64-encoded, encrypted secret key.
	SkEnc string `json:"sk_enc"`
}

// KeyInRoleInfo defines model for KeyInRoleInfo.
type KeyInRoleInfo struct {
	// KeyId Key ID
	KeyId   string   `json:"key_id"`
	KeyInfo *KeyInfo `json:"key_info"`

	// Policy Policies that are checked before this key is used on behalf of this role
	Policy *[]map[string]interface{} `json:"policy,omitempty"`

	// RoleId Role ID
	RoleId string `json:"role_id"`
}

// KeyInfo defines model for KeyInfo.
type KeyInfo struct {
	Created        *EpochDateTime     `json:"created"`
	DerivationInfo *KeyDerivationInfo `json:"derivation_info"`

	// EditPolicy A policy which governs when and who is allowed to update the entity this policy is
	// attached to (e.g., a role or a key).
	//
	// When attached to a role, by default, this policy applies to role deletion and all
	// role updates (including adding/removing keys and users); in terms of scopes,
	// it applies to `manage:role:update:*` and `manage:role:delete`.
	//
	// When attached to a key, by default, this policy applies to key deletion, all
	// key updates, and adding/removing that key to/from a role; in terms of scopes,
	// it applies to `manage:key:update:*`, `manage:key:delete`, `manage:role:update:key:*`.
	//
	// This default can be changed by setting the `applies_to_scopes` property.
	EditPolicy *EditPolicy `json:"edit_policy,omitempty"`

	// Enabled Whether the key is enabled (only enabled keys may be used for signing)
	Enabled bool `json:"enabled"`

	// KeyId The id of the key: "Key#" followed by a unique identifier specific to
	// the type of key (such as a public key for BLS or an ethereum address for Secp)
	KeyId        string         `json:"key_id"`
	KeyType      KeyType        `json:"key_type"`
	LastModified *EpochDateTime `json:"last_modified"`

	// MaterialId A unique identifier specific to the type of key, such as a public key or an ethereum address
	MaterialId string `json:"material_id"`

	// Metadata User-defined metadata. When rendering (e.g., in the browser) you should treat
	// it as untrusted user data (and avoid injecting metadata into HTML directly) if
	// untrusted users can create/update keys (or their metadata).
	Metadata interface{} `json:"metadata,omitempty"`

	// Owner Owner of the key
	Owner string `json:"owner"`

	// Policy Key policy
	Policy []interface{} `json:"policy"`

	// PublicKey Hex-encoded, serialized public key. The format used depends on the key type:
	// - Secp256k1 keys use 65-byte uncompressed SECG format;
	// - Stark keys use 33-byte compressed SECG format;
	// - BLS keys use 48-byte compressed BLS12-381 (ZCash) format;
	// - Ed25519 keys use the canonical 32-byte encoding specified in RFC 8032.
	PublicKey string `json:"public_key"`

	// Purpose The purpose for which the key can be used (e.g., chain id for which the key is allowed to sign messages)
	Purpose string `json:"purpose"`

	// Region The region affinity for this key
	Region *string `json:"region,omitempty"`

	// Version Version of this object
	Version *int64 `json:"version,omitempty"`
}

// KeyInfos defines model for KeyInfos.
type KeyInfos struct {
	Keys []KeyInfo `json:"keys"`
}

// KeyType defines model for KeyType.
type KeyType string

// KeyTypeAndDerivationPath defines model for KeyTypeAndDerivationPath.
type KeyTypeAndDerivationPath struct {
	// DerivationPath List of derivation paths for which to derive.
	DerivationPath string  `json:"derivation_path"`
	KeyType        KeyType `json:"key_type"`

	// Policy Policies to apply to this key. It is an error to specify a policy
	// that is not compatible with `key_type`.
	Policy *[]interface{} `json:"policy"`
}

// LastEvalKey Wrapper around encrypted [UnencryptedLastEvalKey] bytes.
//
// We serialize this into a base64url-encoded string and return to the user
// so that they can pass this back to us as a url query parameter.
type LastEvalKey = string

// ListIdentitiesResponse Third-party identities associated with the user's account
type ListIdentitiesResponse struct {
	Identities []IdentityInfo `json:"identities"`
}

// ListMfaResponse defines model for ListMfaResponse.
type ListMfaResponse struct {
	// MfaRequests All pending MFA requests
	MfaRequests []MfaRequestInfo `json:"mfa_requests"`
}

// ListPendingMessagesResponse All pending MMI requests created by the current user.
type ListPendingMessagesResponse struct {
	// PendingMessages All pending messages for a user.
	PendingMessages []PendingMessageInfo `json:"pending_messages"`
}

// LoginRequest OIDC login request
type LoginRequest = OidcLoginRequest

// MemberRole Describes whether a user in an org is an Owner or just a regular member
type MemberRole string

// MembershipStatus defines model for MembershipStatus.
type MembershipStatus string

// MetricName The name of the metric to compute
type MetricName struct {
	union json.RawMessage
}

// MfaPolicy defines model for MfaPolicy.
type MfaPolicy struct {
	// AllowedApprovers Users who are allowed to approve. If empty at creation time, default to the current user.
	AllowedApprovers *[]string `json:"allowed_approvers,omitempty"`

	// AllowedMfaTypes Allowed approval types. When omitted, defaults to any.
	AllowedMfaTypes *[]MfaType `json:"allowed_mfa_types"`

	// Count How many users to require to approve (defaults to 1).
	Count *int32 `json:"count,omitempty"`

	// Lifetime Duration measured in seconds
	// A wrapper type for serialization that encodes a `Duration` as a `u64` representing the number of seconds.
	Lifetime *Seconds `json:"lifetime,omitempty"`

	// NumAuthFactors How many auth factors to require per user (defaults to 1).
	NumAuthFactors *int32 `json:"num_auth_factors,omitempty"`

	// RequestComparer How to compare HTTP requests when verifying MFA receipt (see [MfaRequest::verify_request])
	RequestComparer *HttpRequestCmp `json:"request_comparer,omitempty"`

	// RestrictedOperations CubeSigner operations to which this policy should apply.
	// When omitted, applies to all operations.
	RestrictedOperations *[]OperationKind `json:"restricted_operations"`

	// TimeDelay Duration measured in seconds
	// A wrapper type for serialization that encodes a `Duration` as a `u64` representing the number of seconds.
	TimeDelay *Seconds `json:"time_delay,omitempty"`
}

// MfaProtectedAction MFA-protected actions whose MFA requirements are configurable by org owners.
//
// Specifying the 'CubeSigner' MFA type is never allowed for any of these actions.
type MfaProtectedAction string

// MfaRequestInfo Returned as a response from multiple routes (e.g., 'get mfa', 'approve mfa', 'approve totp').
type MfaRequestInfo struct {
	// CreatedAt DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	CreatedAt *EpochDateTime `json:"created_at,omitempty"`

	// CreatedBy The session identity (user or role) that created this request.
	CreatedBy string `json:"created_by"`

	// ExpiresAt DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	ExpiresAt EpochDateTime `json:"expires_at"`

	// Id Approval request ID.
	Id string `json:"id"`

	// NotValidUntil DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	NotValidUntil *EpochDateTime `json:"not_valid_until,omitempty"`

	// Provenance MFA policy provenance
	Provenance MfaRequestInfoProvenance `json:"provenance"`
	Receipt    *Receipt                 `json:"receipt"`

	// Region The region this MFA request was created in. It can only be redeemed from the same region.
	Region *string `json:"region,omitempty"`

	// RelatedIds If set, contains the IDs of all MFA requests (including this one!) that
	// were generated at once for the same CubeSigner operation.
	//
	// If not set, it means that this was the lone MFA request generated for `request`.
	//
	// This is useful so that a client can discover all the MFAs whose receipts must
	// be submitted together to carry out the original CubeSigner operation.
	RelatedIds *[]string `json:"related_ids,omitempty"`

	// Request Information about the request.
	//
	// Captures all the relevant info (including the request body) about requests that require MFA.
	// We use this to verify that when a request is resumed (after obtaining necessary MFA approvals)
	// it is exactly the same as it originally was.
	Request HttpRequest `json:"request"`
	Status  Status      `json:"status"`
}

// MfaRequestInfoProvenance MFA policy provenance
type MfaRequestInfoProvenance string

// MfaRequirements Org-wide MFA requirements.
type MfaRequirements struct {
	// AlienLoginRequirement Represents the number of MFA approvals required for a given operation
	// (e.g. login). Can be used to produce a concrete policy for a given user
	AlienLoginRequirement *SecondFactorRequirement `json:"alien_login_requirement,omitempty"`

	// AllowedMfaTypes MFA types that are allowed to be used for individual implicitly security-sensitive
	// operations (like logging in, adding an MFA factor, exporting keys, etc; see `MfaProtectedAction`).
	AllowedMfaTypes *AllowedMfaMap `json:"allowed_mfa_types,omitempty"`

	// MemberLoginRequirement Represents the number of MFA approvals required for a given operation
	// (e.g. login). Can be used to produce a concrete policy for a given user
	MemberLoginRequirement *SecondFactorRequirement `json:"member_login_requirement,omitempty"`
}

// MfaResetRequest defines model for MfaResetRequest.
type MfaResetRequest struct {
	// UserId The id of the user you want to reset MFA for
	UserId string `json:"user_id"`
}

// MfaType Different types that can be used to approve an MFA request
type MfaType = string

// MfaVote defines model for MfaVote.
type MfaVote string

// MigrateIdentityItem defines model for MigrateIdentityItem.
type MigrateIdentityItem struct {
	// Iss The root-level issuer who administrates this user. From the OIDC spec:
	// Issuer Identifier for the Issuer of the response. The iss
	// value is a case sensitive URL using the https scheme that contains
	// scheme, host, and optionally, port number and path components and
	// no query or fragment components.
	Iss string `json:"iss"`

	// Sub From the OIDC spec:
	//
	// A locally unique and never reassigned identifier within the Issuer for
	// the End-User, which is intended to be consumed by the Client, e.g.,
	// 24400320 or AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4. It MUST NOT exceed
	// 255 ASCII characters in length. The sub value is a case sensitive
	// string.
	Sub string `json:"sub"`

	// UserId The id of the user you want to operate on
	UserId string `json:"user_id"`
}

// MigrateIdentityRequest A request to add or remove an OIDC identities for an existing user
type MigrateIdentityRequest = []MigrateIdentityItem

// MigrateUpdateUserItem A request to update an existing user.
type MigrateUpdateUserItem struct {
	// UserId The id of the user you want to operate on
	UserId string `json:"user_id"`

	// VerifiedEmail Override user's verified email in this org. Use an empty string to indicate that this user's
	// verified email should be cleared (and fallback to their display email).
	VerifiedEmail *string `json:"verified_email"`
}

// MigrateUpdateUsersRequest defines model for MigrateUpdateUsersRequest.
type MigrateUpdateUsersRequest = []MigrateUpdateUserItem

// MmiMetadata defines model for MmiMetadata.
type MmiMetadata struct {
	// Accounts All accounts the user can access.
	// Only set when requested explicitly, i.e., via 'customer_listAccountsSigned'.
	Accounts *[]struct {
		// Address An Ethereum address, hex-encoded, with leading '0x'
		Address string `json:"address"`

		// Metadata Account metadata
		Metadata interface{} `json:"metadata,omitempty"`

		// Name Account name
		Name string `json:"name"`

		// Tags Ordered list of name-value pairs
		Tags *[]struct {
			// Name Tag name
			Name string `json:"name"`

			// Value Tag value
			Value string `json:"value"`
		} `json:"tags,omitempty"`
	} `json:"accounts"`

	// ChainId Chain ID (not required when signing a personal message (EIP-191))
	ChainId *string `json:"chainId"`

	// CustodianPublishesTransaction If the custodian should publish the transaction
	CustodianPublishesTransaction *bool `json:"custodianPublishesTransaction"`

	// CustomerId The customer ID of the user, i.e., the customer's organization ID.
	CustomerId *string `json:"customerId"`

	// CustomerName A human readable name of the corresponding organization, if any.
	CustomerName *string `json:"customerName"`

	// Note A note to be attached to the transaction which can be specified by the user
	Note *string `json:"note"`

	// OriginUrl The web page/dapp where the transaction originated
	OriginUrl *string `json:"originUrl"`

	// RpcUrl User's preferred RPC URL, and it should be the same as the RPC URL for the network corresponding to the Chain ID
	RpcUrl *string `json:"rpcUrl"`

	// TransactionCategory The category of transaction, as best can be determined by the wallet
	TransactionCategory *string `json:"transactionCategory"`

	// UserId This must match the `sub` claim of the customer proof of
	// the user or role session which created the transaction.
	UserId *string `json:"userId"`
}

// MmiMetadataExt defines model for MmiMetadataExt.
type MmiMetadataExt struct {
	// Accounts All accounts the user can access.
	// Only set when requested explicitly, i.e., via 'customer_listAccountsSigned'.
	Accounts *[]struct {
		// Address An Ethereum address, hex-encoded, with leading '0x'
		Address string `json:"address"`

		// Metadata Account metadata
		Metadata interface{} `json:"metadata,omitempty"`

		// Name Account name
		Name string `json:"name"`

		// Tags Ordered list of name-value pairs
		Tags *[]struct {
			// Name Tag name
			Name string `json:"name"`

			// Value Tag value
			Value string `json:"value"`
		} `json:"tags,omitempty"`
	} `json:"accounts"`

	// CustomerId The customer ID of the user, i.e., the customer's organization ID.
	CustomerId *string `json:"customerId"`

	// CustomerName A human readable name of the corresponding organization, if any.
	CustomerName *string `json:"customerName"`

	// UserId This must match the `sub` claim of the customer proof of
	// the user or role session which created the transaction.
	UserId *string `json:"userId"`
}

// MmiRejectRequest defines model for MmiRejectRequest.
type MmiRejectRequest struct {
	// Reason Optional reason for rejecting.
	Reason *string `json:"reason"`
}

// MmiStatus defines model for MmiStatus.
type MmiStatus struct {
	// DisplayText Short text to display to the user
	DisplayText string `json:"displayText"`

	// Finished Whether the signed message has finished, e.g. it is completed, failed or cancelled
	Finished bool `json:"finished"`

	// Reason The reason for the signed message status
	Reason *string `json:"reason"`

	// Signed Whether the message was signed
	Signed bool `json:"signed"`

	// Submitted Whether the transaction was submitted to the blockchain
	Submitted *bool `json:"submitted,omitempty"`

	// Success Whether the transaction was successful, i.e. it was included in a block and not reverted
	Success bool `json:"success"`
}

// MsgSignature Information about a signed message
type MsgSignature struct {
	// Signature The signature
	Signature string `json:"signature"`
}

// MsgStatus A struct representing the pending message status
type MsgStatus struct {
	union json.RawMessage
}

// MsgStatusPending defines model for MsgStatusPending.
type MsgStatusPending struct {
	Status MsgStatusPendingStatus `json:"status"`
}

// MsgStatusPendingStatus defines model for MsgStatusPending.Status.
type MsgStatusPendingStatus string

// MsgStatusRejected The message has been rejected, including the reason for the rejection.
type MsgStatusRejected struct {
	Reason string                  `json:"reason"`
	Status MsgStatusRejectedStatus `json:"status"`
}

// MsgStatusRejectedStatus defines model for MsgStatusRejected.Status.
type MsgStatusRejectedStatus string

// MsgStatusSigned The message has been signed, including the signature information.
type MsgStatusSigned struct {
	// Sig Information about a signed message
	Sig struct {
		// Signature The signature
		Signature string `json:"signature"`
	} `json:"sig"`
	Status MsgStatusSignedStatus `json:"status"`
}

// MsgStatusSignedStatus defines model for MsgStatusSigned.Status.
type MsgStatusSignedStatus string

// Network Network name ('mainnet', 'holesky')
type Network string

// NewSessionResponse Information about a new session, returned from multiple endpoints (e.g., login, refresh, etc.).
type NewSessionResponse struct {
	// Expiration Session expiration (in seconds since UNIX epoch), beyond which it cannot be refreshed.
	Expiration *int64 `json:"expiration,omitempty"`
	OrgId      *Id    `json:"org_id"`

	// RefreshToken Token that can be used to refresh this session.
	RefreshToken string `json:"refresh_token"`

	// SessionInfo Session information sent to the client.
	// This struct works in tandem with its server-side counterpart [`SessionData`].
	SessionInfo ClientSessionInfo `json:"session_info"`

	// Token New token to be used for authentication. Requests to signing endpoints
	// should include this value in the `Authorization` header.
	Token string `json:"token"`
}

// NonceValue defines model for NonceValue.
type NonceValue = openapi_types.File

// NotFoundErrorCode defines model for NotFoundErrorCode.
type NotFoundErrorCode string

// NotificationEndpoint defines model for NotificationEndpoint.
type NotificationEndpoint struct {
	// Arn The ARN of the subscription
	Arn string `json:"arn"`

	// Config The configuration for an org event endpoint
	Config NotificationEndpointConfiguration `json:"config"`

	// Status The status of a subscription
	Status SubscriptionStatus `json:"status"`
}

// NotificationEndpointConfiguration The configuration for an org event endpoint
type NotificationEndpointConfiguration struct {
	// Filter Filter for org events
	Filter *OrgEventFilter `json:"filter,omitempty"`

	// Url URL of the endpoint
	Url string `json:"url"`
}

// NotificationEndpointSubscription A notification endpoint subscription
type NotificationEndpointSubscription struct {
	// Arn The ARN of the subscription
	Arn string `json:"arn"`

	// Config The configuration for an org event endpoint
	Config NotificationEndpointConfiguration `json:"config"`
}

// OidcIdentity Represents a globally unique OIDC-authorized user by expressing the full "path" to a user. That is:
//
// (iss) (sub)
// Issuer -> Subresource
type OidcIdentity struct {
	// Iss The root-level issuer who administrates this user. From the OIDC spec:
	// Issuer Identifier for the Issuer of the response. The iss
	// value is a case sensitive URL using the https scheme that contains
	// scheme, host, and optionally, port number and path components and
	// no query or fragment components.
	Iss string `json:"iss"`

	// Sub From the OIDC spec:
	//
	// A locally unique and never reassigned identifier within the Issuer for
	// the End-User, which is intended to be consumed by the Client, e.g.,
	// 24400320 or AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4. It MUST NOT exceed
	// 255 ASCII characters in length. The sub value is a case sensitive
	// string.
	Sub string `json:"sub"`
}

// OidcIssuerInfo Information about an explicitly configured (allowlisted) OpenID provider for an org
type OidcIssuerInfo struct {
	// Audiences Intended audiences (client IDs)
	Audiences []string `json:"audiences"`

	// Issuer Issuer URL
	Issuer string `json:"issuer"`

	// Nickname Optional issuer nickname
	Nickname *string `json:"nickname"`

	// Users The user roles allowed to use this IDP
	Users []MemberRole `json:"users"`
}

// OidcLoginDimensions defines model for OidcLoginDimensions.
type OidcLoginDimensions struct {
	// Issuer The OIDC issuer (provider)
	Issuer string `json:"issuer"`

	// OrgId All metrics must include 'org_id' as a dimension.
	OrgId string `json:"org_id"`
}

// OidcLoginRequest defines model for OidcLoginRequest.
type OidcLoginRequest struct {
	// Client Client information representing the nature of front-end in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`].
	Client *ClientProfile `json:"client,omitempty"`

	// OsInfo OS information set in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`]
	OsInfo *OsInfo `json:"os_info,omitempty"`

	// Purpose A human readable description of the purpose of the session
	Purpose *string `json:"purpose"`

	// Scopes Controls what capabilities this session will have.
	Scopes []Scope        `json:"scopes"`
	Tokens *RatchetConfig `json:"tokens,omitempty"`
}

// OidcUserInfo defines model for OidcUserInfo.
type OidcUserInfo struct {
	// Email The email associated with the user
	Email *string `json:"email"`

	// PreferredUsername The user name (if any) associated with the user
	PreferredUsername *string `json:"preferred_username"`
}

// OperationKind All different kinds of sensitive operations
type OperationKind string

// OrgAlertsPrefs defines model for OrgAlertsPrefs.
type OrgAlertsPrefs struct {
	// AlertRecipients Recipient users for org-level alerts
	AlertRecipients *[]Id `json:"alert_recipients"`

	// SubscribedAlerts Org-level alerts to send emails for
	SubscribedAlerts *[]AlertKind `json:"subscribed_alerts"`
}

// OrgData defines model for OrgData.
type OrgData struct {
	// OrgId The id of the org
	OrgId string `json:"org_id"`

	// OrgName The human-readable name for the org
	OrgName *string `json:"org_name"`
}

// OrgEventDiscriminants Auto-generated discriminant enum variants
type OrgEventDiscriminants string

// OrgEventFilter Filter for org events
type OrgEventFilter struct {
	union json.RawMessage
}

// OrgEventFilterAll Do not filter any org events
type OrgEventFilterAll string

// OrgEventFilterAllExcept defines model for OrgEventFilterAllExcept.
type OrgEventFilterAllExcept struct {
	// AllExcept Accepts all org events other than the ones listed
	AllExcept []OrgEventDiscriminants `json:"AllExcept"`
}

// OrgEventFilterOneOf defines model for OrgEventFilterOneOf.
type OrgEventFilterOneOf struct {
	// OneOf Only accepts org events that are one of the listed events
	OneOf []OrgEventDiscriminants `json:"OneOf"`
}

// OrgExportResponse An org-export ciphertext retrieved via the org-export API.
type OrgExportResponse struct {
	// Ciphertext A base64-encoded export ciphertext.
	Ciphertext string `json:"ciphertext"`
}

// OrgInfo defines model for OrgInfo.
type OrgInfo struct {
	// AccessModel Determines who controls the keys within an org
	AccessModel AccessModel `json:"access_model"`

	// AlienLoginRequirement Represents the number of MFA approvals required for a given operation
	// (e.g. login). Can be used to produce a concrete policy for a given user
	AlienLoginRequirement *SecondFactorRequirement `json:"alien_login_requirement,omitempty"`

	// AllowedMfaTypes MFA types that are allowed to be used for individual implicitly security-sensitive
	// operations (like logging in, adding an MFA factor, exporting keys, etc; see `MfaProtectedAction`).
	AllowedMfaTypes *AllowedMfaMap `json:"allowed_mfa_types,omitempty"`

	// DefaultInviteKind Indicates the auth sources allowed to an invited user
	DefaultInviteKind *InviteKind `json:"default_invite_kind,omitempty"`

	// EmailPreferences Describes email preferences at an Org level - what emails to send and options associated
	EmailPreferences *EmailPreferences `json:"email_preferences,omitempty"`

	// Enabled When false, all cryptographic operations involving keys in this org are disabled.
	Enabled bool `json:"enabled"`

	// HistoricalDataConfiguration Configuration governing whether and how to save historical data.
	HistoricalDataConfiguration *HistoricalDataConfiguration `json:"historical_data_configuration,omitempty"`

	// IdpConfiguration IDP configuration
	IdpConfiguration *IdpConfig `json:"idp_configuration,omitempty"`

	// KeyImportKey Deprecated: this field should be ignored.
	KeyImportKey *string `json:"key_import_key"`

	// KwkId The organization's universally unique key-wrapping-key identifier.
	// This value is required when setting up key export.
	KwkId string `json:"kwk_id"`

	// LastUnstake Date/time (in UTC) when last 'unstake' was performed. Unix epoch if none.
	LastUnstake string `json:"last_unstake"`

	// LastUnstakeDayCount How many 'unstake' calls happened on the day when `last_unstake` was performed.
	LastUnstakeDayCount int32 `json:"last_unstake_day_count"`

	// MemberLoginRequirement Represents the number of MFA approvals required for a given operation
	// (e.g. login). Can be used to produce a concrete policy for a given user
	MemberLoginRequirement *SecondFactorRequirement `json:"member_login_requirement,omitempty"`

	// MetricsEnabled Whether metrics are collected for this org
	MetricsEnabled *bool `json:"metrics_enabled,omitempty"`

	// Name The human-readable name for the org
	Name *string `json:"name"`

	// NotificationEndpoints The organization's notification endpoints, which are HTTPS URLs are notified about a
	// configurable set of events in an organization. For each event, CubeSigner sends a POST
	// request with a JSON-formatted body that contains the event details.
	NotificationEndpoints *[]NotificationEndpoint `json:"notification_endpoints,omitempty"`

	// OrgId The ID of the organization
	OrgId string `json:"org_id"`

	// PasskeyConfiguration Org-level passkey configuration
	PasskeyConfiguration *PasskeyConfig `json:"passkey_configuration,omitempty"`

	// Policy Org-wide policies that are checked before a key is used for signing
	Policy *[]map[string]interface{} `json:"policy,omitempty"`

	// PolicyEngineConfiguration A struct containing Org-level configurations for the workings of the Policy Engine.
	PolicyEngineConfiguration *PolicyEngineConfiguration `json:"policy_engine_configuration,omitempty"`

	// TotpFailureLimit The organization's currently configured TOTP failure limit, i.e., the number
	// of times a user can provide an incorrect TOTP code before being rate limited.
	// This value can be between 1 and 5 (inclusive).
	TotpFailureLimit int32 `json:"totp_failure_limit"`

	// UserExportDelay The organization's currently configured user-export delay, i.e., the minimum
	// amount of time (in seconds) between when a user-export is initiated and when
	// it may be completed. (This value is meaningless for organizations that use
	// org-wide export.)
	UserExportDelay int64 `json:"user_export_delay"`

	// UserExportDisabled Whether user export is disabled
	UserExportDisabled *bool `json:"user_export_disabled,omitempty"`

	// UserExportWindow The organization's currently configured user-export window, i.e., the amount
	// of time (in seconds) between when the user-export delay is completed and when
	// the user export request has expired and can no longer be completed. (This value
	// is meaningless for organizations that use org-wide export.)
	UserExportWindow int64 `json:"user_export_window"`

	// WebappEnabled If set, the official webapp origin is automatically allowed
	WebappEnabled *bool `json:"webapp_enabled,omitempty"`
}

// OrgMetric Supported org metrics.
type OrgMetric struct {
	union json.RawMessage
}

// OrgMetricBillingEvent defines model for OrgMetricBillingEvent.
type OrgMetricBillingEvent struct {
	BillingEvent BillingDimensions `json:"BillingEvent"`
}

// OrgMetricData defines model for OrgMetricData.
type OrgMetricData struct {
	// Data The data points, one for each time period (time periods for which the value is 0 are omitted).
	Data map[string]float64 `json:"data"`

	// Dimensions The metric dimensions.
	Dimensions map[string]string `json:"dimensions"`
}

// OrgMetricDiscriminants Auto-generated discriminant enum variants
type OrgMetricDiscriminants string

// OrgMetricKeyCount defines model for OrgMetricKeyCount.
type OrgMetricKeyCount struct {
	KeyCount KeyCountDimensions `json:"KeyCount"`
}

// OrgMetricOidcLoginEvent defines model for OrgMetricOidcLoginEvent.
type OrgMetricOidcLoginEvent struct {
	OidcLoginEvent OidcLoginDimensions `json:"OidcLoginEvent"`
}

// OrgMetricSignEvent defines model for OrgMetricSignEvent.
type OrgMetricSignEvent struct {
	SignEvent SignDimensions `json:"SignEvent"`
}

// OrgMetricStat Available statistics to compute
type OrgMetricStat string

// OrgMetricUserCount defines model for OrgMetricUserCount.
type OrgMetricUserCount struct {
	UserCount UserCountDimensions `json:"UserCount"`
}

// OsInfo OS information set in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`]
type OsInfo struct {
	Architecture *string `json:"architecture"`
	Name         *string `json:"name"`
	Version      *string `json:"version"`
	WordSize     *string `json:"word_size"`
}

// OtherScopes Scopes including wildcard fragments for accessing CubeSigner APIs
type OtherScopes = string

// Page The rocket query parameter representing the page from which to start a paginated query.
//
// MUST be named `<page>` in rocket url spec so that 'serde(rename = "page.*")' below continues to work
type Page struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `json:"page.start"`
}

// PaginatedGetUsersInOrgResponse defines model for PaginatedGetUsersInOrgResponse.
type PaginatedGetUsersInOrgResponse struct {
	// LastEvaluatedKey If set, the content of `response` does not contain the entire result set.
	// To fetch the next page of the result set, call the same endpoint
	// but specify this value as the 'page.start' query parameter.
	LastEvaluatedKey *string `json:"last_evaluated_key"`

	// Users The list of users in the org
	Users []UserInOrgInfo `json:"users"`
}

// PaginatedListContactsResponse defines model for PaginatedListContactsResponse.
type PaginatedListContactsResponse struct {
	// Contacts All contacts in an organization.
	Contacts []ContactInfo `json:"contacts"`

	// LastEvaluatedKey If set, the content of `response` does not contain the entire result set.
	// To fetch the next page of the result set, call the same endpoint
	// but specify this value as the 'page.start' query parameter.
	LastEvaluatedKey *string `json:"last_evaluated_key"`
}

// PaginatedListHistoricalTxResponse defines model for PaginatedListHistoricalTxResponse.
type PaginatedListHistoricalTxResponse struct {
	// LastEvaluatedKey If set, the content of `response` does not contain the entire result set.
	// To fetch the next page of the result set, call the same endpoint
	// but specify this value as the 'page.start' query parameter.
	LastEvaluatedKey *string `json:"last_evaluated_key"`

	// Txs Historical transactions signed with the requested key, sorted from most to least recent.
	Txs []HistoricalTx `json:"txs"`
}

// PaginatedListKeyRolesResponse defines model for PaginatedListKeyRolesResponse.
type PaginatedListKeyRolesResponse struct {
	// LastEvaluatedKey If set, the content of `response` does not contain the entire result set.
	// To fetch the next page of the result set, call the same endpoint
	// but specify this value as the 'page.start' query parameter.
	LastEvaluatedKey *string `json:"last_evaluated_key"`

	// Roles All roles the key is in
	Roles []KeyInRoleInfo `json:"roles"`
}

// PaginatedListKeysResponse defines model for PaginatedListKeysResponse.
type PaginatedListKeysResponse struct {
	Keys []KeyInfo `json:"keys"`

	// LastEvaluatedKey If set, the content of `response` does not contain the entire result set.
	// To fetch the next page of the result set, call the same endpoint
	// but specify this value as the 'page.start' query parameter.
	LastEvaluatedKey *string `json:"last_evaluated_key"`
}

// PaginatedListPoliciesResponse defines model for PaginatedListPoliciesResponse.
type PaginatedListPoliciesResponse struct {
	// LastEvaluatedKey If set, the content of `response` does not contain the entire result set.
	// To fetch the next page of the result set, call the same endpoint
	// but specify this value as the 'page.start' query parameter.
	LastEvaluatedKey *string `json:"last_evaluated_key"`

	// Policies The Org's named policies.
	Policies []PolicyInfo `json:"policies"`
}

// PaginatedListRoleKeysResponse defines model for PaginatedListRoleKeysResponse.
type PaginatedListRoleKeysResponse struct {
	// Keys All keys in a role
	Keys []KeyInRoleInfo `json:"keys"`

	// LastEvaluatedKey If set, the content of `response` does not contain the entire result set.
	// To fetch the next page of the result set, call the same endpoint
	// but specify this value as the 'page.start' query parameter.
	LastEvaluatedKey *string `json:"last_evaluated_key"`
}

// PaginatedListRoleUsersResponse defines model for PaginatedListRoleUsersResponse.
type PaginatedListRoleUsersResponse struct {
	// LastEvaluatedKey If set, the content of `response` does not contain the entire result set.
	// To fetch the next page of the result set, call the same endpoint
	// but specify this value as the 'page.start' query parameter.
	LastEvaluatedKey *string `json:"last_evaluated_key"`

	// Users All users in a role
	Users []UserInRoleInfo `json:"users"`
}

// PaginatedListRolesResponse defines model for PaginatedListRolesResponse.
type PaginatedListRolesResponse struct {
	// LastEvaluatedKey If set, the content of `response` does not contain the entire result set.
	// To fetch the next page of the result set, call the same endpoint
	// but specify this value as the 'page.start' query parameter.
	LastEvaluatedKey *string `json:"last_evaluated_key"`

	// Roles All roles in an organization.
	Roles []RoleInfo `json:"roles"`
}

// PaginatedPolicyLogsResponse defines model for PaginatedPolicyLogsResponse.
type PaginatedPolicyLogsResponse struct {
	// LastEvaluatedKey If set, the content of `response` does not contain the entire result set.
	// To fetch the next page of the result set, call the same endpoint
	// but specify this value as the 'page.start' query parameter.
	LastEvaluatedKey *string `json:"last_evaluated_key"`

	// Logs The policy execution logs
	Logs []map[string]string `json:"logs"`
}

// PaginatedQueryMetricsResponse defines model for PaginatedQueryMetricsResponse.
type PaginatedQueryMetricsResponse struct {
	// LastEvaluatedKey If set, the content of `response` does not contain the entire result set.
	// To fetch the next page of the result set, call the same endpoint
	// but specify this value as the 'page.start' query parameter.
	LastEvaluatedKey *string `json:"last_evaluated_key"`

	// Messages Advisory messages (e.g., if max number of results is reached).
	Messages *[]string `json:"messages,omitempty"`

	// Period The period for which the statistic is computed, if any (not all metrics support splitting the requested time range into bins).
	// If set, equals to the value from the request rounded up to the closest multiple of 60.
	Period *int64 `json:"period,omitempty"`

	// RawData Some metrics can optionally return the raw data, when requested.
	RawData []map[string]string `json:"raw_data"`

	// Results Computed data points.
	Results []struct {
		// Data The data points, one for each time period (time periods for which the value is 0 are omitted).
		Data map[string]float64 `json:"data"`

		// Dimensions The metric dimensions.
		Dimensions map[string]string `json:"dimensions"`
	} `json:"results"`
	Stat *OrgMetricStat `json:"stat"`
}

// PaginatedSessionsResponse defines model for PaginatedSessionsResponse.
type PaginatedSessionsResponse struct {
	// LastEvaluatedKey If set, the content of `response` does not contain the entire result set.
	// To fetch the next page of the result set, call the same endpoint
	// but specify this value as the 'page.start' query parameter.
	LastEvaluatedKey *string `json:"last_evaluated_key"`

	// Sessions The list of sessions
	Sessions []SessionInfo `json:"sessions"`
}

// PaginatedUserExportListResponse defines model for PaginatedUserExportListResponse.
type PaginatedUserExportListResponse struct {
	ExportRequests []UserExportInitResponse `json:"export_requests"`

	// LastEvaluatedKey If set, the content of `response` does not contain the entire result set.
	// To fetch the next page of the result set, call the same endpoint
	// but specify this value as the 'page.start' query parameter.
	LastEvaluatedKey *string `json:"last_evaluated_key"`
}

// PasskeyAssertAnswer Sent from the client to the server to answer a fido challenge
type PasskeyAssertAnswer struct {
	// ChallengeId The ID of the challenge that was returned from the POST endpoint
	ChallengeId string `json:"challenge_id"`

	// Credential This type represents a wire-encodable form of the PublicKeyCredential interface
	// Clients may need to manually encode into this format to communicate with the server
	//
	// The PublicKeyCredential interface inherits from Credential
	// [CREDENTIAL-MANAGEMENT-1], and contains the attributes that are returned to
	// the caller when a new credential is created, or a new assertion is
	// requested.
	//
	// https://www.w3.org/TR/webauthn-2/#iface-pkcredential
	Credential PublicKeyCredential `json:"credential"`
}

// PasskeyAssertChallenge defines model for PasskeyAssertChallenge.
type PasskeyAssertChallenge struct {
	// ChallengeId The id of the challenge. Must be supplied when answering the challenge.
	ChallengeId string `json:"challenge_id"`

	// Options The `PublicKeyCredentialRequestOptions` dictionary supplies get() with the
	// data it needs to generate an assertion. Its challenge member MUST be
	// present, while its other members are OPTIONAL.
	//
	// This struct is also used as part of the verification procedure for assertions
	Options PublicKeyCredentialRequestOptions `json:"options"`

	// Preimage A base64url encoding of UTF8 JSON. The data in that JSON is endpoint specific, and describes what this FIDO challenge will be used for.
	//
	// Clients can use `preimage` along with `random_seed` to reconstruct the challenge like so:
	//
	// `challenge = HMAC-SHA256(key=random_seed, message=preimage)`
	Preimage string `json:"preimage"`

	// RandomSeed A random seed that prevents replay attacks
	RandomSeed string `json:"random_seed"`
}

// PasskeyConfig Org-level passkey configuration
type PasskeyConfig struct {
	// Users Enable passkey login for certain user roles (disabled for everyone by default)
	Users *[]MemberRole `json:"users,omitempty"`
}

// PasswordResetConfirmRequest defines model for PasswordResetConfirmRequest.
type PasswordResetConfirmRequest struct {
	// NewPassword The new password to set.
	NewPassword string `json:"new_password"`

	// Token Invitation token, constructed by concatenating the "partial token"
	// (i.e., `{header}.{payload}.`) returned by the `idp_password_reset_request` endpoint
	// and the signature sent to the user's email.
	Token string `json:"token"`
}

// PasswordResetRequest The request body for the idp password reset endpoint
type PasswordResetRequest struct {
	// Email The email address of the user requesting to reset their password
	Email string `json:"email"`
}

// PendingMessageInfo defines model for PendingMessageInfo.
type PendingMessageInfo struct {
	// CreatedAt DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	CreatedAt EpochDateTime `json:"created_at"`

	// ExpiresAt DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	ExpiresAt EpochDateTime `json:"expires_at"`

	// Id The ID of the pending message
	Id string `json:"id"`

	// Identity The identity (a user or a role id) which created this message.
	Identity      string `json:"identity"`
	MessageEip191 *struct {
		// Address From address, hex-encoded, with leading '0x'
		Address string `json:"address"`

		// Message Hex-encoded (including a '0x' prefix) message to sign.
		Message string `json:"message"`
	} `json:"message_eip191"`
	MessageEip712 *struct {
		// Address From address, hex-encoded, with leading '0x'
		Address string `json:"address"`

		// Data Represents the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) typed data object.
		//
		// Typed data is a JSON object containing type information, domain separator parameters and the
		// message object.
		Data    TypedData                              `json:"data"`
		Version PendingMessageInfoMessageEip712Version `json:"version"`
	} `json:"message_eip712"`
	MessageTx     *TypedTransaction     `json:"message_tx"`
	Metadata      MmiMetadata           `json:"metadata"`
	SignedMessage *SignedMessage        `json:"signedMessage"`
	Transaction   *TransactionAndStatus `json:"transaction"`
}

// PendingMessageInfoMessageEip712Version defines model for PendingMessageInfo.MessageEip712.Version.
type PendingMessageInfoMessageEip712Version string

// PendingMessageSignResponse defines model for PendingMessageSignResponse.
type PendingMessageSignResponse struct {
	// CreatedAt DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	CreatedAt EpochDateTime `json:"created_at"`

	// ExpiresAt DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	ExpiresAt EpochDateTime `json:"expires_at"`

	// Id The ID of the pending message
	Id string `json:"id"`

	// Identity The identity (a user or a role id) which created this message.
	Identity      string `json:"identity"`
	MessageEip191 *struct {
		// Address From address, hex-encoded, with leading '0x'
		Address string `json:"address"`

		// Message Hex-encoded (including a '0x' prefix) message to sign.
		Message string `json:"message"`
	} `json:"message_eip191"`
	MessageEip712 *struct {
		// Address From address, hex-encoded, with leading '0x'
		Address string `json:"address"`

		// Data Represents the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) typed data object.
		//
		// Typed data is a JSON object containing type information, domain separator parameters and the
		// message object.
		Data    TypedData                                      `json:"data"`
		Version PendingMessageSignResponseMessageEip712Version `json:"version"`
	} `json:"message_eip712"`
	MessageTx     *TypedTransaction     `json:"message_tx"`
	Metadata      MmiMetadata           `json:"metadata"`
	SignedMessage *SignedMessage        `json:"signedMessage"`
	Transaction   *TransactionAndStatus `json:"transaction"`
}

// PendingMessageSignResponseMessageEip712Version defines model for PendingMessageSignResponse.MessageEip712.Version.
type PendingMessageSignResponseMessageEip712Version string

// PolicyAttachedToId The id for attaching a named policy to a key, role, or key in role.
type PolicyAttachedToId struct {
	union json.RawMessage
}

// PolicyAttachedToIdObject defines model for PolicyAttachedToIdObject.
type PolicyAttachedToIdObject struct {
	// KeyId The id of the key in the role the policy should be attached to.
	KeyId string `json:"key_id"`

	// RoleId The id of the role the key is in.
	RoleId string `json:"role_id"`
}

// PolicyAttachedToIdkeyId defines model for PolicyAttachedToIdkey_id.
type PolicyAttachedToIdkeyId struct {
	// KeyId The id of the key the policy should be attached to.
	KeyId string `json:"key_id"`
}

// PolicyAttachedToIdroleId defines model for PolicyAttachedToIdrole_id.
type PolicyAttachedToIdroleId struct {
	// RoleId The id of the role the policy should be attached to.
	RoleId string `json:"role_id"`
}

// PolicyEngineConfiguration A struct containing Org-level configurations for the workings of the Policy Engine.
type PolicyEngineConfiguration struct {
	// AllowedHttpAuthorities Allowed domains for HTTP requests
	AllowedHttpAuthorities []string `json:"allowed_http_authorities"`
}

// PolicyErrorCode defines model for PolicyErrorCode.
type PolicyErrorCode struct {
	union json.RawMessage
}

// PolicyErrorOwnCodes defines model for PolicyErrorOwnCodes.
type PolicyErrorOwnCodes string

// PolicyInfo A struct containing all the information about a specific version of a policy.
type PolicyInfo struct {
	// AttachedTo A list of entities (keys, roles, etc.) the policy is attached to.
	AttachedTo []PolicyAttachedToId `json:"attached_to"`

	// Created DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	Created EpochDateTime `json:"created"`

	// EditPolicy A policy which governs when and who is allowed to update the entity this policy is
	// attached to (e.g., a role or a key).
	//
	// When attached to a role, by default, this policy applies to role deletion and all
	// role updates (including adding/removing keys and users); in terms of scopes,
	// it applies to `manage:role:update:*` and `manage:role:delete`.
	//
	// When attached to a key, by default, this policy applies to key deletion, all
	// key updates, and adding/removing that key to/from a role; in terms of scopes,
	// it applies to `manage:key:update:*`, `manage:key:delete`, `manage:role:update:key:*`.
	//
	// This default can be changed by setting the `applies_to_scopes` property.
	EditPolicy *EditPolicy `json:"edit_policy,omitempty"`

	// Metadata User-defined metadata for the named policy.
	Metadata interface{} `json:"metadata,omitempty"`

	// Name The name of the policy.
	Name  string `json:"name"`
	Owner Id     `json:"owner"`

	// PolicyId The policy id
	PolicyId string `json:"policy_id"`

	// PolicyType The type of a [NamedPolicy].
	//
	// The type of a policy is set at creation time, and is used to offer guarantees
	// about the current and all future versions of a [NamedPolicy].
	PolicyType PolicyType `json:"policy_type"`

	// Rules The policy rule.
	Rules []interface{} `json:"rules"`

	// Version The policy rule's version.
	Version int64 `json:"version"`
}

// PolicyLogsRequest A request for querying Wasm policy logs.
type PolicyLogsRequest struct {
	// EndTime End time in seconds since unix epoch. If omitted, defaults to 'now'.
	EndTime *int64 `json:"end_time"`

	// StartTime Start time in seconds since unix epoch. If omitted, defaults to 24 hours ago.
	StartTime *int64 `json:"start_time"`

	// Version The version of the policy to get the logs for.
	// If omitted, all policy logs are retrieved.
	Version *string `json:"version,omitempty"`
}

// PolicyResultResponse PolicyResultResponse is a wrapper on PolicyResult with two important
// properties:
// * derives OkToLogResponse, so that it can be used in the rocket handler.
// * derives ToSchema and ToResponse, with the `val` field with value_type
// Object, so that we don't have to provide all of the OpenAPI type
// descriptions of a PolicyResult.
//
// The PolicyResult includes enums and other standard types (e.g.
// std::time::Interval) which are nontrivial to represent in OpenAPI. Since
// this endpoint is just for testing, we don't really care about how accurate
// the schema is, and can lean on serde_json when decoding this response to a
// PolicyResult in a client. Note that there is a bug in utoipa where the
// value_type annotation will not work for a tuple-struct, only a struct with
// fields.
type PolicyResultResponse struct {
	Val map[string]interface{} `json:"val"`
}

// PolicySecretsInfo defines model for PolicySecretsInfo.
type PolicySecretsInfo struct {
	Created *EpochDateTime `json:"created"`

	// EditPolicy A policy which governs when and who is allowed to update the entity this policy is
	// attached to (e.g., a role or a key).
	//
	// When attached to a role, by default, this policy applies to role deletion and all
	// role updates (including adding/removing keys and users); in terms of scopes,
	// it applies to `manage:role:update:*` and `manage:role:delete`.
	//
	// When attached to a key, by default, this policy applies to key deletion, all
	// key updates, and adding/removing that key to/from a role; in terms of scopes,
	// it applies to `manage:key:update:*`, `manage:key:delete`, `manage:role:update:key:*`.
	//
	// This default can be changed by setting the `applies_to_scopes` property.
	EditPolicy   *EditPolicy    `json:"edit_policy,omitempty"`
	LastModified *EpochDateTime `json:"last_modified"`

	// Metadata User-defined metadata. When rendering (e.g., in the browser) you should treat
	// it as untrusted user data (and avoid injecting metadata into HTML directly) if
	// untrusted users can create/update keys (or their metadata).
	Metadata interface{} `json:"metadata,omitempty"`

	// Names The names of the secrets.,
	Names []string `json:"names"`

	// Version Version of this object
	Version *int64 `json:"version,omitempty"`
}

// PolicyType The type of a [NamedPolicy].
//
// The type of a policy is set at creation time, and is used to offer guarantees
// about the current and all future versions of a [NamedPolicy].
type PolicyType string

// PreconditionErrorCode defines model for PreconditionErrorCode.
type PreconditionErrorCode struct {
	union json.RawMessage
}

// PreconditionErrorOwnCodes defines model for PreconditionErrorOwnCodes.
type PreconditionErrorOwnCodes string

// PrevOutputs Contains outputs of previous transactions.
type PrevOutputs struct {
	union json.RawMessage
}

// PrevOutputsAll defines model for PrevOutputsAll.
type PrevOutputsAll struct {
	// All When `SIGHASH_ANYONECANPAY` is not provided, or when the caller is giving all
	// previous outputs so the same variable can be used for multiple inputs.
	All []BtcTxOut `json:"All"`
}

// PrevOutputsOne defines model for PrevOutputsOne.
type PrevOutputsOne struct {
	// One `One` variant allows provision of the single previous output needed. It's useful,
	// for example, when modifier `SIGHASH_ANYONECANPAY` is provided, only previous output
	// of the current input is needed. The first `index` argument is the input index
	// this output is referring to.
	One struct {
		Index int      `json:"index"`
		TxOut BtcTxOut `json:"tx_out"`
	} `json:"One"`
}

// PsbtSignRequest defines model for PsbtSignRequest.
type PsbtSignRequest struct {
	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata interface{} `json:"metadata"`

	// Psbt A hex-serialized PSBT (version 0), with or without leading 0x prefix.
	// This PSBT must contain the transaction inputs and outputs, plus all
	// information needed to sign (e.g., taproot path and leaf information).
	Psbt string `json:"psbt"`

	// SignAllScripts When true, unconditionally sign every input to the PSBT controlled by a script
	// spend. Otherwise (false, the default), this endpoint uses a heuristic to decide
	// whether the script controlling a given UTXO requires a signature from this key.
	SignAllScripts *bool `json:"sign_all_scripts,omitempty"`
}

// PsbtSignResponse Response to a PSBT signing request
type PsbtSignResponse struct {
	// Psbt The PSBT in standard hex serialization, without leading "0x".
	Psbt string `json:"psbt"`
}

// PublicKeyCredential This type represents a wire-encodable form of the PublicKeyCredential interface
// Clients may need to manually encode into this format to communicate with the server
//
// The PublicKeyCredential interface inherits from Credential
// [CREDENTIAL-MANAGEMENT-1], and contains the attributes that are returned to
// the caller when a new credential is created, or a new assertion is
// requested.
//
// https://www.w3.org/TR/webauthn-2/#iface-pkcredential
type PublicKeyCredential struct {
	// ClientExtensionResults This internal slot contains the results of processing client extensions
	// requested by the Relying Party upon the Relying Party's invocation of
	// either navigator.credentials.create() or navigator.credentials.get().
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredential-clientextensionsresults-slot
	//
	// IMPLEMENTATION NOTE: The type for this field comes from the type of getClientExtensionResults() which as the following doc:
	//
	// This operation returns the value of [[clientExtensionsResults]], which is a map containing extension identifier  client extension output entries produced by the extensions client extension processing.
	// https://www.w3.org/TR/webauthn-2/#ref-for-dom-publickeycredential-getclientextensionresults
	ClientExtensionResults *map[string]interface{} `json:"clientExtensionResults"`

	// Id This internal slot contains the credential ID, chosen by the
	// authenticator. The credential ID is used to look up credentials for use,
	// and is therefore expected to be globally unique with high probability
	// across all credentials of the same type, across all authenticators.
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredential-identifier-slot
	Id string `json:"id"`

	// Response Authenticators respond to Relying Party requests by returning an object derived from the AuthenticatorResponse interface
	Response PublicKeyCredential_Response `json:"response"`
}

// PublicKeyCredential_Response Authenticators respond to Relying Party requests by returning an object derived from the AuthenticatorResponse interface
type PublicKeyCredential_Response struct {
	union json.RawMessage
}

// PublicKeyCredentialCreationOptions Defines the parameters for the creation of a new public key credential
//
// https://www.w3.org/TR/webauthn-2/#dictdef-publickeycredentialcreationoptions
type PublicKeyCredentialCreationOptions struct {
	// Attestation WebAuthn Relying Parties may use AttestationConveyancePreference to specify
	// their preference regarding attestation conveyance during credential
	// generation.
	//
	// https://www.w3.org/TR/webauthn-2/#enumdef-attestationconveyancepreference
	Attestation            *AttestationConveyancePreference `json:"attestation,omitempty"`
	AuthenticatorSelection *AuthenticatorSelectionCriteria  `json:"authenticatorSelection"`

	// Challenge This member contains a challenge intended to be used for generating the
	// newly created credentials attestation object. See the  13.4.3
	// Cryptographic Challenges security consideration.
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialcreationoptions-challenge
	Challenge string `json:"challenge"`

	// ExcludeCredentials This member is intended for use by Relying Parties that wish to limit
	// the creation of multiple credentials for the same account on a single
	// authenticator. The client is requested to return an error if the new
	// credential would be created on an authenticator that also contains one
	// of the credentials enumerated in this parameter.
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialcreationoptions-excludecredentials
	ExcludeCredentials *[]PublicKeyCredentialDescriptor `json:"excludeCredentials,omitempty"`

	// Extensions This member contains additional parameters requesting additional
	// processing by the client and authenticator. For example, the caller may
	// request that only authenticators with certain capabilities be used to
	// create the credential, or that particular information be returned in the
	// attestation object. Some extensions are defined in  9 WebAuthn
	// Extensions; consult the IANA "WebAuthn Extension Identifiers" registry
	// [IANA-WebAuthn-Registries] established by [RFC8809] for an up-to-date
	// list of registered WebAuthn Extensions.
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialcreationoptions-extensions
	Extensions *map[string]interface{} `json:"extensions"`

	// PubKeyCredParams This member contains information about the desired properties of the
	// credential to be created. The sequence is ordered from most preferred to
	// least preferred. The client makes a best-effort to create the most
	// preferred credential that it can.
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialcreationoptions-pubkeycredparams
	PubKeyCredParams []PublicKeyCredentialParameters `json:"pubKeyCredParams"`

	// Rp The PublicKeyCredentialRpEntity dictionary is used to supply additional
	// Relying Party attributes when creating a new credential.
	//
	// https://www.w3.org/TR/webauthn-2/#dictionary-rp-credential-params
	Rp PublicKeyCredentialRpEntity `json:"rp"`

	// Timeout This member specifies a time, in milliseconds, that the caller is
	// willing to wait for the call to complete. This is treated as a hint, and
	// MAY be overridden by the client.
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialcreationoptions-timeout
	Timeout *int32 `json:"timeout"`

	// User The PublicKeyCredentialUserEntity dictionary is used to supply additional
	// user account attributes when creating a new credential.
	User PublicKeyCredentialUserEntity `json:"user"`
}

// PublicKeyCredentialDescriptor This dictionary contains the attributes that are specified by a caller when
// referring to a public key credential as an input parameter to the create()
// or get() methods. It mirrors the fields of the PublicKeyCredential object
// returned by the latter methods.
//
// https://www.w3.org/TR/webauthn-2/#dictionary-credential-descriptor
type PublicKeyCredentialDescriptor struct {
	// Id This member contains the credential ID of the public key credential the caller is referring to.
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialdescriptor-id
	Id string `json:"id"`

	// Transports This OPTIONAL member contains a hint as to how the client might
	// communicate with the managing authenticator of the public key credential
	// the caller is referring to. The values SHOULD be members of
	// AuthenticatorTransport but client platforms MUST ignore unknown values.
	//
	// The getTransports() operation can provide suitable values for this
	// member. When registering a new credential, the Relying Party SHOULD
	// store the value returned from getTransports(). When creating a
	// PublicKeyCredentialDescriptor for that credential, the Relying Party
	// SHOULD retrieve that stored value and set it as the value of the
	// transports member.
	Transports *[]AuthenticatorTransport `json:"transports"`

	// Type This enumeration defines the valid credential types. It is an extension
	// point; values can be added to it in the future, as more credential types are
	// defined. The values of this enumeration are used for versioning the
	// Authentication Assertion and attestation structures according to the type of
	// the authenticator. Currently one credential type is defined, namely
	// "public-key".
	//
	// https://www.w3.org/TR/webauthn-2/#enumdef-publickeycredentialtype
	Type PublicKeyCredentialType `json:"type"`
}

// PublicKeyCredentialParameters This dictionary is used to supply additional parameters when creating a new
// credential.
//
// https://www.w3.org/TR/webauthn-2/#dictionary-credential-params
type PublicKeyCredentialParameters struct {
	// Alg This member specifies the cryptographic signature algorithm with which
	// the newly generated credential will be used, and thus also the type of
	// asymmetric key pair to be generated, e.g., RSA or Elliptic Curve.
	Alg int64 `json:"alg"`

	// Type This enumeration defines the valid credential types. It is an extension
	// point; values can be added to it in the future, as more credential types are
	// defined. The values of this enumeration are used for versioning the
	// Authentication Assertion and attestation structures according to the type of
	// the authenticator. Currently one credential type is defined, namely
	// "public-key".
	//
	// https://www.w3.org/TR/webauthn-2/#enumdef-publickeycredentialtype
	Type PublicKeyCredentialType `json:"type"`
}

// PublicKeyCredentialRequestOptions The `PublicKeyCredentialRequestOptions` dictionary supplies get() with the
// data it needs to generate an assertion. Its challenge member MUST be
// present, while its other members are OPTIONAL.
//
// This struct is also used as part of the verification procedure for assertions
type PublicKeyCredentialRequestOptions struct {
	// AllowCredentials This OPTIONAL member contains a list of PublicKeyCredentialDescriptor
	// objects representing public key credentials acceptable to the caller, in
	// descending order of the callers preference (the first item in the list
	// is the most preferred credential, and so on down the list).
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialrequestoptions-allowcredentials
	AllowCredentials *[]PublicKeyCredentialDescriptor `json:"allowCredentials,omitempty"`

	// Challenge This member represents a challenge that the selected authenticator
	// signs, along with other data, when producing an authentication
	// assertion.
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialrequestoptions-challenge
	Challenge  string                  `json:"challenge"`
	Extensions *map[string]interface{} `json:"extensions"`

	// RpId This OPTIONAL member specifies the relying party identifier claimed by
	// the caller. If omitted, its value will be the CredentialsContainer
	// objects relevant settings object's origin's effective domain.
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialrequestoptions-rpid
	RpId *string `json:"rpId"`

	// Timeout This OPTIONAL member specifies a time, in milliseconds, that the caller
	// is willing to wait for the call to complete. The value is treated as a
	// hint, and MAY be overridden by the client.
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialrequestoptions-timeout
	Timeout *int32 `json:"timeout"`

	// UserVerification A WebAuthn Relying Party may require user verification for some of its
	// operations but not for others, and may use this type to express its needs.
	//
	// https://www.w3.org/TR/webauthn-2/#enum-userVerificationRequirement
	UserVerification *UserVerificationRequirement `json:"userVerification,omitempty"`
}

// PublicKeyCredentialRpEntity The PublicKeyCredentialRpEntity dictionary is used to supply additional
// Relying Party attributes when creating a new credential.
//
// https://www.w3.org/TR/webauthn-2/#dictionary-rp-credential-params
type PublicKeyCredentialRpEntity struct {
	// Id A unique identifier for the Relying Party entity, which sets the RP ID.
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialrpentity-id
	Id *string `json:"id"`

	// Name A human-palatable name for the entity. Its function depends on what the
	// PublicKeyCredentialEntity represents: When inherited by
	// PublicKeyCredentialRpEntity it is a human-palatable identifier for the
	// Relying Party, intended only for display. For example, "ACME
	// Corporation", "Wonderful Widgets, Inc." or " ".
	//
	// Relying Parties SHOULD perform enforcement, as prescribed in Section 2.3
	// of [RFC8266] for the Nickname Profile of the PRECIS FreeformClass
	// [RFC8264], when setting name's value, or displaying the value to the
	// user.
	//
	// This string MAY contain language and direction metadata. Relying Parties
	// SHOULD consider providing this information. See  6.4.2 Language and
	// Direction Encoding about how this metadata is encoded.
	Name string `json:"name"`
}

// PublicKeyCredentialType This enumeration defines the valid credential types. It is an extension
// point; values can be added to it in the future, as more credential types are
// defined. The values of this enumeration are used for versioning the
// Authentication Assertion and attestation structures according to the type of
// the authenticator. Currently one credential type is defined, namely
// "public-key".
//
// https://www.w3.org/TR/webauthn-2/#enumdef-publickeycredentialtype
type PublicKeyCredentialType string

// PublicKeyCredentialUserEntity The PublicKeyCredentialUserEntity dictionary is used to supply additional
// user account attributes when creating a new credential.
type PublicKeyCredentialUserEntity struct {
	// DisplayName A human-palatable name for the user account, intended only for display.
	// For example, "Alex Mller" or "". The Relying Party SHOULD let the
	// user choose this, and SHOULD NOT restrict the choice more than
	// necessary.
	//
	// Relying Parties SHOULD perform enforcement, as prescribed in Section 2.3
	// of [RFC8266] for the Nickname Profile of the PRECIS FreeformClass
	// [RFC8264], when setting displayName's value, or displaying the value to
	// the user.
	//
	// This string MAY contain language and direction metadata. Relying Parties
	// SHOULD consider providing this information. See  6.4.2 Language and
	// Direction Encoding about how this metadata is encoded.
	//
	// Clients SHOULD perform enforcement, as prescribed in Section 2.3 of
	// [RFC8266] for the Nickname Profile of the PRECIS FreeformClass
	// [RFC8264], on displayName's value prior to displaying the value to the
	// user or including the value as a parameter of the
	// authenticatorMakeCredential operation.
	//
	// When clients, client platforms, or authenticators display a
	// displayName's value, they should always use UI elements to provide a
	// clear boundary around the displayed value, and not allow overflow into
	// other elements [css-overflow-3].
	//
	// Authenticators MUST accept and store a 64-byte minimum length for a
	// displayName members value. Authenticators MAY truncate a displayName
	// members value so that it fits within 64 bytes. See  6.4.1 String
	// Truncation about truncation and other considerations.
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialuserentity-displayname
	DisplayName string `json:"displayName"`

	// Id The user handle of the user account entity. A user handle is an opaque
	// byte sequence with a maximum size of 64 bytes, and is not meant to be
	// displayed to the user.
	//
	// To ensure secure operation, authentication and authorization decisions
	// MUST be made on the basis of this id member, not the displayName nor
	// name members. See Section 6.1 of [RFC8266].
	//
	// The user handle MUST NOT contain personally identifying information
	// about the user, such as a username or e-mail address; see  14.6.1 User
	// Handle Contents for details. The user handle MUST NOT be empty, though
	// it MAY be null.
	//
	// Note: the user handle ought not be a constant value across different
	// accounts, even for non-discoverable credentials, because some
	// authenticators always create discoverable credentials. Thus a constant
	// user handle would prevent a user from using such an authenticator with
	// more than one account at the Relying Party.
	//
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialuserentity-id
	Id string `json:"id"`

	// Name When inherited by PublicKeyCredentialUserEntity, it is a human-palatable
	// identifier for a user account. It is intended only for display, i.e.,
	// aiding the user in determining the difference between user accounts with
	// similar displayNames. For example, "alexm", "alex.mueller@example.com"
	// or "+14255551234".
	//
	// The Relying Party MAY let the user choose this value. The Relying Party
	// SHOULD perform enforcement, as prescribed in Section 3.4.3 of [RFC8265]
	// for the UsernameCasePreserved Profile of the PRECIS IdentifierClass
	// [RFC8264], when setting name's value, or displaying the value to the
	// user.
	//
	// This string MAY contain language and direction metadata. Relying Parties
	// SHOULD consider providing this information. See  6.4.2 Language and
	// Direction Encoding about how this metadata is encoded.
	//
	// Clients SHOULD perform enforcement, as prescribed in Section 3.4.3 of [RFC8265] for the UsernameCasePreserved Profile of the PRECIS IdentifierClass [RFC8264], on name's value prior to displaying the value to the user or including the value as a parameter of the authenticatorMakeCredential operation.
	Name string `json:"name"`
}

// PublicOrgInfo Public information about an organization.
type PublicOrgInfo struct {
	// OidcIssuers Explicitly configured (allowlisted) OpenID providers for an org
	OidcIssuers []struct {
		// Audiences Intended audiences (client IDs)
		Audiences []string `json:"audiences"`

		// Issuer Issuer URL
		Issuer string `json:"issuer"`

		// Nickname Optional issuer nickname
		Nickname *string `json:"nickname"`

		// Users The user roles allowed to use this IDP
		Users []MemberRole `json:"users"`
	} `json:"oidc_issuers"`

	// OrgId Org identifier
	OrgId string `json:"org_id"`

	// PasskeyLoginEnabled Whether logging in with just a passkey is allowed
	PasskeyLoginEnabled bool `json:"passkey_login_enabled"`
}

// Purpose defines model for Purpose.
type Purpose string

// QueryMetricsRequest defines model for QueryMetricsRequest.
type QueryMetricsRequest struct {
	// EndTime End time in seconds since unix epoch. If omitted, defaults to 'now'.
	EndTime *int64 `json:"end_time"`

	// MetricName The name of the metric to compute
	MetricName MetricName `json:"metric_name"`

	// Period The granularity, in seconds, of the returned data points.
	//
	// This value is automatically rounded up to a multiple of 3600 (i.e., 1 hour).
	// If omitted, defaults to the duration between `end_time` and `start_time`.
	// Must be no less than 1 hour (3600 seconds) for "event" metrics, and 1 day
	// (86400 seconds) for "count" metrics. Also, this period must not
	// divide the `end_time - start_time` period into more than 100 data points.
	Period *int64 `json:"period"`

	// RawData Return the raw data instead of computing the metric values
	// (not supported by all metrics).
	RawData *bool `json:"raw_data,omitempty"`

	// StartTime Start time in seconds since unix epoch.
	StartTime int64 `json:"start_time"`
}

// QueryMetricsResponse The metric data points.
type QueryMetricsResponse struct {
	// Messages Advisory messages (e.g., if max number of results is reached).
	Messages *[]string `json:"messages,omitempty"`

	// Period The period for which the statistic is computed, if any (not all metrics support splitting the requested time range into bins).
	// If set, equals to the value from the request rounded up to the closest multiple of 60.
	Period *int64 `json:"period,omitempty"`

	// RawData Some metrics can optionally return the raw data, when requested.
	RawData []map[string]string `json:"raw_data"`

	// Results Computed data points.
	Results []struct {
		// Data The data points, one for each time period (time periods for which the value is 0 are omitted).
		Data map[string]float64 `json:"data"`

		// Dimensions The metric dimensions.
		Dimensions map[string]string `json:"dimensions"`
	} `json:"results"`
	Stat *OrgMetricStat `json:"stat"`
}

// RatchetConfig defines model for RatchetConfig.
type RatchetConfig struct {
	// AuthLifetime The lifetime (in seconds) of auth tokens for this session.
	// Auth tokens can be refreshed (renewed) using a valid (unexpired)
	// refresh token, but not beyond the session lifetime.
	AuthLifetime *int64 `json:"auth_lifetime,omitempty"`

	// GraceLifetime The amount of time (in seconds) that an auth token for this session remains
	// valid after it has been refreshed and a new auth token has been issued. This
	// helps to address concurrency hazards, for example, if one thread makes requests
	// with auth token while another refreshes it.
	GraceLifetime *int64 `json:"grace_lifetime,omitempty"`

	// RefreshLifetime The lifetime (in seconds) of refresh tokens for this session.
	// If this value is shorter than the session lifetime, inactive sessions
	// will become invalid once the auth and refresh tokens have both expired.
	RefreshLifetime *int64 `json:"refresh_lifetime,omitempty"`

	// SessionLifetime The lifetime (in seconds) of the session.
	// The session cannot be extended beyond its original lifetime.
	SessionLifetime *int64 `json:"session_lifetime,omitempty"`
}

// Receipt Receipt that an MFA request was approved.
type Receipt struct {
	// Confirmation Confirmation code the user needs to present when resuming the original request.
	Confirmation string `json:"confirmation"`

	// FinalApprover The ID of the logged-in user whose action created this approval.
	FinalApprover string `json:"final_approver"`

	// Timestamp DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	Timestamp EpochDateTime `json:"timestamp"`
}

// RefreshGrantType defines model for RefreshGrantType.
type RefreshGrantType string

// Request JSON-RPC request object
type Request struct {
	// Id Request ID
	Id interface{} `json:"id"`

	// Jsonrpc JSON-RPC version.
	Jsonrpc string `json:"jsonrpc"`

	// Method Name of the method to be invoked.
	Method string `json:"method"`

	// Params Parameter values of the request.
	Params interface{} `json:"params"`
}

// RequestOptionsWithHash defines model for RequestOptionsWithHash.
type RequestOptionsWithHash struct {
	// Options The `PublicKeyCredentialRequestOptions` dictionary supplies get() with the
	// data it needs to generate an assertion. Its challenge member MUST be
	// present, while its other members are OPTIONAL.
	//
	// This struct is also used as part of the verification procedure for assertions
	Options PublicKeyCredentialRequestOptions `json:"options"`

	// Preimage A base64url encoding of UTF8 JSON. The data in that JSON is endpoint specific, and describes what this FIDO challenge will be used for.
	//
	// Clients can use `preimage` along with `random_seed` to reconstruct the challenge like so:
	//
	// `challenge = HMAC-SHA256(key=random_seed, message=preimage)`
	Preimage string `json:"preimage"`

	// RandomSeed A random seed that prevents replay attacks
	RandomSeed string `json:"random_seed"`
}

// ResidentKeyRequirement This enumerations values describe the Relying Party's requirements for
// client-side discoverable credentials (formerly known as resident credentials
// or resident keys):
//
// https://www.w3.org/TR/webauthn-2/#enumdef-residentkeyrequirement
type ResidentKeyRequirement string

// Response JSON-RPC response object
type Response struct {
	Error *ErrorObj `json:"error"`

	// Id ID from the corresponding request
	Id interface{} `json:"id"`

	// Jsonrpc Constant "2.0"
	Jsonrpc string `json:"jsonrpc"`

	// Result Result, if success
	Result *map[string]interface{} `json:"result"`
}

// RestrictedActionsMap A map of actions to sets of membership roles
type RestrictedActionsMap map[string][]MemberRole

// RoleAction List of role actions that can be restricted to a set of member roles
type RoleAction string

// RoleInfo defines model for RoleInfo.
type RoleInfo struct {
	Created *EpochDateTime `json:"created"`

	// EditPolicy A policy which governs when and who is allowed to update the entity this policy is
	// attached to (e.g., a role or a key).
	//
	// When attached to a role, by default, this policy applies to role deletion and all
	// role updates (including adding/removing keys and users); in terms of scopes,
	// it applies to `manage:role:update:*` and `manage:role:delete`.
	//
	// When attached to a key, by default, this policy applies to key deletion, all
	// key updates, and adding/removing that key to/from a role; in terms of scopes,
	// it applies to `manage:key:update:*`, `manage:key:delete`, `manage:role:update:key:*`.
	//
	// This default can be changed by setting the `applies_to_scopes` property.
	EditPolicy *EditPolicy `json:"edit_policy,omitempty"`

	// Enabled Whether the role is enabled
	Enabled bool `json:"enabled"`

	// Keys Deprecated The CubeSigner IDs of at most 100 keys associated with this role
	Keys         *[]KeyInRoleInfo `json:"keys"`
	LastModified *EpochDateTime   `json:"last_modified"`

	// Member Whether the current user is a member of the role. This is always true,
	// except for owners who can see roles they are not members of.
	Member bool `json:"member"`

	// Metadata User-defined metadata. When rendering (e.g., in the browser) you should treat
	// it as untrusted user data (and avoid injecting metadata into HTML directly) if
	// untrusted users can create/update keys (or their metadata).
	Metadata interface{} `json:"metadata,omitempty"`

	// Name The human-readable name for the role (must be alphanumeric)
	Name *string `json:"name"`

	// Policy Policy that is checked whenever a key is accessed for signing via this role.
	Policy *[]map[string]interface{} `json:"policy,omitempty"`

	// RestrictedActions A map of actions to sets of membership roles
	RestrictedActions RestrictedActionsMap `json:"restricted_actions"`

	// RoleId The ID of the role
	RoleId string `json:"role_id"`

	// Users Deprecated. The list of at most 100 users with access to the role.
	Users *[]string `json:"users"`

	// Version Version of this object
	Version *int64 `json:"version,omitempty"`
}

// Scope All scopes for accessing CubeSigner APIs
type Scope string

type ScopeType struct {
	union json.RawMessage
}

// ScopeSet A set of scopes.
type ScopeSet struct {
	union json.RawMessage
}

// ScopeSetAll All scopes
type ScopeSetAll string

// ScopeSetAllExcept defines model for ScopeSetAllExcept.
type ScopeSetAllExcept struct {
	// AllExcept All scopes except these (including those transitively implied).
	AllExcept []Scope `json:"AllExcept"`
}

// ScopeSetAllOf defines model for ScopeSetAllOf.
type ScopeSetAllOf struct {
	// AllOf All of these scopes (including those transitively implied).
	AllOf []Scope `json:"AllOf"`
}

// SecondFactorRequirement Represents the number of MFA approvals required for a given operation
// (e.g. login). Can be used to produce a concrete policy for a given user
type SecondFactorRequirement string

// Seconds Duration measured in seconds
// A wrapper type for serialization that encodes a `Duration` as a `u64` representing the number of seconds.
type Seconds = int64

// SecretValue The value of a policy secret.
type SecretValue struct {
	union json.RawMessage
}

// SecretValueObject A secret value encrypted to this organization's Wasm policy.
// Each value is encrypted with its own ephemeral key.
type SecretValueObject struct {
	// ClientPublicKey The client's ephemeral public key used to derive a shared key.
	// This is a base64-encoded, SEC1-encoded P384 public key.
	ClientPublicKey string `json:"client_public_key"`

	// EncryptedValue The encrypted secret value.
	// This is a base64-encoded ciphertext.
	EncryptedValue string `json:"encrypted_value"`

	// Salt A salt value used to derive a shared key for AES-GCM.
	// This is a base64-encoded byte string.
	Salt string `json:"salt"`
}

// SecretValueString A secret value.
// Config values are encrypted in transit and at rest.
type SecretValueString = string

// SessionInfo defines model for SessionInfo.
type SessionInfo struct {
	// Client Client information representing the nature of front-end in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`].
	Client *ClientProfile `json:"client,omitempty"`

	// CreatedBy The id of the user who created the session.
	CreatedBy *string `json:"created_by,omitempty"`

	// Exp Expiration date (in seconds since unix epoch)
	Exp int64 `json:"exp"`

	// Os OS String for backwards compatibility, see os_info instead.
	Os *string `json:"os"`

	// OsInfo OS information set in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`]
	OsInfo *OsInfo `json:"os_info,omitempty"`

	// Purpose A human-readable description for the session
	Purpose string `json:"purpose"`

	// Scopes Lists user permission and access for the session
	Scopes *[]Scope `json:"scopes,omitempty"`

	// SessionId Session ID. Uniquely identifies the session, but cannot be used for auth.
	SessionId string    `json:"session_id"`
	SourceIp  *SourceIp `json:"source_ip,omitempty"`

	// UserAgent User agent that created the session.
	UserAgent *string `json:"user_agent"`
}

// SessionMetadata Collection of attributes related to a Session.
// This is the backend variant of [`ClientSessionMetadata`] and works in tandem with its frontend counterpart.
type SessionMetadata struct {
	// Client Client information representing the nature of front-end in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`].
	Client *ClientProfile `json:"client,omitempty"`

	// CreatedBy The id of the user who created the session.
	CreatedBy *string `json:"created_by,omitempty"`

	// Os OS String for backwards compatibility, see os_info instead.
	Os *string `json:"os"`

	// OsInfo OS information set in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`]
	OsInfo   *OsInfo   `json:"os_info,omitempty"`
	SourceIp *SourceIp `json:"source_ip,omitempty"`

	// UserAgent User agent that created the session.
	UserAgent *string `json:"user_agent"`
}

// SessionsResponse The response from any operation operating on multiple sessions
type SessionsResponse struct {
	// Sessions The list of sessions
	Sessions []SessionInfo `json:"sessions"`
}

// SetPolicySecretRequest A request for setting an Org-level policy secret
type SetPolicySecretRequest struct {
	ImportKey *KeyImportKey `json:"import_key"`

	// Value The value of a policy secret.
	Value SecretValue `json:"value"`
}

// SignDimensions defines model for SignDimensions.
type SignDimensions struct {
	// Operation The sign operation
	Operation string `json:"operation"`

	// OrgId All metrics must include 'org_id' as a dimension.
	OrgId string `json:"org_id"`
}

// SignResponse defines model for SignResponse.
type SignResponse struct {
	// Signature The hex-encoded resulting signature.
	Signature string `json:"signature"`
}

// SignatureVersion defines model for SignatureVersion.
type SignatureVersion string

// SignedMessage defines model for SignedMessage.
type SignedMessage struct {
	// Address The address of the signer, with leading '0x'
	Address string `json:"address"`

	// Id The ID of the request record.
	Id string `json:"id"`

	// Signature The signature, hex encoded, with leading '0x'
	Signature        *string          `json:"signature"`
	SignatureVersion SignatureVersion `json:"signatureVersion"`
	Status           MmiStatus        `json:"status"`
}

// SignerErrorCode defines model for SignerErrorCode.
type SignerErrorCode struct {
	union json.RawMessage
}

// SignerErrorOwnCodes defines model for SignerErrorOwnCodes.
type SignerErrorOwnCodes string

// SiweCompleteRequest Answer to a Sign-in with Ethereum challenge.
type SiweCompleteRequest struct {
	ChallengeId Id `json:"challenge_id"`

	// Signature The hex-encoded EIP-191 signature of the message returned by the corresponding POST ('init') endpoint
	Signature string `json:"signature"`
}

// SiweCompleteResponse Returned upon a successful SIWE authentication.
type SiweCompleteResponse struct {
	// IdToken The OIDC token corresponding to the user with the requested SIWE identity.
	IdToken string `json:"id_token"`
}

// SiweInitRequest Initialize the request to sign in with ethereum. The response will
// contain a SIWE message that the client has to sign and submit via the
// corresponding PATCH endpoint within 5 minutes.
type SiweInitRequest struct {
	// Address The Ethereum address performing the signing conformant to capitalization encoded checksum specified in EIP-55.
	Address string `json:"address"`

	// Domain The RFC 3986 authority that is requesting the signing.
	Domain string `json:"domain"`

	// ExpirationTime The ISO 8601 datetime string that, if present, indicates when the signed authentication message is no longer valid.
	ExpirationTime *string `json:"expiration_time"`

	// NotBefore The ISO 8601 datetime string that, if present, indicates when the signed authentication message will become valid.
	NotBefore *string `json:"not_before"`

	// RequestId A system-specific identifier that may be used to uniquely refer to the sign-in request.
	RequestId *string `json:"request_id"`

	// Resources A list of information or references to information the user wishes to have resolved as part of authentication by the relying party. They are expressed as RFC 3986 URIs separated by "\n- " where \n is the byte 0x0a.
	Resources *[]string `json:"resources,omitempty"`

	// Statement A human-readable ASCII assertion that the user will sign, and it must not contain '\n' (the byte 0x0a).
	Statement *string `json:"statement"`

	// Uri An RFC 3986 URI referring to the resource that is the subject of the signing (as in the subject of a claim).
	Uri string `json:"uri"`
}

// SiweInitResponse A challenge returned in response to a Sign-In with Ethereum request.
//
// Contains a message that the client must sign following EIP-191
// with the requested key in order to complete authentication.
//
// The client has until the message expires (but no more than 5 minutes) to complete the challenge.
type SiweInitResponse struct {
	// ChallengeId The ID of the challenge (to include in the request when calling the PATCH ('complete') endpoint)
	ChallengeId string `json:"challenge_id"`

	// Message The message to sign following the EIP-191 standard.
	Message string `json:"message"`
}

// SolanaSignRequest defines model for SolanaSignRequest.
type SolanaSignRequest struct {
	// MessageBase64 Solana base64-encoded serialized Message
	MessageBase64 string `json:"message_base64"`

	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata interface{} `json:"metadata"`
}

// SolanaTxCmp defines model for SolanaTxCmp.
type SolanaTxCmp struct {
	// IgnoreBlockhash Whether the 'recent_blockhash' property of the Solana transaction is allowed to be different.
	IgnoreBlockhash *bool `json:"ignore_blockhash,omitempty"`
}

// SourceIp defines model for SourceIp.
type SourceIp struct {
	SourceIp string `json:"source_ip"`
}

// StakeRequest defines model for StakeRequest.
type StakeRequest struct {
	// ChainId The chain on which we will deposit
	ChainId int64 `json:"chain_id"`

	// DepositType The type of deposit to perform
	DepositType DepositType `json:"deposit_type"`

	// StakingAmountGwei Optional staking amount in GWEI.
	// If not specified, defaults to 32_000_000_000 (32 ETH).
	// Must be between 1 ETH and 32 ETH.
	// Must not be different from the default value when 'deposit_type' is "Wrapper".
	StakingAmountGwei *int64      `json:"staking_amount_gwei,omitempty"`
	UnsafeConf        *UnsafeConf `json:"unsafe_conf"`

	// ValidatorKey The validator BLS public key to use, or `None` to generate a fresh one.
	ValidatorKey *string `json:"validator_key"`

	// WithdrawalAddr The ethereum address to which withdrawn funds go
	WithdrawalAddr string `json:"withdrawal_addr"`
}

// StakeResponse defines model for StakeResponse.
type StakeResponse struct {
	// CreatedValidatorKeyId The validator key id ("Key#...")
	CreatedValidatorKeyId string `json:"created_validator_key_id"`

	// DepositTx Information produced by a successful deposit
	DepositTx DepositTxn `json:"deposit_tx"`
}

// Status defines model for Status.
type Status struct {
	// AllowedApprovers Users who are allowed to approve. Must be non-empty.
	AllowedApprovers []string `json:"allowed_approvers"`

	// AllowedMfaTypes Allowed approval types. When omitted, defaults to any.
	AllowedMfaTypes *[]MfaType `json:"allowed_mfa_types"`

	// ApprovedBy Users who have already approved
	ApprovedBy map[string]map[string]ApprovalInfo `json:"approved_by"`

	// Count How many users must approve
	Count int32 `json:"count"`

	// NumAuthFactors How many auth factors to require per user
	NumAuthFactors int32 `json:"num_auth_factors"`

	// RequestComparer How to compare HTTP requests when verifying MFA receipt (see [MfaRequest::verify_request])
	RequestComparer *HttpRequestCmp `json:"request_comparer,omitempty"`
}

// SubscriptionStatus The status of a subscription
type SubscriptionStatus string

// SuiChain Supported Sui chains.
type SuiChain string

// SuiSignRequest defines model for SuiSignRequest.
type SuiSignRequest struct {
	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata interface{} `json:"metadata"`

	// Tx Base64-encoding of a BCS-serialized SUI transaction.
	//
	// When using the SUI TypeScript SDK, these bytes
	// are returned by the `Transaction.build()` method.
	Tx string `json:"tx"`
}

// TaprootSignRequest defines model for TaprootSignRequest.
type TaprootSignRequest struct {
	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata interface{}          `json:"metadata"`
	SigKind  TaprootSignatureKind `json:"sig_kind"`
	Tx       BtcTx                `json:"tx"`
}

// TaprootSignatureKind defines model for TaprootSignatureKind.
type TaprootSignatureKind struct {
	// Annex Optional annex, as per BIP341
	Annex *string `json:"annex"`

	// InputIndex Transaction input index
	InputIndex            int                       `json:"input_index"`
	LeafHashCodeSeparator *BtcLeafHashCodeSeparator `json:"leaf_hash_code_separator"`

	// MerkleRoot If this field is not present or null, no tweak is applied. If the field is an
	// empty string, the key is tweaked with an unspendable script path per BIP0341.
	// Otherwise, this field must contain a base-64 string encoding 32 bytes that
	// represent the Merkle root with which to tweak the key before signing.
	MerkleRoot *string `json:"merkle_root"`

	// Prevouts Contains outputs of previous transactions.
	Prevouts PrevOutputs `json:"prevouts"`

	// SighashType Hash type of an input's signature, encoded in the last byte of the signature.
	// Possible values:
	// - SIGHASH_ALL
	// - SIGHASH_ALL|SIGHASH_ANYONECANPAY
	// - SIGHASH_DEFAULT
	// - SIGHASH_NONE
	// - SIGHASH_NONE|SIGHASH_ANYONECANPAY
	// - SIGHASH_SINGLE
	// - SIGHASH_SINGLE|SIGHASH_ANYONECANPAY
	SighashType string `json:"sighash_type"`
}

// TelegramAuthRequest defines model for TelegramAuthRequest.
type TelegramAuthRequest struct {
	// BotId The telegram bot ID
	BotId string `json:"bot_id"`

	// Environment Telegram has two environments: production and test
	// Each one has an associated public key for verifying signatures,
	// and we assign each one a unique OIDC issuer
	Environment TelegramEnvironment `json:"environment"`

	// TgWebAppData The telegram webapp data (found in the `tgWebAppData` parameter encoded in the hash section of the URL)
	TgWebAppData string `json:"tg_web_app_data"`
}

// TelegramAuthResponse defines model for TelegramAuthResponse.
type TelegramAuthResponse struct {
	// IdToken The OIDC token corresponding to this telegram user
	IdToken string `json:"id_token"`
}

// TelegramEnvironment Telegram has two environments: production and test
// Each one has an associated public key for verifying signatures,
// and we assign each one a unique OIDC issuer
type TelegramEnvironment string

// TendermintSignRequest defines model for TendermintSignRequest.
type TendermintSignRequest struct {
	// MessageBase64 The bytes of the protobuf-encoded message to sign as a BASE64 string.
	MessageBase64 string `json:"message_base64"`

	// Metadata Optional metadata. Passing additional information as metadata can be used to make reviewing
	// of pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.
	Metadata interface{} `json:"metadata"`
}

// ThrottleConfig Configuration object for a throttle which limits the number of entities within a given time window
type ThrottleConfig struct {
	// Threshold The number of entities allowed within the window
	Threshold int32 `json:"threshold"`

	// Window Duration measured in seconds
	// A wrapper type for serialization that encodes a `Duration` as a `u64` representing the number of seconds.
	Window Seconds `json:"window"`
}

// TimeoutErrorCode defines model for TimeoutErrorCode.
type TimeoutErrorCode string

// TokenRequest defines model for TokenRequest.
type TokenRequest struct {
	GrantType RefreshGrantType `json:"grant_type"`

	// RefreshToken The refresh token issued to the client.
	RefreshToken string `json:"refresh_token"`
}

// TokenResponse defines model for TokenResponse.
type TokenResponse struct {
	// AccessToken The access token issued by the authorization server.
	AccessToken string `json:"access_token"`

	// ExpiresIn Duration measured in seconds
	// A wrapper type for serialization that encodes a `Duration` as a `u64` representing the number of seconds.
	ExpiresIn Seconds `json:"expires_in"`

	// IdToken An OIDC token issued by Cubist, containing user information
	IdToken *string `json:"id_token"`

	// RefreshToken The refresh token issued by the authorization server.
	RefreshToken *string `json:"refresh_token"`

	// TokenType The type of the token issued. Value is case insensitive.
	TokenType            string                 `json:"token_type"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// TotpApproveRequest defines model for TotpApproveRequest.
type TotpApproveRequest struct {
	// Code TOTP verification code
	Code string `json:"code"`
}

// TotpChallengeAnswer Sent from the client to the server to answer a TOTP challenge
type TotpChallengeAnswer struct {
	// Code The current TOTP code
	Code string `json:"code"`

	// TotpId The ID of the challenge that was returned from the POST endpoint
	TotpId string `json:"totp_id"`
}

// TotpInfo defines model for TotpInfo.
type TotpInfo struct {
	// TotpId The ID of the TOTP challenge.
	TotpId string `json:"totp_id"`

	// TotpUrl Standard TOTP url which includes everything needed to initialize TOTP.
	TotpUrl string `json:"totp_url"`
}

// TotpResetRequest Request to reset TOTP.
type TotpResetRequest struct {
	// Issuer The name of the issuer; defaults to "Cubist".
	Issuer *string `json:"issuer"`
}

// Transaction EIP-2718 typed transaction, including EIP-1559 transactions (`{ "type": "0x02" ... }`), and legacy transactions (`{ "type": "0x00" ... }`). All values in the transaction are expected to be (0x-prefixed or not) hex strings or byte arrays.
type Transaction = TypedTransaction

// TransactionAndStatus defines model for TransactionAndStatus.
type TransactionAndStatus struct {
	// Hash The hash of the transaction that was signed
	Hash *string `json:"hash"`

	// Id The ID of the request record.
	Id string `json:"id"`

	// Nonce The nonce (computed right before signing)
	Nonce *string `json:"nonce"`

	// SignedRawTransaction The signature
	SignedRawTransaction *string   `json:"signedRawTransaction"`
	Status               MmiStatus `json:"status"`
	union                json.RawMessage
}

// TransactionAndStatus0 Legacy (pre EIP-2718) Ethereum transaction type
type TransactionAndStatus0 struct {
	Data     *string `json:"data,omitempty"`
	From     *string `json:"from,omitempty"`
	Gas      *string `json:"gas,omitempty"`
	GasPrice *string `json:"gasPrice,omitempty"`
	Nonce    *string `json:"nonce,omitempty"`
	To       *string `json:"to,omitempty"`
	Type     string  `json:"type"`
	Value    *string `json:"value,omitempty"`
}

// TransactionAndStatus1 EIP-1559 Ethereum transaction type
type TransactionAndStatus1 struct {
	AccessList *[]struct {
		Address     *string   `json:"address,omitempty"`
		StorageKeys *[]string `json:"storageKeys,omitempty"`
	} `json:"accessList,omitempty"`
	Data                 *string `json:"data,omitempty"`
	From                 *string `json:"from,omitempty"`
	Gas                  *string `json:"gas,omitempty"`
	MaxFeePerGas         *string `json:"maxFeePerGas,omitempty"`
	MaxPriorityFeePerGas *string `json:"maxPriorityFeePerGas,omitempty"`
	Nonce                *string `json:"nonce,omitempty"`
	To                   *string `json:"to,omitempty"`
	Type                 string  `json:"type"`
	Value                *string `json:"value,omitempty"`
}

// TsQueryName Supported queries
type TsQueryName string

// TxSignature Information about a signed transaction
type TxSignature struct {
	// Hash Keccak 256 Hash of the RLP encoding of the transaction
	Hash string `json:"hash"`

	// Nonce The nonce (either provided explicitly or computed right before signing)
	Nonce string `json:"nonce"`

	// SignedTx The signed raw transaction
	SignedTx string `json:"signed_tx"`
}

// TxStatus A struct representing the pending message status
type TxStatus struct {
	union json.RawMessage
}

// TxStatusPending defines model for TxStatusPending.
type TxStatusPending struct {
	Status TxStatusPendingStatus `json:"status"`
}

// TxStatusPendingStatus defines model for TxStatusPending.Status.
type TxStatusPendingStatus string

// TxStatusRejected The message has been rejected, including the reason for the rejection.
type TxStatusRejected struct {
	Reason string                 `json:"reason"`
	Status TxStatusRejectedStatus `json:"status"`
}

// TxStatusRejectedStatus defines model for TxStatusRejected.Status.
type TxStatusRejectedStatus string

// TxStatusSigned The message has been signed, including the signature information.
type TxStatusSigned struct {
	// Sig Information about a signed transaction
	Sig struct {
		// Hash Keccak 256 Hash of the RLP encoding of the transaction
		Hash string `json:"hash"`

		// Nonce The nonce (either provided explicitly or computed right before signing)
		Nonce string `json:"nonce"`

		// SignedTx The signed raw transaction
		SignedTx string `json:"signed_tx"`
	} `json:"sig"`
	Status TxStatusSignedStatus `json:"status"`
}

// TxStatusSignedStatus defines model for TxStatusSigned.Status.
type TxStatusSignedStatus string

// TypedData Represents the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) typed data object.
//
// Typed data is a JSON object containing type information, domain separator parameters and the
// message object.
type TypedData struct {
	// Domain Represents the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) EIP712Domain object.
	//
	// EIP712Domain is a JSON object with one or more of the below fields. Protocol designers only need to include the fields that make sense for their signing domain.
	Domain struct {
		// ChainId The EIP-155 chain id. The user-agent should refuse signing if it does not match the
		// currently active chain.
		ChainId *string `json:"chainId"`

		// Name The user readable name of signing domain, i.e., the name of the DApp or the protocol.
		Name *string `json:"name"`

		// Salt A disambiguating salt for the protocol. This can be used as a domain separator of last resort. Can be either a hex-encoded string or byte array
		Salt *TypedDataDomainSalt `json:"salt,omitempty"`

		// VerifyingContract The address of the contract that will verify the signature.
		VerifyingContract *string `json:"verifyingContract"`

		// Version The current major version of the signing domain. Signatures from different versions are not
		// compatible.
		Version *string `json:"version"`
	} `json:"domain"`

	// Message The message to be signed.
	Message map[string]interface{} `json:"message"`

	// PrimaryType The type of the message.
	PrimaryType string `json:"primaryType"`

	// Types The custom types used by this message.
	Types map[string][]struct {
		Name string `json:"name"`
		Type string `json:"type"`
	} `json:"types"`
}

// TypedDataDomainSalt A disambiguating salt for the protocol. This can be used as a domain separator of last resort. Can be either a hex-encoded string or byte array
type TypedDataDomainSalt struct {
	union json.RawMessage
}

// TypedDataArray Byte array of length 32
type TypedDataArray = []float32

// TypedDataString Hex-encoded byte array of length 32
type TypedDataString = string

// TypedTransaction EIP-2718 typed transaction, including EIP-1559 transactions (`{ "type": "0x02" ... }`), and legacy transactions (`{ "type": "0x00" ... }`). All values in the transaction are expected to be (0x-prefixed or not) hex strings or byte arrays.
type TypedTransaction struct {
	union json.RawMessage
}

// TypedTransactionLegacy Legacy (pre EIP-2718) Ethereum transaction type
type TypedTransactionLegacy struct {
	Data     *string `json:"data,omitempty"`
	From     *string `json:"from,omitempty"`
	Gas      *string `json:"gas,omitempty"`
	GasPrice *string `json:"gasPrice,omitempty"`
	Nonce    *string `json:"nonce,omitempty"`
	To       *string `json:"to,omitempty"`
	Type     string  `json:"type"`
	Value    *string `json:"value,omitempty"`
}

// TypedTransactionEip1559 EIP-1559 Ethereum transaction type
type TypedTransactionEip1559 struct {
	AccessList *[]struct {
		Address     *string   `json:"address,omitempty"`
		StorageKeys *[]string `json:"storageKeys,omitempty"`
	} `json:"accessList,omitempty"`
	Data                 *string `json:"data,omitempty"`
	From                 *string `json:"from,omitempty"`
	Gas                  *string `json:"gas,omitempty"`
	MaxFeePerGas         *string `json:"maxFeePerGas,omitempty"`
	MaxPriorityFeePerGas *string `json:"maxPriorityFeePerGas,omitempty"`
	Nonce                *string `json:"nonce,omitempty"`
	To                   *string `json:"to,omitempty"`
	Type                 string  `json:"type"`
	Value                *string `json:"value,omitempty"`
}

// UnauthorizedErrorCode defines model for UnauthorizedErrorCode.
type UnauthorizedErrorCode string

// UnsafeConf Options that should be set only for local devnet testing.
type UnsafeConf struct {
	// DepositContractAddr The hex-encoded address of the deposit contract. If omitted, inferred from `chain_id`
	DepositContractAddr *string `json:"deposit_contract_addr"`

	// GenesisForkVersion The hex-encoded 4-byte fork version
	GenesisForkVersion *string `json:"genesis_fork_version"`
}

// UnstakeRequest Unstake message request.
type UnstakeRequest struct {
	Epoch *Epoch `json:"epoch"`

	// Fork Specifies a fork of the `BeaconChain`, to prevent replay attacks.
	// The schema of `Fork` is defined in the [Beacon chain
	// spec](https://github.com/ethereum/consensus-specs/blob/v1.0.1/specs/phase0/beacon-chain.md#fork).
	Fork Fork `json:"fork"`

	// GenesisData Genesis data as defined in the [Beacon API
	// spec](https://ethereum.github.io/beacon-APIs/#/Beacon/getGenesis).
	// You can get the genesis data from the Beacon node's `/eth/v1/beacon/genesis` end-point.
	// This struct definition is originally from lighthouse's eth2.
	GenesisData GenesisData `json:"genesis_data"`

	// Network Network name ('mainnet', 'holesky')
	Network Network `json:"network"`

	// ValidatorIndex Validator index (`uint64`) to exit. You can get the validator index from the Beacon node's
	// `/eth/v1/beacon/states/head/validators/{pubkey}` end-point. This end point returns an
	// object that contains information about the validator (whose public key is `{pubkey}`),
	// including the validator index. The schema of this end-point is defined
	// [here](https://ethereum.github.io/beacon-APIs/#/Beacon/getStateValidator).
	ValidatorIndex string `json:"validator_index"`
}

// UnstakeResponse Unstake responses are signed voluntary exit messages.
// The schema for this message is defined
// [here](https://github.com/ethereum/consensus-specs/blob/v1.0.1/specs/phase0/beacon-chain.md#signedvoluntaryexit).
// This message can be directly POSTed to the Beacon node's
// `/eth/v1/beacon/pool/voluntary_exits` end-point (see expected schema
// [here](https://ethereum.github.io/beacon-APIs/#/Beacon/submitPoolVoluntaryExit)).
type UnstakeResponse struct {
	// Message An exit voluntarily submitted a validator who wishes to withdraw.
	// The schema for this message is defined
	// [here](https://github.com/ethereum/consensus-specs/blob/v1.0.1/specs/phase0/beacon-chain.md#signedvoluntaryexit).
	Message VoluntaryExit `json:"message"`

	// Signature BLS signature.
	Signature string `json:"signature"`
}

// UpdateContactRequest The information needed to update a Contact.
type UpdateContactRequest struct {
	Addresses  *AddressMap `json:"addresses"`
	EditPolicy *EditPolicy `json:"edit_policy"`

	// Metadata Optional user-defined metadata about the contact.
	Metadata interface{} `json:"metadata"`

	// Name The name for the contact. Must be unique among contacts in the
	// org. Duplicate contact names will be rejected. Name must consist of
	// alphanumeric characters, spaces, `.` and `-`, and cannot be longer than
	// 50 characters.
	Name  *string `json:"name"`
	Owner *Id     `json:"owner"`
}

// UpdateKeyRequest defines model for UpdateKeyRequest.
type UpdateKeyRequest struct {
	EditPolicy *EditPolicy `json:"edit_policy"`

	// Enabled If set, updates the key's `enabled` property to this value.
	// Once disabled, a key cannot be used for signing.
	Enabled *bool `json:"enabled"`

	// Metadata Set this key's metadata. If this value is `null`, the metadata is erased. If the field is
	// missing, the metadata remains unchanged.
	Metadata interface{} `json:"metadata,omitempty"`

	// Owner Specify a user other than themselves to be the (potentially new) owner of the key.
	// The specified owner must be an existing user who is a member of the same org.
	Owner *string `json:"owner"`

	// Policy Set this key's policies. For an existing key, this overwrites all its policies.
	Policy *[]interface{} `json:"policy"`

	// Version If set, updating the metadata only succeeds if the version matches this value.
	Version *int64 `json:"version"`
}

// UpdateOrgRequest defines model for UpdateOrgRequest.
type UpdateOrgRequest struct {
	AlienLoginRequirement *SecondFactorRequirement `json:"alien_login_requirement"`

	// AllowedMfaTypes MFA types that are allowed to be used for implicitly security-sensitive
	// operations (like logging in, adding an MFA factor, exporting keys, etc.).
	AllowedMfaTypes   *map[string][]MfaType `json:"allowed_mfa_types"`
	DefaultInviteKind *InviteKind           `json:"default_invite_kind"`
	EmailPreferences  *EmailPreferences     `json:"email_preferences"`

	// Enabled If set, update this org's `enabled` field to this value.
	Enabled                     *bool                        `json:"enabled"`
	HistoricalDataConfiguration *HistoricalDataConfiguration `json:"historical_data_configuration"`
	IdpConfiguration            *IdpConfig                   `json:"idp_configuration"`
	MemberLoginRequirement      *SecondFactorRequirement     `json:"member_login_requirement"`

	// NotificationEndpoints If set, update this org's notification endpoints. Notification endpoints are expected to be
	// HTTPS URLs, which accept POST requests. The body of the requests sent to these endpoints are
	// are formatted in JSON and have the following format:
	//
	// ```json
	// {
	// "org": "...",
	// "utc_timestamp": "...",
	// "org_event": "...",
	// ...
	// }
	// ```
	//
	// `org` is the org id, `utc_timestamp` is the UTC timestamp of the event in milliseconds, and
	// `org_event` is a string identifying the type of event that has occurred. The rest of the
	// fields provide additional information related to the type of the event.
	//
	// Endpoints can optionally include filters to customize the org events that they are notified
	// about. Currently, the only supported filter type is `OneOf`, which expects a list of org
	// event types to send to the endpoint. If no filter is configured, the system sends all org
	// events to the endpoint.
	NotificationEndpoints *[]NotificationEndpointConfiguration `json:"notification_endpoints"`
	PasskeyConfiguration  *PasskeyConfig                       `json:"passkey_configuration"`

	// Policy If set, update this org's policies (old policies will be overwritten!).
	Policy                    *[]map[string]interface{}  `json:"policy"`
	PolicyEngineConfiguration *PolicyEngineConfiguration `json:"policy_engine_configuration"`

	// RequireScopeCeiling If set, all user logins will require the claim `cubesigner_scope_ceiling` to be present in
	// the user's token. This claim is an array of scopes (e.g. `[ "manage:keys:list", "sign:evm:tx" ]`),
	// which define a maximum set of scopes the user may request. If the user's token does not contain
	// this claim, the login will be rejected.
	//
	// Owners of the org are exempt from this requirement.
	RequireScopeCeiling *bool `json:"require_scope_ceiling"`

	// TotpFailureLimit If set, update this org's TOTP failure limit. After this many failures,
	// the user is rate limited until the next 30-second TOTP window.
	TotpFailureLimit *int32 `json:"totp_failure_limit"`

	// UserExportDelay If set, update this org's user-export delay, i.e., the amount of time
	// (in seconds) between a user's initiating an export and the time when
	// export is allowed. For security, this delay cannot be set to less than
	// 172800, i.e., 2 days.
	UserExportDelay *int64 `json:"user_export_delay"`

	// UserExportDisabled If set, turn this org's user export off (by passing `true`) or on (by passing `false`).
	UserExportDisabled *bool `json:"user_export_disabled"`

	// UserExportWindow If set, update this org's user-export window, i.e., the amount of time
	// (in seconds) that export is allowed after the user-export delay. After
	// this amount of time, the export is canceled and must be re-initiated.
	// For security, this window cannot be set to greater than 259200, i.e.,
	// 3 days.
	UserExportWindow *int64 `json:"user_export_window"`
}

// UpdateOrgResponse defines model for UpdateOrgResponse.
type UpdateOrgResponse struct {
	AlienLoginRequirement *SecondFactorRequirement `json:"alien_login_requirement"`

	// AllowedMfaTypes MFA types that are allowed to be used for implicitly security-sensitive
	// operations (like logging in, adding an MFA factor, exporting keys, etc.).
	AllowedMfaTypes   *map[string][]MfaType `json:"allowed_mfa_types"`
	DefaultInviteKind *InviteKind           `json:"default_invite_kind"`
	EmailPreferences  *EmailPreferences     `json:"email_preferences"`

	// Enabled The new value of the 'enabled' property
	Enabled                     *bool                        `json:"enabled"`
	HistoricalDataConfiguration *HistoricalDataConfiguration `json:"historical_data_configuration"`
	IdpConfiguration            *IdpConfig                   `json:"idp_configuration"`
	MemberLoginRequirement      *SecondFactorRequirement     `json:"member_login_requirement"`

	// Name The new human-readable name for the org (must be alphanumeric)
	Name *string `json:"name"`

	// NotificationEndpoints The new notification endpoint configurations
	NotificationEndpoints *[]NotificationEndpointConfiguration `json:"notification_endpoints"`

	// OrgId The ID of the organization
	OrgId                string         `json:"org_id"`
	PasskeyConfiguration *PasskeyConfig `json:"passkey_configuration"`

	// Policy The new value of org-wide policies
	Policy                    *[]map[string]interface{}  `json:"policy"`
	PolicyEngineConfiguration *PolicyEngineConfiguration `json:"policy_engine_configuration"`

	// RequireScopeCeiling The new value of require_scope_ceiling
	RequireScopeCeiling *bool `json:"require_scope_ceiling"`

	// TotpFailureLimit The new value of the TOTP failure limit
	TotpFailureLimit *int32 `json:"totp_failure_limit"`

	// UserExportDelay The new value of user-export delay
	UserExportDelay *int64 `json:"user_export_delay"`

	// UserExportDisabled The new value of user-export disabled
	UserExportDisabled *bool `json:"user_export_disabled"`

	// UserExportWindow The new value of user-export window
	UserExportWindow *int64 `json:"user_export_window"`
}

// UpdatePolicyRequest Request body for updating a named policy.
type UpdatePolicyRequest struct {
	EditPolicy *EditPolicy `json:"edit_policy"`

	// Metadata A new metadata.
	Metadata interface{} `json:"metadata"`

	// Name A new name for the policy.
	Name *string `json:"name"`

	// Owner A new owner for the policy.
	Owner *string `json:"owner"`

	// Rules New policy rules.
	Rules *[]interface{} `json:"rules"`
}

// UpdatePolicySecretsRequest defines model for UpdatePolicySecretsRequest.
type UpdatePolicySecretsRequest struct {
	EditPolicy *EditPolicy   `json:"edit_policy"`
	ImportKey  *KeyImportKey `json:"import_key"`

	// Secrets The policy secrets.
	Secrets *map[string]SecretValue `json:"secrets"`
}

// UpdateRoleRequest defines model for UpdateRoleRequest.
type UpdateRoleRequest struct {
	EditPolicy *EditPolicy `json:"edit_policy"`

	// Enabled If set, updates the role's `enabled` property to this value.
	// Once disabled, a role cannot be used; and it's tokens cannot be used for signing.
	Enabled *bool `json:"enabled"`

	// Policy If set, update this role's key policies (old policies will be overwritten!).
	// Only "deny" style policies may be set.
	Policy *[]interface{} `json:"policy"`

	// RestrictedActions If set, update this role's settings for restricting which member roles are allowed to
	// perform actions on this role.
	RestrictedActions *map[string][]MemberRole `json:"restricted_actions"`
}

// UpdateUserMembershipRequest Request to update an existing user
type UpdateUserMembershipRequest struct {
	// Disabled Enable or disable user
	Disabled *bool       `json:"disabled"`
	Role     *MemberRole `json:"role"`
}

// UploadObjectHash The SHA-256 hash of the object for an [UploadRequest].
type UploadObjectHash = openapi_types.File

// UploadWasmPolicyRequest Request for uploading a wasm policy
type UploadWasmPolicyRequest struct {
	// Hash The SHA-256 hash of the object for an [UploadRequest].
	Hash UploadObjectHash `json:"hash"`
}

// UploadWasmPolicyResponse The response to a request for uploading a wasm policy
type UploadWasmPolicyResponse struct {
	// SignedUrl A signed URL for uploading the requested wasm policy.
	SignedUrl string `json:"signed_url"`
}

// UserCountDimensions defines model for UserCountDimensions.
type UserCountDimensions struct {
	// Membership User's membership in the org
	Membership string `json:"membership"`

	// OrgId All metrics must include 'org_id' as a dimension.
	OrgId string `json:"org_id"`
}

// UserExportCompleteRequest A request to complete a user export
type UserExportCompleteRequest struct {
	// KeyId The id of the key to be exported. The key-id must correspond to the one in
	// the specified export request, and the caller must own this key.
	KeyId string `json:"key_id"`

	// PublicKey The NIST P-256 public key (base64-encoded SEC1 with or without compression)
	// to which the export will be encrypted. If a public key was provided when
	// `user_export_init` was called, this key must match that one.
	PublicKey string `json:"public_key"`
}

// UserExportCompleteResponse An encrypted user-export
type UserExportCompleteResponse struct {
	// EncryptedKeyMaterial The exported key material, encrypted with AES-256-GCM under a key
	// derived from the public key supplied in the request via HPKE (RFC9180)
	// with DHKEM(P-256, HKDF-SHA256) and base64 encoded.
	EncryptedKeyMaterial string `json:"encrypted_key_material"`

	// EphemeralPublicKey The ephemeral public key used for HPKE key derivation as base64-encoded
	// uncompressed SEC1 serialization.
	EphemeralPublicKey string `json:"ephemeral_public_key"`

	// UserId The user-id to which this key belongs.
	UserId string `json:"user_id"`
}

// UserExportInitRequest A request to initiate a user export
type UserExportInitRequest struct {
	// KeyId The id of the key to be exported. This key must be owned by the caller.
	KeyId string `json:"key_id"`

	// PublicKey An optional NIST P-256 public key (base64-encoded SEC1 with or without
	// compression) to which the export will be encrypted. If provided, this
	// public key MUST be the one used to encrypt the export once the delay has
	// expired. Otherwise, the user can provide any public key when completing
	// the export request post delay.
	//
	// This option may provide extra security when the user has a secure hardware
	// device (e.g., a phone's secure element or a YubiKey) in which a NIST P-256
	// secret key can be generated. Providing the corresponding public key here
	// ensures that only that specific device will be capable of decrypting
	// the export ciphertext.
	//
	// If no secure hardware device is available to store the secret key, this
	// option SHOULD NOT be used because of the risk of secret key theft during
	// the export delay period.
	PublicKey *string `json:"public_key"`
}

// UserExportInitResponse defines model for UserExportInitResponse.
type UserExportInitResponse struct {
	// ExpEpoch DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	ExpEpoch EpochDateTime `json:"exp_epoch"`

	// KeyId The key-id being requested.
	KeyId string `json:"key_id"`

	// OrgId The org-id in which the key is housed.
	OrgId string `json:"org_id"`

	// PublicKeyHash The SHA-256 hash of the public key provided at export initiation,
	// if any. If a key was provided, only that key can be used to complete
	// the export procedure. Otherwise, any key can be used.
	//
	// IMPORTANT: if a public key is supplied at export initiation, it is
	// STRONGLY RECOMMENDED that the corresponding secret key be stored in
	// a secure hardware device, e.g., a YubiKey or a phone's secure element.
	// If no such hardware is available, supplying a public key at export
	// initiation is STRONGLY DISCOURAGED because of the risk of theft during
	// the export delay period.
	//
	// (See also the comment in the `public_key` field of `UserInitRequest`.)
	PublicKeyHash *string `json:"public_key_hash"`

	// ValidEpoch DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	ValidEpoch EpochDateTime `json:"valid_epoch"`
}

// UserExportRequest Pending user-export request as stored in the database.
type UserExportRequest struct {
	// ExpEpoch DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	ExpEpoch EpochDateTime `json:"exp_epoch"`

	// OrgId The org-id in which the key is housed.
	OrgId string `json:"org_id"`

	// PublicKeyHash The SHA-256 hash of the public key provided at export initiation,
	// if any. If a key was provided, only that key can be used to complete
	// the export procedure. Otherwise, any key can be used.
	//
	// IMPORTANT: if a public key is supplied at export initiation, it is
	// STRONGLY RECOMMENDED that the corresponding secret key be stored in
	// a secure hardware device, e.g., a YubiKey or a phone's secure element.
	// If no such hardware is available, supplying a public key at export
	// initiation is STRONGLY DISCOURAGED because of the risk of theft during
	// the export delay period.
	//
	// (See also the comment in the `public_key` field of `UserInitRequest`.)
	PublicKeyHash *string `json:"public_key_hash"`

	// ValidEpoch DateTime measured in seconds since unix epoch.
	// A wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]
	// representing the number of seconds since [`SystemTime::UNIX_EPOCH`].
	ValidEpoch EpochDateTime `json:"valid_epoch"`
}

// UserInOrgInfo defines model for UserInOrgInfo.
type UserInOrgInfo struct {
	// Email The user's email (optional)
	Email *string `json:"email"`

	// Id The id of the user
	Id string `json:"id"`

	// Initialized Whether the user has ever successfully logged in
	Initialized *bool `json:"initialized,omitempty"`

	// Membership Describes whether a user in an org is an Owner or just a regular member
	Membership MemberRole `json:"membership"`

	// Name Optional user name.
	Name          *string          `json:"name"`
	Status        MembershipStatus `json:"status"`
	VerifiedEmail *VerifiedEmail   `json:"verified_email"`
}

// UserInOrgInfoWithIdentity defines model for UserInOrgInfoWithIdentity.
type UserInOrgInfoWithIdentity struct {
	// Email The user's email (optional)
	Email *string `json:"email"`

	// Id The id of the user
	Id string `json:"id"`

	// Identities Optional third-party identities via which the user was found
	Identities *[]IdentityInfo `json:"identities,omitempty"`

	// Initialized Whether the user has ever successfully logged in
	Initialized *bool `json:"initialized,omitempty"`

	// Membership Describes whether a user in an org is an Owner or just a regular member
	Membership MemberRole `json:"membership"`

	// Name Optional user name.
	Name          *string          `json:"name"`
	Status        MembershipStatus `json:"status"`
	VerifiedEmail *VerifiedEmail   `json:"verified_email"`
}

// UserInOrgMembership Information about a user's membership in an organization
// (without including any info about the user)
type UserInOrgMembership struct {
	// Membership Describes whether a user in an org is an Owner or just a regular member
	Membership MemberRole `json:"membership"`

	// OrgId Organization id
	OrgId  string           `json:"org_id"`
	Status MembershipStatus `json:"status"`
}

// UserInRoleInfo defines model for UserInRoleInfo.
type UserInRoleInfo struct {
	UserId string `json:"user_id"`
}

// UserInfo defines model for UserInfo.
type UserInfo struct {
	// Email Optional email
	Email *string `json:"email"`

	// Mfa All multi-factor authentication methods configured for this user
	Mfa       []ConfiguredMfa `json:"mfa"`
	MfaPolicy *MfaPolicy      `json:"mfa_policy"`

	// Name Optional name
	Name *string `json:"name"`

	// OrgIds All organizations the user belongs to. Deprecated in favor of 'orgs'.
	// Deprecated:
	OrgIds []string `json:"org_ids"`

	// Orgs All organizations the user belongs to, including the membership role in each.
	Orgs []UserInOrgMembership `json:"orgs"`

	// UserId The id of the currently logged in user
	UserId        string         `json:"user_id"`
	VerifiedEmail *VerifiedEmail `json:"verified_email"`
}

// UserOrgsResponse The response to the user/orgs endpoint
type UserOrgsResponse struct {
	// Orgs The list of orgs this user is a member of
	Orgs []OrgData `json:"orgs"`
}

// UserVerificationRequirement A WebAuthn Relying Party may require user verification for some of its
// operations but not for others, and may use this type to express its needs.
//
// https://www.w3.org/TR/webauthn-2/#enum-userVerificationRequirement
type UserVerificationRequirement string

// VerifiedEmail defines model for VerifiedEmail.
type VerifiedEmail struct {
	// Email Email address
	Email string `json:"email"`

	// UpdatedAt Last time this record was updated (in seconds since unix epoch)
	UpdatedAt int64 `json:"updated_at"`
}

// VoluntaryExit An exit voluntarily submitted a validator who wishes to withdraw.
// The schema for this message is defined
// [here](https://github.com/ethereum/consensus-specs/blob/v1.0.1/specs/phase0/beacon-chain.md#signedvoluntaryexit).
type VoluntaryExit struct {
	// Epoch Epoch is a quoted `uint64`.
	Epoch Epoch `json:"epoch"`

	// ValidatorIndex Index of the exiting validator.
	ValidatorIndex string `json:"validator_index"`
}

// WasmPolicyResponse The response from invoking a Wasm policy.
type WasmPolicyResponse struct {
	union json.RawMessage
}

// WasmPolicyResponseAllow defines model for WasmPolicyResponseAllow.
type WasmPolicyResponseAllow struct {
	Response WasmPolicyResponseAllowResponse `json:"response"`
}

// WasmPolicyResponseAllowResponse defines model for WasmPolicyResponseAllow.Response.
type WasmPolicyResponseAllowResponse string

// WasmPolicyResponseDeny The policy denied signing the transaction.
type WasmPolicyResponseDeny struct {
	// Reason The reason for the denial.
	Reason   string                         `json:"reason"`
	Response WasmPolicyResponseDenyResponse `json:"response"`
}

// WasmPolicyResponseDenyResponse defines model for WasmPolicyResponseDeny.Response.
type WasmPolicyResponseDenyResponse string

// WasmPolicyResponseError The policy failed to execute successfully, and exited with an error.
type WasmPolicyResponseError struct {
	// Error The error from the Policy Engine.
	Error    string                          `json:"error"`
	Response WasmPolicyResponseErrorResponse `json:"response"`
}

// WasmPolicyResponseErrorResponse defines model for WasmPolicyResponseError.Response.
type WasmPolicyResponseErrorResponse string

// WasmRule A wasm policy rule that can be executed in the wasm engine.
type WasmRule struct {
	// Hash The SHA-256 hash of a wasm policy that can be used to look it up in the policy store.
	Hash string `json:"hash"`

	// PolicyId The Id of the policy this wasm rule belongs to.
	PolicyId string `json:"policy_id"`
}

// WebhookMethod Allowed webhook methods
type WebhookMethod string

// WebhookPayload The payload that is sent to the webhook.
//
// The webhook should respond with HTTP status code 200 if the operation is permitted.
//
// All non-200 status codes imply that the operation is denied; any response body returned
// by the webhook will be included in the error response sent back to the client.
type WebhookPayload struct {
	// KeyAddress The address (material id) of the key used to sign the request
	KeyAddress string  `json:"key_address"`
	KeyType    KeyType `json:"key_type"`

	// Operation All different kinds of sensitive operations
	Operation OperationKind `json:"operation"`

	// Request The payload (if any) of the sign operation
	Request interface{} `json:"request"`
}

// WebhookPolicyParams Parameters for the [Deny::Webhook] policy.
type WebhookPolicyParams struct {
	// Headers Optional HTTP headers to set
	Headers *map[string]string `json:"headers,omitempty"`

	// Method Optional HTTP method to use. Defaults to POST.
	Method *string `json:"method,omitempty"`

	// RestrictedOperations CubeSigner operations to which this policy should apply.
	// When omitted, applies to all operations.
	RestrictedOperations *[]OperationKind `json:"restricted_operations"`

	// Timeout Request execution timeout in seconds; must not exceed 5 seconds.
	Timeout *int64 `json:"timeout,omitempty"`

	// Url The url of the webhook
	Url string `json:"url"`
}

// EmailMyOrgsParams defines parameters for EmailMyOrgs.
type EmailMyOrgsParams struct {
	// Email The email of the user
	Email string `form:"email" json:"email"`
}

// SentryApiCallPublicTextBody defines parameters for SentryApiCallPublic.
type SentryApiCallPublicTextBody = string

// ListContactsParams defines parameters for ListContacts.
type ListContactsParams struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `form:"page.size,omitempty" json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `form:"page.start,omitempty" json:"page.start,omitempty"`
}

// ConfigureEmailParamsPurpose defines parameters for ConfigureEmail.
type ConfigureEmailParamsPurpose string

// SentryApiCallTextBody defines parameters for SentryApiCall.
type SentryApiCallTextBody = string

// ListKeysInOrgParams defines parameters for ListKeysInOrg.
type ListKeysInOrgParams struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `form:"page.size,omitempty" json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `form:"page.start,omitempty" json:"page.start,omitempty"`

	// KeyType Filter by key type
	KeyType *KeyType `form:"key_type,omitempty" json:"key_type,omitempty"`

	// KeyOwner Filter by key owner
	KeyOwner *Id `form:"key_owner,omitempty" json:"key_owner,omitempty"`

	// Search Search key metadata
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// ListKeyRolesParams defines parameters for ListKeyRoles.
type ListKeyRolesParams struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `form:"page.size,omitempty" json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `form:"page.start,omitempty" json:"page.start,omitempty"`
}

// ListHistoricalKeyTxParams defines parameters for ListHistoricalKeyTx.
type ListHistoricalKeyTxParams struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `form:"page.size,omitempty" json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `form:"page.start,omitempty" json:"page.start,omitempty"`
}

// QueryMetricsParams defines parameters for QueryMetrics.
type QueryMetricsParams struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `form:"page.size,omitempty" json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `form:"page.start,omitempty" json:"page.start,omitempty"`
}

// MfaVoteCsParams defines parameters for MfaVoteCs.
type MfaVoteCsParams struct {
	MfaVote *MfaVote `form:"mfa_vote,omitempty" json:"mfa_vote,omitempty"`
}

// MfaEmailInitParams defines parameters for MfaEmailInit.
type MfaEmailInitParams struct {
	MfaVote *MfaVote `form:"mfa_vote,omitempty" json:"mfa_vote,omitempty"`
}

// MfaVoteFidoCompleteParams defines parameters for MfaVoteFidoComplete.
type MfaVoteFidoCompleteParams struct {
	MfaVote *MfaVote `form:"mfa_vote,omitempty" json:"mfa_vote,omitempty"`
}

// MfaVoteTotpParams defines parameters for MfaVoteTotp.
type MfaVoteTotpParams struct {
	MfaVote *MfaVote `form:"mfa_vote,omitempty" json:"mfa_vote,omitempty"`
}

// MmiMessageRejectJSONBody defines parameters for MmiMessageReject.
type MmiMessageRejectJSONBody = MmiRejectRequest

// Oauth2TwitterJSONBody defines parameters for Oauth2Twitter.
type Oauth2TwitterJSONBody map[string]string

// ListPoliciesParams defines parameters for ListPolicies.
type ListPoliciesParams struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `form:"page.size,omitempty" json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `form:"page.start,omitempty" json:"page.start,omitempty"`
}

// GetPolicyLogsParams defines parameters for GetPolicyLogs.
type GetPolicyLogsParams struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `form:"page.size,omitempty" json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `form:"page.start,omitempty" json:"page.start,omitempty"`
}

// ListRolesParams defines parameters for ListRoles.
type ListRolesParams struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `form:"page.size,omitempty" json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `form:"page.start,omitempty" json:"page.start,omitempty"`

	// Summarize Don't include keys and users for each role
	Summarize *bool `form:"summarize,omitempty" json:"summarize,omitempty"`
}

// CreateRoleJSONBody defines parameters for CreateRole.
type CreateRoleJSONBody = CreateRoleRequest

// ListRoleKeysParams defines parameters for ListRoleKeys.
type ListRoleKeysParams struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `form:"page.size,omitempty" json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `form:"page.start,omitempty" json:"page.start,omitempty"`
}

// GetRoleKeyParams defines parameters for GetRoleKey.
type GetRoleKeyParams struct {
	// Details Whether to include detailed key information
	Details *bool `form:"details,omitempty" json:"details,omitempty"`
}

// ListHistoricalRoleTxParams defines parameters for ListHistoricalRoleTx.
type ListHistoricalRoleTxParams struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `form:"page.size,omitempty" json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `form:"page.start,omitempty" json:"page.start,omitempty"`
}

// ListRoleUsersParams defines parameters for ListRoleUsers.
type ListRoleUsersParams struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `form:"page.size,omitempty" json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `form:"page.start,omitempty" json:"page.start,omitempty"`
}

// RevokeSessionsParams defines parameters for RevokeSessions.
type RevokeSessionsParams struct {
	// Role If provided, the name or ID of a role to operate on.
	// Cannot be specified together with `user`.
	Role *string `form:"role,omitempty" json:"role,omitempty"`

	// User If provided, the ID of a user to operate on.
	// Cannot be specified together with `role`.
	User *string `form:"user,omitempty" json:"user,omitempty"`
}

// ListSessionsParams defines parameters for ListSessions.
type ListSessionsParams struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `form:"page.size,omitempty" json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `form:"page.start,omitempty" json:"page.start,omitempty"`

	// Role If provided, the name or ID of a role to operate on.
	// Cannot be specified together with `user`.
	Role *string `form:"role,omitempty" json:"role,omitempty"`

	// User If provided, the ID of a user to operate on.
	// Cannot be specified together with `role`.
	User *string `form:"user,omitempty" json:"user,omitempty"`
}

// UserExportDeleteParams defines parameters for UserExportDelete.
type UserExportDeleteParams struct {
	// KeyId The key-id whose export request should be deleted
	KeyId string `form:"key_id" json:"key_id"`

	// UserId The user-id who owns this request. If omitted, defaults to the current user.
	// Only the org owner may delete user-export requests for another user.
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`
}

// UserExportListParams defines parameters for UserExportList.
type UserExportListParams struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `form:"page.size,omitempty" json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `form:"page.start,omitempty" json:"page.start,omitempty"`

	// UserId If provided, the user-id whose user-export requests to list. Defaults to the
	// current user. Only the org owner may list requests for another user.
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`

	// KeyId If provided, the key-id for which to list an existing user-export request.
	KeyId *string `form:"key_id,omitempty" json:"key_id,omitempty"`
}

// UserResetTotpInitJSONBody defines parameters for UserResetTotpInit.
type UserResetTotpInitJSONBody = TotpResetRequest

// ListUsersInOrgParams defines parameters for ListUsersInOrg.
type ListUsersInOrgParams struct {
	// PageSize Max number of items to return per page.
	//
	// If the actual number of returned items may be less that this, even if there exist more
	// data in the result set. To reliably determine if more data is left in the result set,
	// inspect the [UnencryptedLastEvalKey] value in the response object.
	PageSize *int32 `form:"page.size,omitempty" json:"page.size,omitempty"`

	// PageStart The start of the page. Omit to start from the beginning; otherwise, only specify a
	// the exact value previously returned as 'last_evaluated_key' from the same endpoint.
	PageStart *string `form:"page.start,omitempty" json:"page.start,omitempty"`

	// Q A query string. If defined, all returned users will contain this string in their name or email.
	Q *string `form:"q,omitempty" json:"q,omitempty"`
}

// PolicyExecuteJSONBody defines parameters for PolicyExecute.
type PolicyExecuteJSONBody = map[string]interface{}

// ResetTotpInitLegacyJSONBody defines parameters for ResetTotpInitLegacy.
type ResetTotpInitLegacyJSONBody = TotpResetRequest

// Cube3signerHeartbeatJSONBody defines parameters for Cube3signerHeartbeat.
type Cube3signerHeartbeatJSONBody = HeartbeatRequest

// SentryApiCallPublicTextRequestBody defines body for SentryApiCallPublic for text/plain ContentType.
type SentryApiCallPublicTextRequestBody = SentryApiCallPublicTextBody

// MmiJSONRequestBody defines body for Mmi for application/json ContentType.
type MmiJSONRequestBody = Request

// Oauth2TokenRefreshJSONRequestBody defines body for Oauth2TokenRefresh for application/json ContentType.
type Oauth2TokenRefreshJSONRequestBody = TokenRequest

// UpdateOrgJSONRequestBody defines body for UpdateOrg for application/json ContentType.
type UpdateOrgJSONRequestBody = UpdateOrgRequest

// AuthMigrationIdentityAddJSONRequestBody defines body for AuthMigrationIdentityAdd for application/json ContentType.
type AuthMigrationIdentityAddJSONRequestBody = MigrateIdentityRequest

// AuthMigrationIdentityRemoveJSONRequestBody defines body for AuthMigrationIdentityRemove for application/json ContentType.
type AuthMigrationIdentityRemoveJSONRequestBody = MigrateIdentityRequest

// AuthMigrationUserUpdateJSONRequestBody defines body for AuthMigrationUserUpdate for application/json ContentType.
type AuthMigrationUserUpdateJSONRequestBody = MigrateUpdateUsersRequest

// AvaSerializedTxSignJSONRequestBody defines body for AvaSerializedTxSign for application/json ContentType.
type AvaSerializedTxSignJSONRequestBody = AvaSerializedTxSignRequest

// AvaSignJSONRequestBody defines body for AvaSign for application/json ContentType.
type AvaSignJSONRequestBody = AvaSignRequest

// BabylonCovSignJSONRequestBody defines body for BabylonCovSign for application/json ContentType.
type BabylonCovSignJSONRequestBody = BabylonCovSignRequest

// CreateEotsNoncesJSONRequestBody defines body for CreateEotsNonces for application/json ContentType.
type CreateEotsNoncesJSONRequestBody = EotsCreateNonceRequest

// EotsSignJSONRequestBody defines body for EotsSign for application/json ContentType.
type EotsSignJSONRequestBody = EotsSignRequest

// BabylonRegistrationJSONRequestBody defines body for BabylonRegistration for application/json ContentType.
type BabylonRegistrationJSONRequestBody = BabylonRegistrationRequest

// BabylonStakingJSONRequestBody defines body for BabylonStaking for application/json ContentType.
type BabylonStakingJSONRequestBody = BabylonStakingRequest

// BtcMessageSignJSONRequestBody defines body for BtcMessageSign for application/json ContentType.
type BtcMessageSignJSONRequestBody = BtcMessageSignRequest

// PsbtSignJSONRequestBody defines body for PsbtSign for application/json ContentType.
type PsbtSignJSONRequestBody = PsbtSignRequest

// BtcSignJSONRequestBody defines body for BtcSign for application/json ContentType.
type BtcSignJSONRequestBody = BtcSignRequest

// BtcTaprootSignJSONRequestBody defines body for BtcTaprootSign for application/json ContentType.
type BtcTaprootSignJSONRequestBody = TaprootSignRequest

// CreateContactJSONRequestBody defines body for CreateContact for application/json ContentType.
type CreateContactJSONRequestBody = CreateContactRequest

// DeleteContactJSONRequestBody defines body for DeleteContact for application/json ContentType.
type DeleteContactJSONRequestBody = Empty

// UpdateContactJSONRequestBody defines body for UpdateContact for application/json ContentType.
type UpdateContactJSONRequestBody = UpdateContactRequest

// DeriveKeyLegacyJSONRequestBody defines body for DeriveKeyLegacy for application/json ContentType.
type DeriveKeyLegacyJSONRequestBody = DeriveKeyRequest

// DeriveKeyJSONRequestBody defines body for DeriveKey for application/json ContentType.
type DeriveKeyJSONRequestBody = DeriveKeysRequest

// DiffieHellmanExchangeJSONRequestBody defines body for DiffieHellmanExchange for application/json ContentType.
type DiffieHellmanExchangeJSONRequestBody = DiffieHellmanRequest

// ConfigureEmailJSONRequestBody defines body for ConfigureEmail for application/json ContentType.
type ConfigureEmailJSONRequestBody = ConfigureEmailRequest

// Eip191SignJSONRequestBody defines body for Eip191Sign for application/json ContentType.
type Eip191SignJSONRequestBody = Eip191SignRequest

// Eip712SignJSONRequestBody defines body for Eip712Sign for application/json ContentType.
type Eip712SignJSONRequestBody = Eip712SignRequest

// RemoveOidcIdentityJSONRequestBody defines body for RemoveOidcIdentity for application/json ContentType.
type RemoveOidcIdentityJSONRequestBody = OidcIdentity

// AddOidcIdentityJSONRequestBody defines body for AddOidcIdentity for application/json ContentType.
type AddOidcIdentityJSONRequestBody = AddIdentityRequest

// VerifyProofJSONRequestBody defines body for VerifyProof for application/json ContentType.
type VerifyProofJSONRequestBody = IdentityProof

// IdpAuthenticateJSONRequestBody defines body for IdpAuthenticate for application/json ContentType.
type IdpAuthenticateJSONRequestBody = AuthenticationRequest

// IdpPasswordResetConfirmJSONRequestBody defines body for IdpPasswordResetConfirm for application/json ContentType.
type IdpPasswordResetConfirmJSONRequestBody = PasswordResetConfirmRequest

// IdpPasswordResetRequestJSONRequestBody defines body for IdpPasswordResetRequest for application/json ContentType.
type IdpPasswordResetRequestJSONRequestBody = PasswordResetRequest

// ImportKeyJSONRequestBody defines body for ImportKey for application/json ContentType.
type ImportKeyJSONRequestBody = ImportKeyRequest

// EsploraApiCallJSONRequestBody defines body for EsploraApiCall for application/json ContentType.
type EsploraApiCallJSONRequestBody = EsploraRequest

// SentryApiCallTextRequestBody defines body for SentryApiCall for text/plain ContentType.
type SentryApiCallTextRequestBody = SentryApiCallTextBody

// InvitationAcceptJSONRequestBody defines body for InvitationAccept for application/json ContentType.
type InvitationAcceptJSONRequestBody = InvitationAcceptRequest

// InviteJSONRequestBody defines body for Invite for application/json ContentType.
type InviteJSONRequestBody = InviteRequest

// CreateKeyJSONRequestBody defines body for CreateKey for application/json ContentType.
type CreateKeyJSONRequestBody = CreateKeyRequest

// DeleteKeyJSONRequestBody defines body for DeleteKey for application/json ContentType.
type DeleteKeyJSONRequestBody = Empty

// UpdateKeyJSONRequestBody defines body for UpdateKey for application/json ContentType.
type UpdateKeyJSONRequestBody = UpdateKeyRequest

// QueryMetricsJSONRequestBody defines body for QueryMetrics for application/json ContentType.
type QueryMetricsJSONRequestBody = QueryMetricsRequest

// MfaVoteEmailCompleteJSONRequestBody defines body for MfaVoteEmailComplete for application/json ContentType.
type MfaVoteEmailCompleteJSONRequestBody = EmailOtpAnswer

// MfaVoteFidoCompleteJSONRequestBody defines body for MfaVoteFidoComplete for application/json ContentType.
type MfaVoteFidoCompleteJSONRequestBody = FidoAssertAnswer

// MfaVoteTotpJSONRequestBody defines body for MfaVoteTotp for application/json ContentType.
type MfaVoteTotpJSONRequestBody = TotpApproveRequest

// MmiMessageRejectJSONRequestBody defines body for MmiMessageReject for application/json ContentType.
type MmiMessageRejectJSONRequestBody = MmiMessageRejectJSONBody

// MmiMessageSignJSONRequestBody defines body for MmiMessageSign for application/json ContentType.
type MmiMessageSignJSONRequestBody = PendingMessageInfo

// Oauth2TwitterJSONRequestBody defines body for Oauth2Twitter for application/json ContentType.
type Oauth2TwitterJSONRequestBody Oauth2TwitterJSONBody

// OidcAuthJSONRequestBody defines body for OidcAuth for application/json ContentType.
type OidcAuthJSONRequestBody = OidcLoginRequest

// EmailOtpAuthJSONRequestBody defines body for EmailOtpAuth for application/json ContentType.
type EmailOtpAuthJSONRequestBody = EmailOtpRequest

// SiweCompleteJSONRequestBody defines body for SiweComplete for application/json ContentType.
type SiweCompleteJSONRequestBody = SiweCompleteRequest

// SiweInitJSONRequestBody defines body for SiweInit for application/json ContentType.
type SiweInitJSONRequestBody = SiweInitRequest

// TelegramAuthJSONRequestBody defines body for TelegramAuth for application/json ContentType.
type TelegramAuthJSONRequestBody = TelegramAuthRequest

// CreateOrgJSONRequestBody defines body for CreateOrg for application/json ContentType.
type CreateOrgJSONRequestBody = CreateOrgRequest

// CreatePolicyJSONRequestBody defines body for CreatePolicy for application/json ContentType.
type CreatePolicyJSONRequestBody = CreatePolicyRequest

// DeletePolicyJSONRequestBody defines body for DeletePolicy for application/json ContentType.
type DeletePolicyJSONRequestBody = Empty

// UpdatePolicyJSONRequestBody defines body for UpdatePolicy for application/json ContentType.
type UpdatePolicyJSONRequestBody = UpdatePolicyRequest

// GetPolicyLogsJSONRequestBody defines body for GetPolicyLogs for application/json ContentType.
type GetPolicyLogsJSONRequestBody = PolicyLogsRequest

// InvokePolicyJSONRequestBody defines body for InvokePolicy for application/json ContentType.
type InvokePolicyJSONRequestBody = InvokePolicyRequest

// UpdatePolicySecretsJSONRequestBody defines body for UpdatePolicySecrets for application/json ContentType.
type UpdatePolicySecretsJSONRequestBody = UpdatePolicySecretsRequest

// DeletePolicySecretJSONRequestBody defines body for DeletePolicySecret for application/json ContentType.
type DeletePolicySecretJSONRequestBody = Empty

// SetPolicySecretJSONRequestBody defines body for SetPolicySecret for application/json ContentType.
type SetPolicySecretJSONRequestBody = SetPolicySecretRequest

// UploadWasmPolicyJSONRequestBody defines body for UploadWasmPolicy for application/json ContentType.
type UploadWasmPolicyJSONRequestBody = UploadWasmPolicyRequest

// CreateRoleJSONRequestBody defines body for CreateRole for application/json ContentType.
type CreateRoleJSONRequestBody = CreateRoleJSONBody

// DeleteRoleJSONRequestBody defines body for DeleteRole for application/json ContentType.
type DeleteRoleJSONRequestBody = Empty

// UpdateRoleJSONRequestBody defines body for UpdateRole for application/json ContentType.
type UpdateRoleJSONRequestBody = UpdateRoleRequest

// AddKeysToRoleJSONRequestBody defines body for AddKeysToRole for application/json ContentType.
type AddKeysToRoleJSONRequestBody = AddKeysToRoleRequest

// AddUserToRoleJSONRequestBody defines body for AddUserToRole for application/json ContentType.
type AddUserToRoleJSONRequestBody = Empty

// RemoveKeyFromRoleJSONRequestBody defines body for RemoveKeyFromRole for application/json ContentType.
type RemoveKeyFromRoleJSONRequestBody = Empty

// CreateRoleTokenJSONRequestBody defines body for CreateRoleToken for application/json ContentType.
type CreateRoleTokenJSONRequestBody = CreateTokenRequest

// RemoveUserFromRoleJSONRequestBody defines body for RemoveUserFromRole for application/json ContentType.
type RemoveUserFromRoleJSONRequestBody = Empty

// CreateSessionJSONRequestBody defines body for CreateSession for application/json ContentType.
type CreateSessionJSONRequestBody = CreateSessionRequest

// SolanaSignJSONRequestBody defines body for SolanaSign for application/json ContentType.
type SolanaSignJSONRequestBody = SolanaSignRequest

// SuiSignJSONRequestBody defines body for SuiSign for application/json ContentType.
type SuiSignJSONRequestBody = SuiSignRequest

// TendermintSignJSONRequestBody defines body for TendermintSign for application/json ContentType.
type TendermintSignJSONRequestBody = TendermintSignRequest

// UserResetEmailCompleteJSONRequestBody defines body for UserResetEmailComplete for application/json ContentType.
type UserResetEmailCompleteJSONRequestBody = EmailOtpAnswer

// UserResetEmailInitJSONRequestBody defines body for UserResetEmailInit for application/json ContentType.
type UserResetEmailInitJSONRequestBody = EmailResetRequest

// UserExportCompleteJSONRequestBody defines body for UserExportComplete for application/json ContentType.
type UserExportCompleteJSONRequestBody = UserExportCompleteRequest

// UserExportInitJSONRequestBody defines body for UserExportInit for application/json ContentType.
type UserExportInitJSONRequestBody = UserExportInitRequest

// UserRegisterFidoCompleteJSONRequestBody defines body for UserRegisterFidoComplete for application/json ContentType.
type UserRegisterFidoCompleteJSONRequestBody = FidoCreateChallengeAnswer

// UserRegisterFidoInitJSONRequestBody defines body for UserRegisterFidoInit for application/json ContentType.
type UserRegisterFidoInitJSONRequestBody = FidoCreateRequest

// UserDeleteFidoJSONRequestBody defines body for UserDeleteFido for application/json ContentType.
type UserDeleteFidoJSONRequestBody = Empty

// UserDeleteTotpJSONRequestBody defines body for UserDeleteTotp for application/json ContentType.
type UserDeleteTotpJSONRequestBody = Empty

// UserResetTotpCompleteJSONRequestBody defines body for UserResetTotpComplete for application/json ContentType.
type UserResetTotpCompleteJSONRequestBody = TotpChallengeAnswer

// UserResetTotpInitJSONRequestBody defines body for UserResetTotpInit for application/json ContentType.
type UserResetTotpInitJSONRequestBody = UserResetTotpInitJSONBody

// UserVerifyTotpJSONRequestBody defines body for UserVerifyTotp for application/json ContentType.
type UserVerifyTotpJSONRequestBody = TotpApproveRequest

// CreateOidcUserJSONRequestBody defines body for CreateOidcUser for application/json ContentType.
type CreateOidcUserJSONRequestBody = AddThirdPartyUserRequest

// DeleteOidcUserJSONRequestBody defines body for DeleteOidcUser for application/json ContentType.
type DeleteOidcUserJSONRequestBody = OidcIdentity

// CompleteResetMemberMfaJSONRequestBody defines body for CompleteResetMemberMfa for application/json ContentType.
type CompleteResetMemberMfaJSONRequestBody = CompleteMfaResetRequest

// ResetMemberMfaJSONRequestBody defines body for ResetMemberMfa for application/json ContentType.
type ResetMemberMfaJSONRequestBody = MfaResetRequest

// UpdateUserMembershipJSONRequestBody defines body for UpdateUserMembership for application/json ContentType.
type UpdateUserMembershipJSONRequestBody = UpdateUserMembershipRequest

// PasskeyAuthCompleteJSONRequestBody defines body for PasskeyAuthComplete for application/json ContentType.
type PasskeyAuthCompleteJSONRequestBody = PasskeyAssertAnswer

// PasskeyAuthInitJSONRequestBody defines body for PasskeyAuthInit for application/json ContentType.
type PasskeyAuthInitJSONRequestBody = LoginRequest

// PolicyExecuteJSONRequestBody defines body for PolicyExecute for application/json ContentType.
type PolicyExecuteJSONRequestBody = PolicyExecuteJSONBody

// RegisterFidoCompleteLegacyJSONRequestBody defines body for RegisterFidoCompleteLegacy for application/json ContentType.
type RegisterFidoCompleteLegacyJSONRequestBody = FidoCreateChallengeAnswer

// RegisterFidoInitLegacyJSONRequestBody defines body for RegisterFidoInitLegacy for application/json ContentType.
type RegisterFidoInitLegacyJSONRequestBody = FidoCreateRequest

// ResetTotpCompleteLegacyJSONRequestBody defines body for ResetTotpCompleteLegacy for application/json ContentType.
type ResetTotpCompleteLegacyJSONRequestBody = TotpChallengeAnswer

// ResetTotpInitLegacyJSONRequestBody defines body for ResetTotpInitLegacy for application/json ContentType.
type ResetTotpInitLegacyJSONRequestBody = ResetTotpInitLegacyJSONBody

// VerifyTotpLegacyJSONRequestBody defines body for VerifyTotpLegacy for application/json ContentType.
type VerifyTotpLegacyJSONRequestBody = TotpApproveRequest

// BlobSignJSONRequestBody defines body for BlobSign for application/json ContentType.
type BlobSignJSONRequestBody = BlobSignRequest

// Cube3signerHeartbeatJSONRequestBody defines body for Cube3signerHeartbeat for application/json ContentType.
type Cube3signerHeartbeatJSONRequestBody = Cube3signerHeartbeatJSONBody

// Eth1SignJSONRequestBody defines body for Eth1Sign for application/json ContentType.
type Eth1SignJSONRequestBody = Eth1SignRequest

// Eth2SignJSONRequestBody defines body for Eth2Sign for application/json ContentType.
type Eth2SignJSONRequestBody = Eth2SignRequest

// StakeJSONRequestBody defines body for Stake for application/json ContentType.
type StakeJSONRequestBody = StakeRequest

// UnstakeJSONRequestBody defines body for Unstake for application/json ContentType.
type UnstakeJSONRequestBody = UnstakeRequest

// SignerSessionRefreshJSONRequestBody defines body for SignerSessionRefresh for application/json ContentType.
type SignerSessionRefreshJSONRequestBody = AuthData

// Getter for additional properties for TokenResponse. Returns the specified
// element and whether it was found
func (a TokenResponse) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TokenResponse
func (a *TokenResponse) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TokenResponse to handle AdditionalProperties
func (a *TokenResponse) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["access_token"]; found {
		err = json.Unmarshal(raw, &a.AccessToken)
		if err != nil {
			return fmt.Errorf("error reading 'access_token': %w", err)
		}
		delete(object, "access_token")
	}

	if raw, found := object["expires_in"]; found {
		err = json.Unmarshal(raw, &a.ExpiresIn)
		if err != nil {
			return fmt.Errorf("error reading 'expires_in': %w", err)
		}
		delete(object, "expires_in")
	}

	if raw, found := object["id_token"]; found {
		err = json.Unmarshal(raw, &a.IdToken)
		if err != nil {
			return fmt.Errorf("error reading 'id_token': %w", err)
		}
		delete(object, "id_token")
	}

	if raw, found := object["refresh_token"]; found {
		err = json.Unmarshal(raw, &a.RefreshToken)
		if err != nil {
			return fmt.Errorf("error reading 'refresh_token': %w", err)
		}
		delete(object, "refresh_token")
	}

	if raw, found := object["token_type"]; found {
		err = json.Unmarshal(raw, &a.TokenType)
		if err != nil {
			return fmt.Errorf("error reading 'token_type': %w", err)
		}
		delete(object, "token_type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TokenResponse to handle AdditionalProperties
func (a TokenResponse) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["access_token"], err = json.Marshal(a.AccessToken)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'access_token': %w", err)
	}

	object["expires_in"], err = json.Marshal(a.ExpiresIn)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'expires_in': %w", err)
	}

	if a.IdToken != nil {
		object["id_token"], err = json.Marshal(a.IdToken)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id_token': %w", err)
		}
	}

	if a.RefreshToken != nil {
		object["refresh_token"], err = json.Marshal(a.RefreshToken)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'refresh_token': %w", err)
		}
	}

	object["token_type"], err = json.Marshal(a.TokenType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'token_type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsAudString returns the union data inside the Aud as a AudString
func (t Aud) AsAudString() (AudString, error) {
	var body AudString
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAudString overwrites any union data inside the Aud as the provided AudString
func (t *Aud) FromAudString(v AudString) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAudString performs a merge with any union data inside the Aud, using the provided AudString
func (t *Aud) MergeAudString(v AudString) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAudArray returns the union data inside the Aud as a AudArray
func (t Aud) AsAudArray() (AudArray, error) {
	var body AudArray
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAudArray overwrites any union data inside the Aud as the provided AudArray
func (t *Aud) FromAudArray(v AudArray) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAudArray performs a merge with any union data inside the Aud, using the provided AudArray
func (t *Aud) MergeAudArray(v AudArray) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Aud) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Aud) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBabylonStakingRequestDeposit returns the union data inside the BabylonStakingRequest as a BabylonStakingRequestDeposit
func (t BabylonStakingRequest) AsBabylonStakingRequestDeposit() (BabylonStakingRequestDeposit, error) {
	var body BabylonStakingRequestDeposit
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBabylonStakingRequestDeposit overwrites any union data inside the BabylonStakingRequest as the provided BabylonStakingRequestDeposit
func (t *BabylonStakingRequest) FromBabylonStakingRequestDeposit(v BabylonStakingRequestDeposit) error {
	v.Action = "BabylonStakingRequestDeposit"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBabylonStakingRequestDeposit performs a merge with any union data inside the BabylonStakingRequest, using the provided BabylonStakingRequestDeposit
func (t *BabylonStakingRequest) MergeBabylonStakingRequestDeposit(v BabylonStakingRequestDeposit) error {
	v.Action = "BabylonStakingRequestDeposit"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBabylonStakingRequestEarlyUnbond returns the union data inside the BabylonStakingRequest as a BabylonStakingRequestEarlyUnbond
func (t BabylonStakingRequest) AsBabylonStakingRequestEarlyUnbond() (BabylonStakingRequestEarlyUnbond, error) {
	var body BabylonStakingRequestEarlyUnbond
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBabylonStakingRequestEarlyUnbond overwrites any union data inside the BabylonStakingRequest as the provided BabylonStakingRequestEarlyUnbond
func (t *BabylonStakingRequest) FromBabylonStakingRequestEarlyUnbond(v BabylonStakingRequestEarlyUnbond) error {
	v.Action = "BabylonStakingRequestEarlyUnbond"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBabylonStakingRequestEarlyUnbond performs a merge with any union data inside the BabylonStakingRequest, using the provided BabylonStakingRequestEarlyUnbond
func (t *BabylonStakingRequest) MergeBabylonStakingRequestEarlyUnbond(v BabylonStakingRequestEarlyUnbond) error {
	v.Action = "BabylonStakingRequestEarlyUnbond"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBabylonStakingRequestWithdrawTimelock returns the union data inside the BabylonStakingRequest as a BabylonStakingRequestWithdrawTimelock
func (t BabylonStakingRequest) AsBabylonStakingRequestWithdrawTimelock() (BabylonStakingRequestWithdrawTimelock, error) {
	var body BabylonStakingRequestWithdrawTimelock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBabylonStakingRequestWithdrawTimelock overwrites any union data inside the BabylonStakingRequest as the provided BabylonStakingRequestWithdrawTimelock
func (t *BabylonStakingRequest) FromBabylonStakingRequestWithdrawTimelock(v BabylonStakingRequestWithdrawTimelock) error {
	v.Action = "BabylonStakingRequestWithdrawTimelock"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBabylonStakingRequestWithdrawTimelock performs a merge with any union data inside the BabylonStakingRequest, using the provided BabylonStakingRequestWithdrawTimelock
func (t *BabylonStakingRequest) MergeBabylonStakingRequestWithdrawTimelock(v BabylonStakingRequestWithdrawTimelock) error {
	v.Action = "BabylonStakingRequestWithdrawTimelock"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBabylonStakingRequestWithdrawEarlyUnbond returns the union data inside the BabylonStakingRequest as a BabylonStakingRequestWithdrawEarlyUnbond
func (t BabylonStakingRequest) AsBabylonStakingRequestWithdrawEarlyUnbond() (BabylonStakingRequestWithdrawEarlyUnbond, error) {
	var body BabylonStakingRequestWithdrawEarlyUnbond
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBabylonStakingRequestWithdrawEarlyUnbond overwrites any union data inside the BabylonStakingRequest as the provided BabylonStakingRequestWithdrawEarlyUnbond
func (t *BabylonStakingRequest) FromBabylonStakingRequestWithdrawEarlyUnbond(v BabylonStakingRequestWithdrawEarlyUnbond) error {
	v.Action = "BabylonStakingRequestWithdrawEarlyUnbond"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBabylonStakingRequestWithdrawEarlyUnbond performs a merge with any union data inside the BabylonStakingRequest, using the provided BabylonStakingRequestWithdrawEarlyUnbond
func (t *BabylonStakingRequest) MergeBabylonStakingRequestWithdrawEarlyUnbond(v BabylonStakingRequestWithdrawEarlyUnbond) error {
	v.Action = "BabylonStakingRequestWithdrawEarlyUnbond"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBabylonStakingRequestWithdrawSlashing returns the union data inside the BabylonStakingRequest as a BabylonStakingRequestWithdrawSlashing
func (t BabylonStakingRequest) AsBabylonStakingRequestWithdrawSlashing() (BabylonStakingRequestWithdrawSlashing, error) {
	var body BabylonStakingRequestWithdrawSlashing
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBabylonStakingRequestWithdrawSlashing overwrites any union data inside the BabylonStakingRequest as the provided BabylonStakingRequestWithdrawSlashing
func (t *BabylonStakingRequest) FromBabylonStakingRequestWithdrawSlashing(v BabylonStakingRequestWithdrawSlashing) error {
	v.Action = "BabylonStakingRequestWithdrawSlashing"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBabylonStakingRequestWithdrawSlashing performs a merge with any union data inside the BabylonStakingRequest, using the provided BabylonStakingRequestWithdrawSlashing
func (t *BabylonStakingRequest) MergeBabylonStakingRequestWithdrawSlashing(v BabylonStakingRequestWithdrawSlashing) error {
	v.Action = "BabylonStakingRequestWithdrawSlashing"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBabylonStakingRequestSlashDeposit returns the union data inside the BabylonStakingRequest as a BabylonStakingRequestSlashDeposit
func (t BabylonStakingRequest) AsBabylonStakingRequestSlashDeposit() (BabylonStakingRequestSlashDeposit, error) {
	var body BabylonStakingRequestSlashDeposit
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBabylonStakingRequestSlashDeposit overwrites any union data inside the BabylonStakingRequest as the provided BabylonStakingRequestSlashDeposit
func (t *BabylonStakingRequest) FromBabylonStakingRequestSlashDeposit(v BabylonStakingRequestSlashDeposit) error {
	v.Action = "BabylonStakingRequestSlashDeposit"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBabylonStakingRequestSlashDeposit performs a merge with any union data inside the BabylonStakingRequest, using the provided BabylonStakingRequestSlashDeposit
func (t *BabylonStakingRequest) MergeBabylonStakingRequestSlashDeposit(v BabylonStakingRequestSlashDeposit) error {
	v.Action = "BabylonStakingRequestSlashDeposit"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBabylonStakingRequestSlashEarlyUnbond returns the union data inside the BabylonStakingRequest as a BabylonStakingRequestSlashEarlyUnbond
func (t BabylonStakingRequest) AsBabylonStakingRequestSlashEarlyUnbond() (BabylonStakingRequestSlashEarlyUnbond, error) {
	var body BabylonStakingRequestSlashEarlyUnbond
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBabylonStakingRequestSlashEarlyUnbond overwrites any union data inside the BabylonStakingRequest as the provided BabylonStakingRequestSlashEarlyUnbond
func (t *BabylonStakingRequest) FromBabylonStakingRequestSlashEarlyUnbond(v BabylonStakingRequestSlashEarlyUnbond) error {
	v.Action = "BabylonStakingRequestSlashEarlyUnbond"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBabylonStakingRequestSlashEarlyUnbond performs a merge with any union data inside the BabylonStakingRequest, using the provided BabylonStakingRequestSlashEarlyUnbond
func (t *BabylonStakingRequest) MergeBabylonStakingRequestSlashEarlyUnbond(v BabylonStakingRequestSlashEarlyUnbond) error {
	v.Action = "BabylonStakingRequestSlashEarlyUnbond"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BabylonStakingRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"action"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t BabylonStakingRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "BabylonStakingRequestDeposit":
		return t.AsBabylonStakingRequestDeposit()
	case "BabylonStakingRequestEarlyUnbond":
		return t.AsBabylonStakingRequestEarlyUnbond()
	case "BabylonStakingRequestSlashDeposit":
		return t.AsBabylonStakingRequestSlashDeposit()
	case "BabylonStakingRequestSlashEarlyUnbond":
		return t.AsBabylonStakingRequestSlashEarlyUnbond()
	case "BabylonStakingRequestWithdrawEarlyUnbond":
		return t.AsBabylonStakingRequestWithdrawEarlyUnbond()
	case "BabylonStakingRequestWithdrawSlashing":
		return t.AsBabylonStakingRequestWithdrawSlashing()
	case "BabylonStakingRequestWithdrawTimelock":
		return t.AsBabylonStakingRequestWithdrawTimelock()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t BabylonStakingRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BabylonStakingRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsConfiguredMfaTotp returns the union data inside the ConfiguredMfa as a ConfiguredMfaTotp
func (t ConfiguredMfa) AsConfiguredMfaTotp() (ConfiguredMfaTotp, error) {
	var body ConfiguredMfaTotp
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConfiguredMfaTotp overwrites any union data inside the ConfiguredMfa as the provided ConfiguredMfaTotp
func (t *ConfiguredMfa) FromConfiguredMfaTotp(v ConfiguredMfaTotp) error {
	v.Type = "ConfiguredMfaTotp"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConfiguredMfaTotp performs a merge with any union data inside the ConfiguredMfa, using the provided ConfiguredMfaTotp
func (t *ConfiguredMfa) MergeConfiguredMfaTotp(v ConfiguredMfaTotp) error {
	v.Type = "ConfiguredMfaTotp"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConfiguredMfaFido returns the union data inside the ConfiguredMfa as a ConfiguredMfaFido
func (t ConfiguredMfa) AsConfiguredMfaFido() (ConfiguredMfaFido, error) {
	var body ConfiguredMfaFido
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConfiguredMfaFido overwrites any union data inside the ConfiguredMfa as the provided ConfiguredMfaFido
func (t *ConfiguredMfa) FromConfiguredMfaFido(v ConfiguredMfaFido) error {
	v.Type = "ConfiguredMfaFido"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConfiguredMfaFido performs a merge with any union data inside the ConfiguredMfa, using the provided ConfiguredMfaFido
func (t *ConfiguredMfa) MergeConfiguredMfaFido(v ConfiguredMfaFido) error {
	v.Type = "ConfiguredMfaFido"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ConfiguredMfa) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ConfiguredMfa) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ConfiguredMfaFido":
		return t.AsConfiguredMfaFido()
	case "ConfiguredMfaTotp":
		return t.AsConfiguredMfaTotp()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ConfiguredMfa) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ConfiguredMfa) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDiffieHellmanResponseMasked returns the union data inside the DiffieHellmanResponse as a DiffieHellmanResponseMasked
func (t DiffieHellmanResponse) AsDiffieHellmanResponseMasked() (DiffieHellmanResponseMasked, error) {
	var body DiffieHellmanResponseMasked
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDiffieHellmanResponseMasked overwrites any union data inside the DiffieHellmanResponse as the provided DiffieHellmanResponseMasked
func (t *DiffieHellmanResponse) FromDiffieHellmanResponseMasked(v DiffieHellmanResponseMasked) error {
	v.ResponseType = "DiffieHellmanResponseMasked"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDiffieHellmanResponseMasked performs a merge with any union data inside the DiffieHellmanResponse, using the provided DiffieHellmanResponseMasked
func (t *DiffieHellmanResponse) MergeDiffieHellmanResponseMasked(v DiffieHellmanResponseMasked) error {
	v.ResponseType = "DiffieHellmanResponseMasked"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDiffieHellmanResponseEncrypted returns the union data inside the DiffieHellmanResponse as a DiffieHellmanResponseEncrypted
func (t DiffieHellmanResponse) AsDiffieHellmanResponseEncrypted() (DiffieHellmanResponseEncrypted, error) {
	var body DiffieHellmanResponseEncrypted
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDiffieHellmanResponseEncrypted overwrites any union data inside the DiffieHellmanResponse as the provided DiffieHellmanResponseEncrypted
func (t *DiffieHellmanResponse) FromDiffieHellmanResponseEncrypted(v DiffieHellmanResponseEncrypted) error {
	v.ResponseType = "DiffieHellmanResponseEncrypted"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDiffieHellmanResponseEncrypted performs a merge with any union data inside the DiffieHellmanResponse, using the provided DiffieHellmanResponseEncrypted
func (t *DiffieHellmanResponse) MergeDiffieHellmanResponseEncrypted(v DiffieHellmanResponseEncrypted) error {
	v.ResponseType = "DiffieHellmanResponseEncrypted"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DiffieHellmanResponse) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"response_type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t DiffieHellmanResponse) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "DiffieHellmanResponseEncrypted":
		return t.AsDiffieHellmanResponseEncrypted()
	case "DiffieHellmanResponseMasked":
		return t.AsDiffieHellmanResponseMasked()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t DiffieHellmanResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DiffieHellmanResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEvmOptionsString returns the union data inside the EvmOptions as a EvmOptionsString
func (t EvmOptions) AsEvmOptionsString() (EvmOptionsString, error) {
	var body EvmOptionsString
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmOptionsString overwrites any union data inside the EvmOptions as the provided EvmOptionsString
func (t *EvmOptions) FromEvmOptionsString(v EvmOptionsString) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmOptionsString performs a merge with any union data inside the EvmOptions, using the provided EvmOptionsString
func (t *EvmOptions) MergeEvmOptionsString(v EvmOptionsString) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmOptionsObject returns the union data inside the EvmOptions as a EvmOptionsObject
func (t EvmOptions) AsEvmOptionsObject() (EvmOptionsObject, error) {
	var body EvmOptionsObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmOptionsObject overwrites any union data inside the EvmOptions as the provided EvmOptionsObject
func (t *EvmOptions) FromEvmOptionsObject(v EvmOptionsObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmOptionsObject performs a merge with any union data inside the EvmOptions, using the provided EvmOptionsObject
func (t *EvmOptions) MergeEvmOptionsObject(v EvmOptionsObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EvmOptions) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EvmOptions) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsHttpRequestCmpEq returns the union data inside the HttpRequestCmp as a HttpRequestCmpEq
func (t HttpRequestCmp) AsHttpRequestCmpEq() (HttpRequestCmpEq, error) {
	var body HttpRequestCmpEq
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHttpRequestCmpEq overwrites any union data inside the HttpRequestCmp as the provided HttpRequestCmpEq
func (t *HttpRequestCmp) FromHttpRequestCmpEq(v HttpRequestCmpEq) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHttpRequestCmpEq performs a merge with any union data inside the HttpRequestCmp, using the provided HttpRequestCmpEq
func (t *HttpRequestCmp) MergeHttpRequestCmpEq(v HttpRequestCmpEq) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsHttpRequestCmpEvmTx returns the union data inside the HttpRequestCmp as a HttpRequestCmpEvmTx
func (t HttpRequestCmp) AsHttpRequestCmpEvmTx() (HttpRequestCmpEvmTx, error) {
	var body HttpRequestCmpEvmTx
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHttpRequestCmpEvmTx overwrites any union data inside the HttpRequestCmp as the provided HttpRequestCmpEvmTx
func (t *HttpRequestCmp) FromHttpRequestCmpEvmTx(v HttpRequestCmpEvmTx) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHttpRequestCmpEvmTx performs a merge with any union data inside the HttpRequestCmp, using the provided HttpRequestCmpEvmTx
func (t *HttpRequestCmp) MergeHttpRequestCmpEvmTx(v HttpRequestCmpEvmTx) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsHttpRequestCmpSolanaTx returns the union data inside the HttpRequestCmp as a HttpRequestCmpSolanaTx
func (t HttpRequestCmp) AsHttpRequestCmpSolanaTx() (HttpRequestCmpSolanaTx, error) {
	var body HttpRequestCmpSolanaTx
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHttpRequestCmpSolanaTx overwrites any union data inside the HttpRequestCmp as the provided HttpRequestCmpSolanaTx
func (t *HttpRequestCmp) FromHttpRequestCmpSolanaTx(v HttpRequestCmpSolanaTx) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHttpRequestCmpSolanaTx performs a merge with any union data inside the HttpRequestCmp, using the provided HttpRequestCmpSolanaTx
func (t *HttpRequestCmp) MergeHttpRequestCmpSolanaTx(v HttpRequestCmpSolanaTx) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t HttpRequestCmp) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *HttpRequestCmp) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsJsonKeyPackageRawSecret returns the union data inside the JsonKeyPackage as a JsonKeyPackageRawSecret
func (t JsonKeyPackage) AsJsonKeyPackageRawSecret() (JsonKeyPackageRawSecret, error) {
	var body JsonKeyPackageRawSecret
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJsonKeyPackageRawSecret overwrites any union data inside the JsonKeyPackage as the provided JsonKeyPackageRawSecret
func (t *JsonKeyPackage) FromJsonKeyPackageRawSecret(v JsonKeyPackageRawSecret) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJsonKeyPackageRawSecret performs a merge with any union data inside the JsonKeyPackage, using the provided JsonKeyPackageRawSecret
func (t *JsonKeyPackage) MergeJsonKeyPackageRawSecret(v JsonKeyPackageRawSecret) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJsonKeyPackageEnglishMnemonic returns the union data inside the JsonKeyPackage as a JsonKeyPackageEnglishMnemonic
func (t JsonKeyPackage) AsJsonKeyPackageEnglishMnemonic() (JsonKeyPackageEnglishMnemonic, error) {
	var body JsonKeyPackageEnglishMnemonic
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJsonKeyPackageEnglishMnemonic overwrites any union data inside the JsonKeyPackage as the provided JsonKeyPackageEnglishMnemonic
func (t *JsonKeyPackage) FromJsonKeyPackageEnglishMnemonic(v JsonKeyPackageEnglishMnemonic) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJsonKeyPackageEnglishMnemonic performs a merge with any union data inside the JsonKeyPackage, using the provided JsonKeyPackageEnglishMnemonic
func (t *JsonKeyPackage) MergeJsonKeyPackageEnglishMnemonic(v JsonKeyPackageEnglishMnemonic) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t JsonKeyPackage) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["key_type"], err = json.Marshal(t.KeyType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'key_type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *JsonKeyPackage) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["key_type"]; found {
		err = json.Unmarshal(raw, &t.KeyType)
		if err != nil {
			return fmt.Errorf("error reading 'key_type': %w", err)
		}
	}

	return err
}

// AsOrgMetricDiscriminants returns the union data inside the MetricName as a OrgMetricDiscriminants
func (t MetricName) AsOrgMetricDiscriminants() (OrgMetricDiscriminants, error) {
	var body OrgMetricDiscriminants
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrgMetricDiscriminants overwrites any union data inside the MetricName as the provided OrgMetricDiscriminants
func (t *MetricName) FromOrgMetricDiscriminants(v OrgMetricDiscriminants) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrgMetricDiscriminants performs a merge with any union data inside the MetricName, using the provided OrgMetricDiscriminants
func (t *MetricName) MergeOrgMetricDiscriminants(v OrgMetricDiscriminants) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTsQueryName returns the union data inside the MetricName as a TsQueryName
func (t MetricName) AsTsQueryName() (TsQueryName, error) {
	var body TsQueryName
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTsQueryName overwrites any union data inside the MetricName as the provided TsQueryName
func (t *MetricName) FromTsQueryName(v TsQueryName) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTsQueryName performs a merge with any union data inside the MetricName, using the provided TsQueryName
func (t *MetricName) MergeTsQueryName(v TsQueryName) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MetricName) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MetricName) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMsgStatusPending returns the union data inside the MsgStatus as a MsgStatusPending
func (t MsgStatus) AsMsgStatusPending() (MsgStatusPending, error) {
	var body MsgStatusPending
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMsgStatusPending overwrites any union data inside the MsgStatus as the provided MsgStatusPending
func (t *MsgStatus) FromMsgStatusPending(v MsgStatusPending) error {
	v.Status = "MsgStatusPending"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMsgStatusPending performs a merge with any union data inside the MsgStatus, using the provided MsgStatusPending
func (t *MsgStatus) MergeMsgStatusPending(v MsgStatusPending) error {
	v.Status = "MsgStatusPending"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMsgStatusSigned returns the union data inside the MsgStatus as a MsgStatusSigned
func (t MsgStatus) AsMsgStatusSigned() (MsgStatusSigned, error) {
	var body MsgStatusSigned
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMsgStatusSigned overwrites any union data inside the MsgStatus as the provided MsgStatusSigned
func (t *MsgStatus) FromMsgStatusSigned(v MsgStatusSigned) error {
	v.Status = "MsgStatusSigned"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMsgStatusSigned performs a merge with any union data inside the MsgStatus, using the provided MsgStatusSigned
func (t *MsgStatus) MergeMsgStatusSigned(v MsgStatusSigned) error {
	v.Status = "MsgStatusSigned"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMsgStatusRejected returns the union data inside the MsgStatus as a MsgStatusRejected
func (t MsgStatus) AsMsgStatusRejected() (MsgStatusRejected, error) {
	var body MsgStatusRejected
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMsgStatusRejected overwrites any union data inside the MsgStatus as the provided MsgStatusRejected
func (t *MsgStatus) FromMsgStatusRejected(v MsgStatusRejected) error {
	v.Status = "MsgStatusRejected"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMsgStatusRejected performs a merge with any union data inside the MsgStatus, using the provided MsgStatusRejected
func (t *MsgStatus) MergeMsgStatusRejected(v MsgStatusRejected) error {
	v.Status = "MsgStatusRejected"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MsgStatus) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"status"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t MsgStatus) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "MsgStatusPending":
		return t.AsMsgStatusPending()
	case "MsgStatusRejected":
		return t.AsMsgStatusRejected()
	case "MsgStatusSigned":
		return t.AsMsgStatusSigned()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t MsgStatus) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MsgStatus) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrgEventFilterAll returns the union data inside the OrgEventFilter as a OrgEventFilterAll
func (t OrgEventFilter) AsOrgEventFilterAll() (OrgEventFilterAll, error) {
	var body OrgEventFilterAll
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrgEventFilterAll overwrites any union data inside the OrgEventFilter as the provided OrgEventFilterAll
func (t *OrgEventFilter) FromOrgEventFilterAll(v OrgEventFilterAll) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrgEventFilterAll performs a merge with any union data inside the OrgEventFilter, using the provided OrgEventFilterAll
func (t *OrgEventFilter) MergeOrgEventFilterAll(v OrgEventFilterAll) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrgEventFilterAllExcept returns the union data inside the OrgEventFilter as a OrgEventFilterAllExcept
func (t OrgEventFilter) AsOrgEventFilterAllExcept() (OrgEventFilterAllExcept, error) {
	var body OrgEventFilterAllExcept
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrgEventFilterAllExcept overwrites any union data inside the OrgEventFilter as the provided OrgEventFilterAllExcept
func (t *OrgEventFilter) FromOrgEventFilterAllExcept(v OrgEventFilterAllExcept) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrgEventFilterAllExcept performs a merge with any union data inside the OrgEventFilter, using the provided OrgEventFilterAllExcept
func (t *OrgEventFilter) MergeOrgEventFilterAllExcept(v OrgEventFilterAllExcept) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrgEventFilterOneOf returns the union data inside the OrgEventFilter as a OrgEventFilterOneOf
func (t OrgEventFilter) AsOrgEventFilterOneOf() (OrgEventFilterOneOf, error) {
	var body OrgEventFilterOneOf
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrgEventFilterOneOf overwrites any union data inside the OrgEventFilter as the provided OrgEventFilterOneOf
func (t *OrgEventFilter) FromOrgEventFilterOneOf(v OrgEventFilterOneOf) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrgEventFilterOneOf performs a merge with any union data inside the OrgEventFilter, using the provided OrgEventFilterOneOf
func (t *OrgEventFilter) MergeOrgEventFilterOneOf(v OrgEventFilterOneOf) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrgEventFilter) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrgEventFilter) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrgMetricBillingEvent returns the union data inside the OrgMetric as a OrgMetricBillingEvent
func (t OrgMetric) AsOrgMetricBillingEvent() (OrgMetricBillingEvent, error) {
	var body OrgMetricBillingEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrgMetricBillingEvent overwrites any union data inside the OrgMetric as the provided OrgMetricBillingEvent
func (t *OrgMetric) FromOrgMetricBillingEvent(v OrgMetricBillingEvent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrgMetricBillingEvent performs a merge with any union data inside the OrgMetric, using the provided OrgMetricBillingEvent
func (t *OrgMetric) MergeOrgMetricBillingEvent(v OrgMetricBillingEvent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrgMetricOidcLoginEvent returns the union data inside the OrgMetric as a OrgMetricOidcLoginEvent
func (t OrgMetric) AsOrgMetricOidcLoginEvent() (OrgMetricOidcLoginEvent, error) {
	var body OrgMetricOidcLoginEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrgMetricOidcLoginEvent overwrites any union data inside the OrgMetric as the provided OrgMetricOidcLoginEvent
func (t *OrgMetric) FromOrgMetricOidcLoginEvent(v OrgMetricOidcLoginEvent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrgMetricOidcLoginEvent performs a merge with any union data inside the OrgMetric, using the provided OrgMetricOidcLoginEvent
func (t *OrgMetric) MergeOrgMetricOidcLoginEvent(v OrgMetricOidcLoginEvent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrgMetricSignEvent returns the union data inside the OrgMetric as a OrgMetricSignEvent
func (t OrgMetric) AsOrgMetricSignEvent() (OrgMetricSignEvent, error) {
	var body OrgMetricSignEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrgMetricSignEvent overwrites any union data inside the OrgMetric as the provided OrgMetricSignEvent
func (t *OrgMetric) FromOrgMetricSignEvent(v OrgMetricSignEvent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrgMetricSignEvent performs a merge with any union data inside the OrgMetric, using the provided OrgMetricSignEvent
func (t *OrgMetric) MergeOrgMetricSignEvent(v OrgMetricSignEvent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrgMetricUserCount returns the union data inside the OrgMetric as a OrgMetricUserCount
func (t OrgMetric) AsOrgMetricUserCount() (OrgMetricUserCount, error) {
	var body OrgMetricUserCount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrgMetricUserCount overwrites any union data inside the OrgMetric as the provided OrgMetricUserCount
func (t *OrgMetric) FromOrgMetricUserCount(v OrgMetricUserCount) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrgMetricUserCount performs a merge with any union data inside the OrgMetric, using the provided OrgMetricUserCount
func (t *OrgMetric) MergeOrgMetricUserCount(v OrgMetricUserCount) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrgMetricKeyCount returns the union data inside the OrgMetric as a OrgMetricKeyCount
func (t OrgMetric) AsOrgMetricKeyCount() (OrgMetricKeyCount, error) {
	var body OrgMetricKeyCount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrgMetricKeyCount overwrites any union data inside the OrgMetric as the provided OrgMetricKeyCount
func (t *OrgMetric) FromOrgMetricKeyCount(v OrgMetricKeyCount) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrgMetricKeyCount performs a merge with any union data inside the OrgMetric, using the provided OrgMetricKeyCount
func (t *OrgMetric) MergeOrgMetricKeyCount(v OrgMetricKeyCount) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrgMetric) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrgMetric) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPolicyAttachedToIdObject returns the union data inside the PolicyAttachedToId as a PolicyAttachedToIdObject
func (t PolicyAttachedToId) AsPolicyAttachedToIdObject() (PolicyAttachedToIdObject, error) {
	var body PolicyAttachedToIdObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPolicyAttachedToIdObject overwrites any union data inside the PolicyAttachedToId as the provided PolicyAttachedToIdObject
func (t *PolicyAttachedToId) FromPolicyAttachedToIdObject(v PolicyAttachedToIdObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePolicyAttachedToIdObject performs a merge with any union data inside the PolicyAttachedToId, using the provided PolicyAttachedToIdObject
func (t *PolicyAttachedToId) MergePolicyAttachedToIdObject(v PolicyAttachedToIdObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPolicyAttachedToIdkeyId returns the union data inside the PolicyAttachedToId as a PolicyAttachedToIdkeyId
func (t PolicyAttachedToId) AsPolicyAttachedToIdkeyId() (PolicyAttachedToIdkeyId, error) {
	var body PolicyAttachedToIdkeyId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPolicyAttachedToIdkeyId overwrites any union data inside the PolicyAttachedToId as the provided PolicyAttachedToIdkeyId
func (t *PolicyAttachedToId) FromPolicyAttachedToIdkeyId(v PolicyAttachedToIdkeyId) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePolicyAttachedToIdkeyId performs a merge with any union data inside the PolicyAttachedToId, using the provided PolicyAttachedToIdkeyId
func (t *PolicyAttachedToId) MergePolicyAttachedToIdkeyId(v PolicyAttachedToIdkeyId) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPolicyAttachedToIdroleId returns the union data inside the PolicyAttachedToId as a PolicyAttachedToIdroleId
func (t PolicyAttachedToId) AsPolicyAttachedToIdroleId() (PolicyAttachedToIdroleId, error) {
	var body PolicyAttachedToIdroleId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPolicyAttachedToIdroleId overwrites any union data inside the PolicyAttachedToId as the provided PolicyAttachedToIdroleId
func (t *PolicyAttachedToId) FromPolicyAttachedToIdroleId(v PolicyAttachedToIdroleId) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePolicyAttachedToIdroleId performs a merge with any union data inside the PolicyAttachedToId, using the provided PolicyAttachedToIdroleId
func (t *PolicyAttachedToId) MergePolicyAttachedToIdroleId(v PolicyAttachedToIdroleId) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PolicyAttachedToId) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PolicyAttachedToId) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPolicyErrorOwnCodes returns the union data inside the PolicyErrorCode as a PolicyErrorOwnCodes
func (t PolicyErrorCode) AsPolicyErrorOwnCodes() (PolicyErrorOwnCodes, error) {
	var body PolicyErrorOwnCodes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPolicyErrorOwnCodes overwrites any union data inside the PolicyErrorCode as the provided PolicyErrorOwnCodes
func (t *PolicyErrorCode) FromPolicyErrorOwnCodes(v PolicyErrorOwnCodes) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePolicyErrorOwnCodes performs a merge with any union data inside the PolicyErrorCode, using the provided PolicyErrorOwnCodes
func (t *PolicyErrorCode) MergePolicyErrorOwnCodes(v PolicyErrorOwnCodes) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmTxDepositErrorCode returns the union data inside the PolicyErrorCode as a EvmTxDepositErrorCode
func (t PolicyErrorCode) AsEvmTxDepositErrorCode() (EvmTxDepositErrorCode, error) {
	var body EvmTxDepositErrorCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmTxDepositErrorCode overwrites any union data inside the PolicyErrorCode as the provided EvmTxDepositErrorCode
func (t *PolicyErrorCode) FromEvmTxDepositErrorCode(v EvmTxDepositErrorCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmTxDepositErrorCode performs a merge with any union data inside the PolicyErrorCode, using the provided EvmTxDepositErrorCode
func (t *PolicyErrorCode) MergeEvmTxDepositErrorCode(v EvmTxDepositErrorCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PolicyErrorCode) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PolicyErrorCode) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPreconditionErrorOwnCodes returns the union data inside the PreconditionErrorCode as a PreconditionErrorOwnCodes
func (t PreconditionErrorCode) AsPreconditionErrorOwnCodes() (PreconditionErrorOwnCodes, error) {
	var body PreconditionErrorOwnCodes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreconditionErrorOwnCodes overwrites any union data inside the PreconditionErrorCode as the provided PreconditionErrorOwnCodes
func (t *PreconditionErrorCode) FromPreconditionErrorOwnCodes(v PreconditionErrorOwnCodes) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreconditionErrorOwnCodes performs a merge with any union data inside the PreconditionErrorCode, using the provided PreconditionErrorOwnCodes
func (t *PreconditionErrorCode) MergePreconditionErrorOwnCodes(v PreconditionErrorOwnCodes) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPolicyErrorCode returns the union data inside the PreconditionErrorCode as a PolicyErrorCode
func (t PreconditionErrorCode) AsPolicyErrorCode() (PolicyErrorCode, error) {
	var body PolicyErrorCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPolicyErrorCode overwrites any union data inside the PreconditionErrorCode as the provided PolicyErrorCode
func (t *PreconditionErrorCode) FromPolicyErrorCode(v PolicyErrorCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePolicyErrorCode performs a merge with any union data inside the PreconditionErrorCode, using the provided PolicyErrorCode
func (t *PreconditionErrorCode) MergePolicyErrorCode(v PolicyErrorCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PreconditionErrorCode) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PreconditionErrorCode) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPrevOutputsOne returns the union data inside the PrevOutputs as a PrevOutputsOne
func (t PrevOutputs) AsPrevOutputsOne() (PrevOutputsOne, error) {
	var body PrevOutputsOne
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPrevOutputsOne overwrites any union data inside the PrevOutputs as the provided PrevOutputsOne
func (t *PrevOutputs) FromPrevOutputsOne(v PrevOutputsOne) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePrevOutputsOne performs a merge with any union data inside the PrevOutputs, using the provided PrevOutputsOne
func (t *PrevOutputs) MergePrevOutputsOne(v PrevOutputsOne) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPrevOutputsAll returns the union data inside the PrevOutputs as a PrevOutputsAll
func (t PrevOutputs) AsPrevOutputsAll() (PrevOutputsAll, error) {
	var body PrevOutputsAll
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPrevOutputsAll overwrites any union data inside the PrevOutputs as the provided PrevOutputsAll
func (t *PrevOutputs) FromPrevOutputsAll(v PrevOutputsAll) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePrevOutputsAll performs a merge with any union data inside the PrevOutputs, using the provided PrevOutputsAll
func (t *PrevOutputs) MergePrevOutputsAll(v PrevOutputsAll) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PrevOutputs) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PrevOutputs) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAuthenticatorAttestationResponse returns the union data inside the PublicKeyCredential_Response as a AuthenticatorAttestationResponse
func (t PublicKeyCredential_Response) AsAuthenticatorAttestationResponse() (AuthenticatorAttestationResponse, error) {
	var body AuthenticatorAttestationResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAuthenticatorAttestationResponse overwrites any union data inside the PublicKeyCredential_Response as the provided AuthenticatorAttestationResponse
func (t *PublicKeyCredential_Response) FromAuthenticatorAttestationResponse(v AuthenticatorAttestationResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAuthenticatorAttestationResponse performs a merge with any union data inside the PublicKeyCredential_Response, using the provided AuthenticatorAttestationResponse
func (t *PublicKeyCredential_Response) MergeAuthenticatorAttestationResponse(v AuthenticatorAttestationResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAuthenticatorAssertionResponse returns the union data inside the PublicKeyCredential_Response as a AuthenticatorAssertionResponse
func (t PublicKeyCredential_Response) AsAuthenticatorAssertionResponse() (AuthenticatorAssertionResponse, error) {
	var body AuthenticatorAssertionResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAuthenticatorAssertionResponse overwrites any union data inside the PublicKeyCredential_Response as the provided AuthenticatorAssertionResponse
func (t *PublicKeyCredential_Response) FromAuthenticatorAssertionResponse(v AuthenticatorAssertionResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAuthenticatorAssertionResponse performs a merge with any union data inside the PublicKeyCredential_Response, using the provided AuthenticatorAssertionResponse
func (t *PublicKeyCredential_Response) MergeAuthenticatorAssertionResponse(v AuthenticatorAssertionResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PublicKeyCredential_Response) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PublicKeyCredential_Response) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsExplicitScopes returns the union data inside the Scope as a ExplicitScopes
func (t ScopeType) AsExplicitScopes() (ExplicitScopes, error) {
	var body ExplicitScopes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExplicitScopes overwrites any union data inside the Scope as the provided ExplicitScopes
func (t *ScopeType) FromExplicitScopes(v ExplicitScopes) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExplicitScopes performs a merge with any union data inside the Scope, using the provided ExplicitScopes
func (t *ScopeType) MergeExplicitScopes(v ExplicitScopes) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOtherScopes returns the union data inside the Scope as a OtherScopes
func (t ScopeType) AsOtherScopes() (OtherScopes, error) {
	var body OtherScopes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOtherScopes overwrites any union data inside the Scope as the provided OtherScopes
func (t *ScopeType) FromOtherScopes(v OtherScopes) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOtherScopes performs a merge with any union data inside the Scope, using the provided OtherScopes
func (t *ScopeType) MergeOtherScopes(v OtherScopes) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ScopeType) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ScopeType) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsScopeSetAll returns the union data inside the ScopeSet as a ScopeSetAll
func (t ScopeSet) AsScopeSetAll() (ScopeSetAll, error) {
	var body ScopeSetAll
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScopeSetAll overwrites any union data inside the ScopeSet as the provided ScopeSetAll
func (t *ScopeSet) FromScopeSetAll(v ScopeSetAll) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScopeSetAll performs a merge with any union data inside the ScopeSet, using the provided ScopeSetAll
func (t *ScopeSet) MergeScopeSetAll(v ScopeSetAll) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScopeSetAllExcept returns the union data inside the ScopeSet as a ScopeSetAllExcept
func (t ScopeSet) AsScopeSetAllExcept() (ScopeSetAllExcept, error) {
	var body ScopeSetAllExcept
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScopeSetAllExcept overwrites any union data inside the ScopeSet as the provided ScopeSetAllExcept
func (t *ScopeSet) FromScopeSetAllExcept(v ScopeSetAllExcept) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScopeSetAllExcept performs a merge with any union data inside the ScopeSet, using the provided ScopeSetAllExcept
func (t *ScopeSet) MergeScopeSetAllExcept(v ScopeSetAllExcept) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScopeSetAllOf returns the union data inside the ScopeSet as a ScopeSetAllOf
func (t ScopeSet) AsScopeSetAllOf() (ScopeSetAllOf, error) {
	var body ScopeSetAllOf
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScopeSetAllOf overwrites any union data inside the ScopeSet as the provided ScopeSetAllOf
func (t *ScopeSet) FromScopeSetAllOf(v ScopeSetAllOf) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScopeSetAllOf performs a merge with any union data inside the ScopeSet, using the provided ScopeSetAllOf
func (t *ScopeSet) MergeScopeSetAllOf(v ScopeSetAllOf) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ScopeSet) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ScopeSet) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSecretValueString returns the union data inside the SecretValue as a SecretValueString
func (t SecretValue) AsSecretValueString() (SecretValueString, error) {
	var body SecretValueString
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecretValueString overwrites any union data inside the SecretValue as the provided SecretValueString
func (t *SecretValue) FromSecretValueString(v SecretValueString) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecretValueString performs a merge with any union data inside the SecretValue, using the provided SecretValueString
func (t *SecretValue) MergeSecretValueString(v SecretValueString) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecretValueObject returns the union data inside the SecretValue as a SecretValueObject
func (t SecretValue) AsSecretValueObject() (SecretValueObject, error) {
	var body SecretValueObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecretValueObject overwrites any union data inside the SecretValue as the provided SecretValueObject
func (t *SecretValue) FromSecretValueObject(v SecretValueObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecretValueObject performs a merge with any union data inside the SecretValue, using the provided SecretValueObject
func (t *SecretValue) MergeSecretValueObject(v SecretValueObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SecretValue) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SecretValue) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSignerErrorOwnCodes returns the union data inside the SignerErrorCode as a SignerErrorOwnCodes
func (t SignerErrorCode) AsSignerErrorOwnCodes() (SignerErrorOwnCodes, error) {
	var body SignerErrorOwnCodes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSignerErrorOwnCodes overwrites any union data inside the SignerErrorCode as the provided SignerErrorOwnCodes
func (t *SignerErrorCode) FromSignerErrorOwnCodes(v SignerErrorOwnCodes) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSignerErrorOwnCodes performs a merge with any union data inside the SignerErrorCode, using the provided SignerErrorOwnCodes
func (t *SignerErrorCode) MergeSignerErrorOwnCodes(v SignerErrorOwnCodes) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAcceptedValueCode returns the union data inside the SignerErrorCode as a AcceptedValueCode
func (t SignerErrorCode) AsAcceptedValueCode() (AcceptedValueCode, error) {
	var body AcceptedValueCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAcceptedValueCode overwrites any union data inside the SignerErrorCode as the provided AcceptedValueCode
func (t *SignerErrorCode) FromAcceptedValueCode(v AcceptedValueCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAcceptedValueCode performs a merge with any union data inside the SignerErrorCode, using the provided AcceptedValueCode
func (t *SignerErrorCode) MergeAcceptedValueCode(v AcceptedValueCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBadRequestErrorCode returns the union data inside the SignerErrorCode as a BadRequestErrorCode
func (t SignerErrorCode) AsBadRequestErrorCode() (BadRequestErrorCode, error) {
	var body BadRequestErrorCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBadRequestErrorCode overwrites any union data inside the SignerErrorCode as the provided BadRequestErrorCode
func (t *SignerErrorCode) FromBadRequestErrorCode(v BadRequestErrorCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBadRequestErrorCode performs a merge with any union data inside the SignerErrorCode, using the provided BadRequestErrorCode
func (t *SignerErrorCode) MergeBadRequestErrorCode(v BadRequestErrorCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBadGatewayErrorCode returns the union data inside the SignerErrorCode as a BadGatewayErrorCode
func (t SignerErrorCode) AsBadGatewayErrorCode() (BadGatewayErrorCode, error) {
	var body BadGatewayErrorCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBadGatewayErrorCode overwrites any union data inside the SignerErrorCode as the provided BadGatewayErrorCode
func (t *SignerErrorCode) FromBadGatewayErrorCode(v BadGatewayErrorCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBadGatewayErrorCode performs a merge with any union data inside the SignerErrorCode, using the provided BadGatewayErrorCode
func (t *SignerErrorCode) MergeBadGatewayErrorCode(v BadGatewayErrorCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNotFoundErrorCode returns the union data inside the SignerErrorCode as a NotFoundErrorCode
func (t SignerErrorCode) AsNotFoundErrorCode() (NotFoundErrorCode, error) {
	var body NotFoundErrorCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNotFoundErrorCode overwrites any union data inside the SignerErrorCode as the provided NotFoundErrorCode
func (t *SignerErrorCode) FromNotFoundErrorCode(v NotFoundErrorCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNotFoundErrorCode performs a merge with any union data inside the SignerErrorCode, using the provided NotFoundErrorCode
func (t *SignerErrorCode) MergeNotFoundErrorCode(v NotFoundErrorCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenErrorCode returns the union data inside the SignerErrorCode as a ForbiddenErrorCode
func (t SignerErrorCode) AsForbiddenErrorCode() (ForbiddenErrorCode, error) {
	var body ForbiddenErrorCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenErrorCode overwrites any union data inside the SignerErrorCode as the provided ForbiddenErrorCode
func (t *SignerErrorCode) FromForbiddenErrorCode(v ForbiddenErrorCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenErrorCode performs a merge with any union data inside the SignerErrorCode, using the provided ForbiddenErrorCode
func (t *SignerErrorCode) MergeForbiddenErrorCode(v ForbiddenErrorCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedErrorCode returns the union data inside the SignerErrorCode as a UnauthorizedErrorCode
func (t SignerErrorCode) AsUnauthorizedErrorCode() (UnauthorizedErrorCode, error) {
	var body UnauthorizedErrorCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedErrorCode overwrites any union data inside the SignerErrorCode as the provided UnauthorizedErrorCode
func (t *SignerErrorCode) FromUnauthorizedErrorCode(v UnauthorizedErrorCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedErrorCode performs a merge with any union data inside the SignerErrorCode, using the provided UnauthorizedErrorCode
func (t *SignerErrorCode) MergeUnauthorizedErrorCode(v UnauthorizedErrorCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPreconditionErrorCode returns the union data inside the SignerErrorCode as a PreconditionErrorCode
func (t SignerErrorCode) AsPreconditionErrorCode() (PreconditionErrorCode, error) {
	var body PreconditionErrorCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreconditionErrorCode overwrites any union data inside the SignerErrorCode as the provided PreconditionErrorCode
func (t *SignerErrorCode) FromPreconditionErrorCode(v PreconditionErrorCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreconditionErrorCode performs a merge with any union data inside the SignerErrorCode, using the provided PreconditionErrorCode
func (t *SignerErrorCode) MergePreconditionErrorCode(v PreconditionErrorCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTimeoutErrorCode returns the union data inside the SignerErrorCode as a TimeoutErrorCode
func (t SignerErrorCode) AsTimeoutErrorCode() (TimeoutErrorCode, error) {
	var body TimeoutErrorCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTimeoutErrorCode overwrites any union data inside the SignerErrorCode as the provided TimeoutErrorCode
func (t *SignerErrorCode) FromTimeoutErrorCode(v TimeoutErrorCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTimeoutErrorCode performs a merge with any union data inside the SignerErrorCode, using the provided TimeoutErrorCode
func (t *SignerErrorCode) MergeTimeoutErrorCode(v TimeoutErrorCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConflictErrorCode returns the union data inside the SignerErrorCode as a ConflictErrorCode
func (t SignerErrorCode) AsConflictErrorCode() (ConflictErrorCode, error) {
	var body ConflictErrorCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConflictErrorCode overwrites any union data inside the SignerErrorCode as the provided ConflictErrorCode
func (t *SignerErrorCode) FromConflictErrorCode(v ConflictErrorCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConflictErrorCode performs a merge with any union data inside the SignerErrorCode, using the provided ConflictErrorCode
func (t *SignerErrorCode) MergeConflictErrorCode(v ConflictErrorCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInternalErrorCode returns the union data inside the SignerErrorCode as a InternalErrorCode
func (t SignerErrorCode) AsInternalErrorCode() (InternalErrorCode, error) {
	var body InternalErrorCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInternalErrorCode overwrites any union data inside the SignerErrorCode as the provided InternalErrorCode
func (t *SignerErrorCode) FromInternalErrorCode(v InternalErrorCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInternalErrorCode performs a merge with any union data inside the SignerErrorCode, using the provided InternalErrorCode
func (t *SignerErrorCode) MergeInternalErrorCode(v InternalErrorCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SignerErrorCode) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SignerErrorCode) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTransactionAndStatus0 returns the union data inside the TransactionAndStatus as a TransactionAndStatus0
func (t TransactionAndStatus) AsTransactionAndStatus0() (TransactionAndStatus0, error) {
	var body TransactionAndStatus0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTransactionAndStatus0 overwrites any union data inside the TransactionAndStatus as the provided TransactionAndStatus0
func (t *TransactionAndStatus) FromTransactionAndStatus0(v TransactionAndStatus0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTransactionAndStatus0 performs a merge with any union data inside the TransactionAndStatus, using the provided TransactionAndStatus0
func (t *TransactionAndStatus) MergeTransactionAndStatus0(v TransactionAndStatus0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTransactionAndStatus1 returns the union data inside the TransactionAndStatus as a TransactionAndStatus1
func (t TransactionAndStatus) AsTransactionAndStatus1() (TransactionAndStatus1, error) {
	var body TransactionAndStatus1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTransactionAndStatus1 overwrites any union data inside the TransactionAndStatus as the provided TransactionAndStatus1
func (t *TransactionAndStatus) FromTransactionAndStatus1(v TransactionAndStatus1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTransactionAndStatus1 performs a merge with any union data inside the TransactionAndStatus, using the provided TransactionAndStatus1
func (t *TransactionAndStatus) MergeTransactionAndStatus1(v TransactionAndStatus1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TransactionAndStatus) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Hash != nil {
		object["hash"], err = json.Marshal(t.Hash)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'hash': %w", err)
		}
	}

	object["id"], err = json.Marshal(t.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if t.Nonce != nil {
		object["nonce"], err = json.Marshal(t.Nonce)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nonce': %w", err)
		}
	}

	if t.SignedRawTransaction != nil {
		object["signedRawTransaction"], err = json.Marshal(t.SignedRawTransaction)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'signedRawTransaction': %w", err)
		}
	}

	object["status"], err = json.Marshal(t.Status)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'status': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *TransactionAndStatus) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["hash"]; found {
		err = json.Unmarshal(raw, &t.Hash)
		if err != nil {
			return fmt.Errorf("error reading 'hash': %w", err)
		}
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["nonce"]; found {
		err = json.Unmarshal(raw, &t.Nonce)
		if err != nil {
			return fmt.Errorf("error reading 'nonce': %w", err)
		}
	}

	if raw, found := object["signedRawTransaction"]; found {
		err = json.Unmarshal(raw, &t.SignedRawTransaction)
		if err != nil {
			return fmt.Errorf("error reading 'signedRawTransaction': %w", err)
		}
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &t.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
	}

	return err
}

// AsTxStatusPending returns the union data inside the TxStatus as a TxStatusPending
func (t TxStatus) AsTxStatusPending() (TxStatusPending, error) {
	var body TxStatusPending
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTxStatusPending overwrites any union data inside the TxStatus as the provided TxStatusPending
func (t *TxStatus) FromTxStatusPending(v TxStatusPending) error {
	v.Status = "TxStatusPending"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTxStatusPending performs a merge with any union data inside the TxStatus, using the provided TxStatusPending
func (t *TxStatus) MergeTxStatusPending(v TxStatusPending) error {
	v.Status = "TxStatusPending"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTxStatusSigned returns the union data inside the TxStatus as a TxStatusSigned
func (t TxStatus) AsTxStatusSigned() (TxStatusSigned, error) {
	var body TxStatusSigned
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTxStatusSigned overwrites any union data inside the TxStatus as the provided TxStatusSigned
func (t *TxStatus) FromTxStatusSigned(v TxStatusSigned) error {
	v.Status = "TxStatusSigned"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTxStatusSigned performs a merge with any union data inside the TxStatus, using the provided TxStatusSigned
func (t *TxStatus) MergeTxStatusSigned(v TxStatusSigned) error {
	v.Status = "TxStatusSigned"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTxStatusRejected returns the union data inside the TxStatus as a TxStatusRejected
func (t TxStatus) AsTxStatusRejected() (TxStatusRejected, error) {
	var body TxStatusRejected
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTxStatusRejected overwrites any union data inside the TxStatus as the provided TxStatusRejected
func (t *TxStatus) FromTxStatusRejected(v TxStatusRejected) error {
	v.Status = "TxStatusRejected"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTxStatusRejected performs a merge with any union data inside the TxStatus, using the provided TxStatusRejected
func (t *TxStatus) MergeTxStatusRejected(v TxStatusRejected) error {
	v.Status = "TxStatusRejected"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TxStatus) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"status"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t TxStatus) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "TxStatusPending":
		return t.AsTxStatusPending()
	case "TxStatusRejected":
		return t.AsTxStatusRejected()
	case "TxStatusSigned":
		return t.AsTxStatusSigned()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t TxStatus) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TxStatus) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTypedDataString returns the union data inside the TypedDataDomainSalt as a TypedDataString
func (t TypedDataDomainSalt) AsTypedDataString() (TypedDataString, error) {
	var body TypedDataString
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTypedDataString overwrites any union data inside the TypedDataDomainSalt as the provided TypedDataString
func (t *TypedDataDomainSalt) FromTypedDataString(v TypedDataString) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTypedDataString performs a merge with any union data inside the TypedDataDomainSalt, using the provided TypedDataString
func (t *TypedDataDomainSalt) MergeTypedDataString(v TypedDataString) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTypedDataArray returns the union data inside the TypedDataDomainSalt as a TypedDataArray
func (t TypedDataDomainSalt) AsTypedDataArray() (TypedDataArray, error) {
	var body TypedDataArray
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTypedDataArray overwrites any union data inside the TypedDataDomainSalt as the provided TypedDataArray
func (t *TypedDataDomainSalt) FromTypedDataArray(v TypedDataArray) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTypedDataArray performs a merge with any union data inside the TypedDataDomainSalt, using the provided TypedDataArray
func (t *TypedDataDomainSalt) MergeTypedDataArray(v TypedDataArray) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TypedDataDomainSalt) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TypedDataDomainSalt) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTypedTransactionLegacy returns the union data inside the TypedTransaction as a TypedTransactionLegacy
func (t TypedTransaction) AsTypedTransactionLegacy() (TypedTransactionLegacy, error) {
	var body TypedTransactionLegacy
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTypedTransactionLegacy overwrites any union data inside the TypedTransaction as the provided TypedTransactionLegacy
func (t *TypedTransaction) FromTypedTransactionLegacy(v TypedTransactionLegacy) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTypedTransactionLegacy performs a merge with any union data inside the TypedTransaction, using the provided TypedTransactionLegacy
func (t *TypedTransaction) MergeTypedTransactionLegacy(v TypedTransactionLegacy) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTypedTransactionEip1559 returns the union data inside the TypedTransaction as a TypedTransactionEip1559
func (t TypedTransaction) AsTypedTransactionEip1559() (TypedTransactionEip1559, error) {
	var body TypedTransactionEip1559
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTypedTransactionEip1559 overwrites any union data inside the TypedTransaction as the provided TypedTransactionEip1559
func (t *TypedTransaction) FromTypedTransactionEip1559(v TypedTransactionEip1559) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTypedTransactionEip1559 performs a merge with any union data inside the TypedTransaction, using the provided TypedTransactionEip1559
func (t *TypedTransaction) MergeTypedTransactionEip1559(v TypedTransactionEip1559) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TypedTransaction) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TypedTransaction) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsWasmPolicyResponseAllow returns the union data inside the WasmPolicyResponse as a WasmPolicyResponseAllow
func (t WasmPolicyResponse) AsWasmPolicyResponseAllow() (WasmPolicyResponseAllow, error) {
	var body WasmPolicyResponseAllow
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWasmPolicyResponseAllow overwrites any union data inside the WasmPolicyResponse as the provided WasmPolicyResponseAllow
func (t *WasmPolicyResponse) FromWasmPolicyResponseAllow(v WasmPolicyResponseAllow) error {
	v.Response = "WasmPolicyResponseAllow"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWasmPolicyResponseAllow performs a merge with any union data inside the WasmPolicyResponse, using the provided WasmPolicyResponseAllow
func (t *WasmPolicyResponse) MergeWasmPolicyResponseAllow(v WasmPolicyResponseAllow) error {
	v.Response = "WasmPolicyResponseAllow"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWasmPolicyResponseDeny returns the union data inside the WasmPolicyResponse as a WasmPolicyResponseDeny
func (t WasmPolicyResponse) AsWasmPolicyResponseDeny() (WasmPolicyResponseDeny, error) {
	var body WasmPolicyResponseDeny
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWasmPolicyResponseDeny overwrites any union data inside the WasmPolicyResponse as the provided WasmPolicyResponseDeny
func (t *WasmPolicyResponse) FromWasmPolicyResponseDeny(v WasmPolicyResponseDeny) error {
	v.Response = "WasmPolicyResponseDeny"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWasmPolicyResponseDeny performs a merge with any union data inside the WasmPolicyResponse, using the provided WasmPolicyResponseDeny
func (t *WasmPolicyResponse) MergeWasmPolicyResponseDeny(v WasmPolicyResponseDeny) error {
	v.Response = "WasmPolicyResponseDeny"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWasmPolicyResponseError returns the union data inside the WasmPolicyResponse as a WasmPolicyResponseError
func (t WasmPolicyResponse) AsWasmPolicyResponseError() (WasmPolicyResponseError, error) {
	var body WasmPolicyResponseError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWasmPolicyResponseError overwrites any union data inside the WasmPolicyResponse as the provided WasmPolicyResponseError
func (t *WasmPolicyResponse) FromWasmPolicyResponseError(v WasmPolicyResponseError) error {
	v.Response = "WasmPolicyResponseError"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWasmPolicyResponseError performs a merge with any union data inside the WasmPolicyResponse, using the provided WasmPolicyResponseError
func (t *WasmPolicyResponse) MergeWasmPolicyResponseError(v WasmPolicyResponseError) error {
	v.Response = "WasmPolicyResponseError"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t WasmPolicyResponse) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"response"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t WasmPolicyResponse) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "WasmPolicyResponseAllow":
		return t.AsWasmPolicyResponseAllow()
	case "WasmPolicyResponseDeny":
		return t.AsWasmPolicyResponseDeny()
	case "WasmPolicyResponseError":
		return t.AsWasmPolicyResponseError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t WasmPolicyResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *WasmPolicyResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
